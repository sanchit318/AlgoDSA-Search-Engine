 b'You given string consisting letters \'a\' \'b\'. In single step remove one palindromic subsequence s.\nReturn minimum number steps make given string empty.\nA string subsequence given string generated deleting characters given string without changing order. Note subsequence necessarily need contiguous.\nA string called palindrome one reads backward well forward.\n\xc2\xa0\nExample 1:\nInput: = "ababa"\nOutput: 1\nExplanation: already palindrome, entirety removed single step.\n\nExample 2:\nInput: = "abb"\nOutput: 2\nExplanation: "abb" -> "bb" -> "". \nRemove palindromic subsequence "a" "bb".\n\nExample 3:\nInput: = "baabb"\nOutput: 2\nExplanation: "baabb" -> "b" -> "". \nRemove palindromic subsequence "baab" "b".\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 1000\ns[i] either \'a\' \'b\'.\n\n' b'Given array integers nums\xc2\xa0and integer target, return indices two numbers add target.\nYou may assume input would exactly one solution, may use element twice.\nYou return answer order.\n\xc2\xa0\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\xc2\xa0\nConstraints:\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\n\n\xc2\xa0\nFollow-up:\xc2\xa0Can come algorithm less than\xc2\xa0O(n2)\xc2\xa0time complexity?' b'You given two non-empty linked lists representing two non-negative integers. The digits stored reverse order, nodes contains single digit. Add two numbers return sum\xc2\xa0as linked list.\nYou may assume two numbers contain leading zero, except number 0 itself.\n\xc2\xa0\nExample 1:\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes linked list range [1, 100].\n0 <= Node.val <= 9\nIt guaranteed list represents number leading zeros.\n\n' b'Given string s, find length longest substring without repeating characters.\n\xc2\xa0\nExample 1:\nInput: = "abcabcbb"\nOutput: 3\nExplanation: The answer "abc", length 3.\n\nExample 2:\nInput: = "bbbbb"\nOutput: 1\nExplanation: The answer "b", length 1.\n\nExample 3:\nInput: = "pwwkew"\nOutput: 3\nExplanation: The answer "wke", length 3.\nNotice answer must substring, "pwke" subsequence substring.\n\n\xc2\xa0\nConstraints:\n\n0 <= s.length <= 5 * 104\ns consists English letters, digits, symbols spaces.\n\n' b'Given two sorted arrays nums1 nums2 size n respectively, return median two sorted arrays.\nThe overall run time complexity O(log (m+n)).\n\xc2\xa0\nExample 1:\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] median 2.\n\nExample 2:\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] median (2 + 3) / 2 = 2.5.\n\n\xc2\xa0\nConstraints:\n\nnums1.length == m\nnums2.length == n\n0 <= <= 1000\n0 <= n <= 1000\n1 <= + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106\n\n' b'Given string s, return longest palindromic substring s.\n\xc2\xa0\nExample 1:\nInput: = "babad"\nOutput: "bab"\nExplanation: "aba" also valid answer.\n\nExample 2:\nInput: = "cbbd"\nOutput: "bb"\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 1000\ns consist digits English letters.\n\n' b'The string "PAYPALISHIRING" written zigzag pattern given number rows like this: (you may want display pattern fixed font better legibility)\nP A H N\nA P L S I I G\nY I R\n\nAnd read line line: "PAHNAPLSIIGYIR"\nWrite code take string make conversion given number rows:\nstring convert(string s, int numRows);\n\n\xc2\xa0\nExample 1:\nInput: = "PAYPALISHIRING", numRows = 3\nOutput: "PAHNAPLSIIGYIR"\n\nExample 2:\nInput: = "PAYPALISHIRING", numRows = 4\nOutput: "PINALSIGYAHRPI"\nExplanation:\nP I N\nA L S I G\nY A H R\nP I\n\nExample 3:\nInput: = "A", numRows = 1\nOutput: "A"\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 1000\ns consists English letters (lower-case upper-case), \',\' \'.\'.\n1 <= numRows <= 1000\n\n' b'Given signed 32-bit integer x, return x digits reversed. If reversing x causes value go outside signed 32-bit integer range [-231, 231 - 1], return 0.\nAssume environment allow store 64-bit integers (signed unsigned).\n\xc2\xa0\nExample 1:\nInput: x = 123\nOutput: 321\n\nExample 2:\nInput: x = -123\nOutput: -321\n\nExample 3:\nInput: x = 120\nOutput: 21\n\n\xc2\xa0\nConstraints:\n\n-231 <= x <= 231 - 1\n\n' b'Implement myAtoi(string s) function, converts string 32-bit signed integer (similar C/C++\'s atoi function).\nThe algorithm myAtoi(string s) follows:\n\nRead ignore leading whitespace.\nCheck next character (if already end string) \'-\' \'+\'. Read character either. This determines final result negative positive respectively. Assume result positive neither present.\nRead next characters next non-digit character end input reached. The rest string ignored.\nConvert digits integer (i.e. "123" -> 123, "0032" -> 32). If digits read, integer 0. Change sign necessary (from step 2).\nIf integer 32-bit signed integer range [-231, 231 - 1], clamp integer remains range. Specifically, integers less -231 clamped -231, integers greater 231 - 1 clamped 231 - 1.\nReturn integer final result.\n\nNote:\n\nOnly space character \' \' considered whitespace character.\nDo ignore characters leading whitespace rest string digits.\n\n\xc2\xa0\nExample 1:\nInput: = "42"\nOutput: 42\nExplanation: The underlined characters read in, caret current reader position.\nStep 1: "42" (no characters read leading whitespace)\n ^\nStep 2: "42" (no characters read neither \'-\' \'+\')\n ^\nStep 3: "42" ("42" read in)\n ^\nThe parsed integer 42.\nSince 42 range [-231, 231 - 1], final result 42.\n\nExample 2:\nInput: = " -42"\nOutput: -42\nExplanation:\nStep 1: " -42" (leading whitespace read ignored)\n ^\nStep 2: " -42" (\'-\' read, result negative)\n ^\nStep 3: " -42" ("42" read in)\n ^\nThe parsed integer -42.\nSince -42 range [-231, 231 - 1], final result -42.\n\nExample 3:\nInput: = "4193 words"\nOutput: 4193\nExplanation:\nStep 1: "4193 words" (no characters read leading whitespace)\n ^\nStep 2: "4193 words" (no characters read neither \'-\' \'+\')\n ^\nStep 3: "4193 words" ("4193" read in; reading stops next character non-digit)\n ^\nThe parsed integer 4193.\nSince 4193 range [-231, 231 - 1], final result 4193.\n\n\xc2\xa0\nConstraints:\n\n0 <= s.length <= 200\ns consists English letters (lower-case upper-case), digits (0-9), \' \', \'+\', \'-\', \'.\'.\n\n' b'Given integer x, return true x palindrome integer.\nAn integer palindrome reads backward forward.\n\nFor example, 121 palindrome 123 not.\n\n\xc2\xa0\nExample 1:\nInput: x = 121\nOutput: true\nExplanation: 121 reads 121 left right right left.\n\nExample 2:\nInput: x = -121\nOutput: false\nExplanation: From left right, reads -121. From right left, becomes 121-. Therefore palindrome.\n\nExample 3:\nInput: x = 10\nOutput: false\nExplanation: Reads 01 right left. Therefore palindrome.\n\n\xc2\xa0\nConstraints:\n\n-231\xc2\xa0<= x <= 231\xc2\xa0- 1\n\n\xc2\xa0\nFollow up: Could solve without converting integer string?' b'Given input string s\xc2\xa0and pattern p, implement regular expression matching support \'.\' \'*\' where:\n\n\'.\' Matches single character.\xe2\x80\x8b\xe2\x80\x8b\xe2\x80\x8b\xe2\x80\x8b\n\'*\' Matches zero preceding element.\n\nThe matching cover entire input string (not partial).\n\xc2\xa0\nExample 1:\nInput: = "aa", p = "a"\nOutput: false\nExplanation: "a" match entire string "aa".\n\nExample 2:\nInput: = "aa", p = "a*"\nOutput: true\nExplanation: \'*\' means zero preceding element, \'a\'. Therefore, repeating \'a\' once, becomes "aa".\n\nExample 3:\nInput: = "ab", p = ".*"\nOutput: true\nExplanation: ".*" means "zero (*) character (.)".\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length\xc2\xa0<= 20\n1 <= p.length\xc2\xa0<= 30\ns contains lowercase English letters.\np contains lowercase English letters, \'.\', and\xc2\xa0\'*\'.\nIt guaranteed appearance character \'*\', previous valid character match.\n\n' b'You given integer array height length n. There n vertical lines drawn two endpoints ith line (i, 0) (i, height[i]).\nFind two lines together x-axis form container, container contains water.\nReturn maximum amount water container store.\nNotice may slant container.\n\xc2\xa0\nExample 1:\n\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The vertical lines represented array [1,8,6,2,5,4,8,3,7]. In case, max area water (blue section) container contain 49.\n\nExample 2:\nInput: height = [1,1]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\nn == height.length\n2 <= n <= 105\n0 <= height[i] <= 104\n\n' b'Roman numerals represented seven different symbols:\xc2\xa0I, V, X, L, C, D M.\nSymbol Value\nI 1\nV 5\nX 10\nL 50\nC 100\nD 500\nM 1000\nFor example,\xc2\xa02 written II\xc2\xa0in Roman numeral, two one\'s added together. 12 written as\xc2\xa0XII, simply X + II. The number 27 written XXVII, XX + V + II.\nRoman numerals usually written largest smallest left right. However, numeral four IIII. Instead, number four written IV. Because one five subtract making four. The principle applies number nine, written IX. There six instances subtraction used:\n\nI placed V (5) X (10) make 4 9.\xc2\xa0\nX placed L (50) C (100) make 40 90.\xc2\xa0\nC placed D (500) M (1000) make 400 900.\n\nGiven integer, convert roman numeral.\n\xc2\xa0\nExample 1:\nInput: num = 3\nOutput: "III"\nExplanation: 3 represented 3 ones.\n\nExample 2:\nInput: num = 58\nOutput: "LVIII"\nExplanation: L = 50, V = 5, III = 3.\n\nExample 3:\nInput: num = 1994\nOutput: "MCMXCIV"\nExplanation: M = 1000, CM = 900, XC = 90 IV = 4.\n\n\xc2\xa0\nConstraints:\n\n1 <= num <= 3999\n\n' b'Roman numerals represented seven different symbols:\xc2\xa0I, V, X, L, C, D M.\nSymbol Value\nI 1\nV 5\nX 10\nL 50\nC 100\nD 500\nM 1000\nFor example,\xc2\xa02 written II\xc2\xa0in Roman numeral, two one\'s added together. 12 written as\xc2\xa0XII, simply X + II. The number 27 written XXVII, XX + V + II.\nRoman numerals usually written largest smallest left right. However, numeral four IIII. Instead, number four written IV. Because one five subtract making four. The principle applies number nine, written IX. There six instances subtraction used:\n\nI placed V (5) X (10) make 4 9.\xc2\xa0\nX placed L (50) C (100) make 40 90.\xc2\xa0\nC placed D (500) M (1000) make 400 900.\n\nGiven roman numeral, convert integer.\n\xc2\xa0\nExample 1:\nInput: = "III"\nOutput: 3\nExplanation: III = 3.\n\nExample 2:\nInput: = "LVIII"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n\nExample 3:\nInput: = "MCMXCIV"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 IV = 4.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 15\ns contains only\xc2\xa0the characters (\'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\').\nIt guaranteed\xc2\xa0that valid roman numeral range [1, 3999].\n\n' b'Write function find longest common prefix string amongst array strings.\nIf common prefix, return empty string "".\n\xc2\xa0\nExample 1:\nInput: strs = ["flower","flow","flight"]\nOutput: "fl"\n\nExample 2:\nInput: strs = ["dog","racecar","car"]\nOutput: ""\nExplanation: There common prefix among input strings.\n\n\xc2\xa0\nConstraints:\n\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists lower-case English letters.\n\n' b'Given integer array nums, return triplets [nums[i], nums[j], nums[k]] != j, != k, j != k, nums[i] + nums[j] + nums[k] == 0.\nNotice solution set must contain duplicate triplets.\n\xc2\xa0\nExample 1:\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExample 2:\nInput: nums = []\nOutput: []\nExample 3:\nInput: nums = [0]\nOutput: []\n\n\xc2\xa0\nConstraints:\n\n0 <= nums.length <= 3000\n-105 <= nums[i] <= 105\n\n' b'Given integer array nums length n integer target, find three integers nums sum closest target.\nReturn sum three integers.\nYou may assume input would exactly one solution.\n\xc2\xa0\nExample 1:\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum closest target 2. (-1 + 2 + 1 = 2).\n\nExample 2:\nInput: nums = [0,0,0], target = 1\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n3 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\n-104 <= target <= 104\n\n' b'Given string containing digits 2-9 inclusive, return possible letter combinations number could represent. Return answer order.\nA mapping digit letters (just like telephone buttons) given below. Note 1 map letters.\n\n\xc2\xa0\nExample 1:\nInput: digits = "23"\nOutput: ["ad","ae","af","bd","be","bf","cd","ce","cf"]\n\nExample 2:\nInput: digits = ""\nOutput: []\n\nExample 3:\nInput: digits = "2"\nOutput: ["a","b","c"]\n\n\xc2\xa0\nConstraints:\n\n0 <= digits.length <= 4\ndigits[i] digit range [\'2\', \'9\'].\n\n' b'Given array nums n integers, return array unique quadruplets [nums[a], nums[b], nums[c], nums[d]] that:\n\n0 <= a, b, c, d\xc2\xa0< n\na, b, c, distinct.\nnums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return answer order.\n\xc2\xa0\nExample 1:\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\nExample 2:\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 200\n-109 <= nums[i] <= 109\n-109 <= target <= 109\n\n' b'Given head linked list, remove nth node end list return head.\n\xc2\xa0\nExample 1:\n\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\nExample 2:\nInput: head = [1], n = 1\nOutput: []\n\nExample 3:\nInput: head = [1,2], n = 1\nOutput: [1]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list sz.\n1 <= sz <= 30\n0 <= Node.val <= 100\n1 <= n <= sz\n\n\xc2\xa0\nFollow up: Could one pass?\n' b'Given string containing characters \'(\', \')\', \'{\', \'}\', \'[\' \']\', determine input string valid.\nAn input string valid if:\n\nOpen brackets must closed type brackets.\nOpen brackets must closed correct order.\n\n\xc2\xa0\nExample 1:\nInput: = "()"\nOutput: true\n\nExample 2:\nInput: = "()[]{}"\nOutput: true\n\nExample 3:\nInput: = "(]"\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 104\ns consists parentheses \'()[]{}\'.\n\n' b'You given heads two sorted linked lists list1 list2.\nMerge two lists one sorted list. The list made splicing together nodes first two lists.\nReturn head merged linked list.\n\xc2\xa0\nExample 1:\n\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\nExample 2:\nInput: list1 = [], list2 = []\nOutput: []\n\nExample 3:\nInput: list1 = [], list2 = [0]\nOutput: [0]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes lists range [0, 50].\n-100 <= Node.val <= 100\nBoth list1 list2 sorted non-decreasing order.\n\n' b'Given n pairs parentheses, write function generate combinations well-formed parentheses.\n\xc2\xa0\nExample 1:\nInput: n = 3\nOutput: ["((()))","(()())","(())()","()(())","()()()"]\nExample 2:\nInput: n = 1\nOutput: ["()"]\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 8\n\n' b'You given array k linked-lists lists, linked-list sorted ascending order.\nMerge linked-lists one sorted linked-list return it.\n\xc2\xa0\nExample 1:\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n 1->4->5,\n 1->3->4,\n 2->6\n]\nmerging one sorted list:\n1->1->2->3->4->4->5->6\n\nExample 2:\nInput: lists = []\nOutput: []\n\nExample 3:\nInput: lists = [[]]\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nk == lists.length\n0 <= k <= 104\n0 <= lists[i].length <= 500\n-104 <= lists[i][j] <= 104\nlists[i] sorted ascending order.\nThe sum lists[i].length exceed 104.\n\n' b"Given a\xc2\xa0linked list, swap every two adjacent nodes return head. You must solve problem without\xc2\xa0modifying values list's nodes (i.e., nodes may changed.)\n\xc2\xa0\nExample 1:\n\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\n\nExample 2:\nInput: head = []\nOutput: []\n\nExample 3:\nInput: head = [1]\nOutput: [1]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes the\xc2\xa0list\xc2\xa0is range [0, 100].\n0 <= Node.val <= 100\n\n" b"Given head linked list, reverse nodes list k time, return modified list.\nk positive integer less equal length linked list. If number nodes multiple k left-out nodes, end, remain is.\nYou may alter values list's nodes, nodes may changed.\n\xc2\xa0\nExample 1:\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n\nExample 2:\n\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list n.\n1 <= k <= n <= 5000\n0 <= Node.val <= 1000\n\n\xc2\xa0\nFollow-up: Can solve problem O(1) extra memory space?\n" b'Given integer array nums sorted non-decreasing order, remove duplicates in-place unique element appears once. The relative order elements kept same.\nSince impossible change length array languages, must instead result placed first part array nums. More formally, k elements removing duplicates, first k elements nums\xc2\xa0should hold final result. It matter leave beyond first\xc2\xa0k\xc2\xa0elements.\nReturn k placing final result first k slots nums.\nDo allocate extra space another array. You must modifying input array in-place O(1) extra memory.\nCustom Judge:\nThe judge test solution following code:\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer correct length\n\nint k = removeDuplicates(nums); // Calls implementation\n\nassert k == expectedNums.length;\nfor (int = 0; < k; i++) {\n assert nums[i] == expectedNums[i];\n}\n\nIf assertions pass, solution accepted.\n\xc2\xa0\nExample 1:\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function return k = 2, first two elements nums 1 2 respectively.\nIt matter leave beyond returned k (hence underscores).\n\nExample 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function return k = 5, first five elements nums 0, 1, 2, 3, 4 respectively.\nIt matter leave beyond returned k (hence underscores).\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 3 * 104\n-100 <= nums[i] <= 100\nnums sorted non-decreasing order.\n\n' b'Given integer array nums integer val, remove occurrences val nums in-place. The relative order elements may changed.\nSince impossible change length array languages, must instead result placed first part array nums. More formally, k elements removing duplicates, first k elements nums hold final result. It matter leave beyond first k elements.\nReturn k placing final result first k slots nums.\nDo allocate extra space another array. You must modifying input array in-place O(1) extra memory.\nCustom Judge:\nThe judge test solution following code:\nint[] nums = [...]; // Input array\nint val = ...; // Value remove\nint[] expectedNums = [...]; // The expected answer correct length.\n // It sorted values equaling val.\n\nint k = removeElement(nums, val); // Calls implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort first k elements nums\nfor (int = 0; < actualLength; i++) {\n assert nums[i] == expectedNums[i];\n}\n\nIf assertions pass, solution accepted.\n\xc2\xa0\nExample 1:\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function return k = 2, first two elements nums 2.\nIt matter leave beyond returned k (hence underscores).\n\nExample 2:\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function return k = 5, first five elements nums containing 0, 0, 1, 3, 4.\nNote five elements returned order.\nIt matter leave beyond returned k (hence underscores).\n\n\xc2\xa0\nConstraints:\n\n0 <= nums.length <= 100\n0 <= nums[i] <= 50\n0 <= val <= 100\n\n' b'Implement strStr().\nGiven two strings needle haystack, return index first occurrence needle haystack, -1 needle part haystack.\nClarification:\nWhat return needle empty string? This great question ask interview.\nFor purpose problem, return 0 needle empty string. This consistent C\'s strstr() Java\'s indexOf().\n\xc2\xa0\nExample 1:\nInput: haystack = "hello", needle = "ll"\nOutput: 2\n\nExample 2:\nInput: haystack = "aaaaa", needle = "bba"\nOutput: -1\n\n\xc2\xa0\nConstraints:\n\n1 <= haystack.length, needle.length <= 104\nhaystack needle consist lowercase English characters.\n\n' b'Given two integers dividend divisor, divide two integers without using multiplication, division, mod operator.\nThe integer division truncate toward zero, means losing fractional part. For example, 8.345 would truncated 8, -2.7335 would truncated -2.\nReturn quotient dividing dividend divisor.\nNote: Assume dealing environment could store integers within 32-bit signed integer range: [\xe2\x88\x92231, 231 \xe2\x88\x92 1]. For problem, quotient strictly greater 231 - 1, return 231 - 1, quotient strictly less -231, return -231.\n\xc2\xa0\nExample 1:\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. truncated 3.\n\nExample 2:\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. truncated -2.\n\n\xc2\xa0\nConstraints:\n\n-231 <= dividend, divisor <= 231 - 1\ndivisor != 0\n\n' b'You given string array strings words length. Return\xc2\xa0all starting indices substring(s) s\xc2\xa0that concatenation word words exactly once, order,\xc2\xa0and without intervening characters.\nYou return answer order.\n\xc2\xa0\nExample 1:\nInput: = "barfoothefoobarman", words = ["foo","bar"]\nOutput: [0,9]\nExplanation: Substrings starting index 0 9 "barfoo" "foobar" respectively.\nThe output order matter, returning [9,0] fine too.\n\nExample 2:\nInput: = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]\nOutput: []\n\nExample 3:\nInput: = "barfoofoobarthefoobarman", words = ["bar","foo","the"]\nOutput: [6,9,12]\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 104\ns consists lower-case English letters.\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\nwords[i]\xc2\xa0consists lower-case English letters.\n\n' b'A permutation array integers arrangement members sequence linear order.\n\nFor example, arr = [1,2,3], following considered permutations arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1].\n\nThe next permutation array integers next lexicographically greater permutation integer. More formally, permutations array sorted one container according lexicographical order, next permutation array permutation follows sorted container. If arrangement possible, array must rearranged lowest possible order (i.e., sorted ascending order).\n\nFor example, next permutation arr = [1,2,3] [1,3,2].\nSimilarly, next permutation arr = [2,3,1] [3,1,2].\nWhile next permutation arr = [3,2,1] [1,2,3] [3,2,1] lexicographical larger rearrangement.\n\nGiven array integers nums, find next permutation nums.\nThe replacement must place use constant extra memory.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\nExample 2:\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\nExample 3:\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 100\n\n' b'Given string containing characters \'(\' \')\', find length longest valid (well-formed) parentheses substring.\n\xc2\xa0\nExample 1:\nInput: = "(()"\nOutput: 2\nExplanation: The longest valid parentheses substring "()".\n\nExample 2:\nInput: = ")()())"\nOutput: 4\nExplanation: The longest valid parentheses substring "()()".\n\nExample 3:\nInput: = ""\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n0 <= s.length <= 3 * 104\ns[i] \'(\', \')\'.\n\n' b'There integer array nums sorted ascending order (with distinct values).\nPrior passed function, nums possibly rotated unknown pivot index k (1 <= k < nums.length) resulting array [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might rotated pivot index 3 become [4,5,6,7,0,1,2].\nGiven array nums possible rotation integer target, return index target nums, -1 nums.\nYou must write algorithm O(log n) runtime complexity.\n\xc2\xa0\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\nExample 3:\nInput: nums = [1], target = 0\nOutput: -1\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nAll values nums unique.\nnums ascending array possibly rotated.\n-104 <= target <= 104\n\n' b'Given array integers nums sorted non-decreasing order, find starting ending position given target value.\nIf target found array, return [-1, -1].\nYou must\xc2\xa0write algorithm with\xc2\xa0O(log n) runtime complexity.\n\xc2\xa0\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\nInput: nums = [], target = 0\nOutput: [-1,-1]\n\n\xc2\xa0\nConstraints:\n\n0 <= nums.length <= 105\n-109\xc2\xa0<= nums[i]\xc2\xa0<= 109\nnums non-decreasing array.\n-109\xc2\xa0<= target\xc2\xa0<= 109\n\n' b'Given sorted array distinct integers target value, return index target found. If not, return index would inserted order.\nYou must\xc2\xa0write algorithm with\xc2\xa0O(log n) runtime complexity.\n\xc2\xa0\nExample 1:\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\n\nExample 2:\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\n\nExample 3:\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted ascending order.\n-104 <= target <= 104\n\n' b'Determine a\xc2\xa09 x 9 Sudoku board\xc2\xa0is valid.\xc2\xa0Only filled cells need validated\xc2\xa0according following rules:\n\nEach row\xc2\xa0must contain the\xc2\xa0digits\xc2\xa01-9 without repetition.\nEach column must contain digits\xc2\xa01-9\xc2\xa0without repetition.\nEach nine\xc2\xa03 x 3 sub-boxes grid must contain digits\xc2\xa01-9\xc2\xa0without repetition.\n\nNote:\n\nA Sudoku board (partially filled) could valid necessarily solvable.\nOnly filled cells need validated according mentioned\xc2\xa0rules.\n\n\xc2\xa0\nExample 1:\n\nInput: board = \n[["5","3",".",".","7",".",".",".","."]\n,["6",".",".","1","9","5",".",".","."]\n,[".","9","8",".",".",".",".","6","."]\n,["8",".",".",".","6",".",".",".","3"]\n,["4",".",".","8",".","3",".",".","1"]\n,["7",".",".",".","2",".",".",".","6"]\n,[".","6",".",".",".",".","2","8","."]\n,[".",".",".","4","1","9",".",".","5"]\n,[".",".",".",".","8",".",".","7","9"]]\nOutput: true\n\nExample 2:\nInput: board = \n[["8","3",".",".","7",".",".",".","."]\n,["6",".",".","1","9","5",".",".","."]\n,[".","9","8",".",".",".",".","6","."]\n,["8",".",".",".","6",".",".",".","3"]\n,["4",".",".","8",".","3",".",".","1"]\n,["7",".",".",".","2",".",".",".","6"]\n,[".","6",".",".",".",".","2","8","."]\n,[".",".",".","4","1","9",".",".","5"]\n,[".",".",".",".","8",".",".","7","9"]]\nOutput: false\nExplanation: Same Example 1, except 5 top left corner modified 8. Since two 8\'s top left 3x3 sub-box, invalid.\n\n\xc2\xa0\nConstraints:\n\nboard.length == 9\nboard[i].length == 9\nboard[i][j] digit 1-9 \'.\'.\n\n' b'Write program solve Sudoku puzzle filling empty cells.\nA sudoku solution must satisfy following rules:\n\nEach digits 1-9 must occur exactly row.\nEach digits 1-9 must occur exactly column.\nEach digits 1-9 must occur exactly 9 3x3 sub-boxes grid.\n\nThe \'.\' character indicates empty cells.\n\xc2\xa0\nExample 1:\n\nInput: board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]\nOutput: [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]\nExplanation:\xc2\xa0The input board shown valid solution shown below:\n\n\n\n\xc2\xa0\nConstraints:\n\nboard.length == 9\nboard[i].length == 9\nboard[i][j] digit \'.\'.\nIt guaranteed input board one solution.\n\n' b'The count-and-say sequence sequence digit strings defined recursive formula:\n\ncountAndSay(1) = "1"\ncountAndSay(n) way would "say" digit string countAndSay(n-1), converted different digit string.\n\nTo determine "say" digit string, split minimal number substrings substring contains exactly one unique digit. Then substring, say number digits, say digit. Finally, concatenate every said digit.\nFor example, saying conversion digit string "3322251":\n\nGiven positive integer n, return nth term count-and-say sequence.\n\xc2\xa0\nExample 1:\nInput: n = 1\nOutput: "1"\nExplanation: This base case.\n\nExample 2:\nInput: n = 4\nOutput: "1211"\nExplanation:\ncountAndSay(1) = "1"\ncountAndSay(2) = say "1" = one 1 = "11"\ncountAndSay(3) = say "11" = two 1\'s = "21"\ncountAndSay(4) = say "21" = one 2 + one 1 = "12" + "11" = "1211"\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 30\n\n' b'Given array distinct integers candidates target integer target, return list unique combinations candidates chosen numbers sum target. You may return combinations order.\nThe number may chosen candidates unlimited number times. Two combinations unique frequency least one chosen numbers different.\nIt guaranteed number unique combinations sum target less 150 combinations given input.\n\xc2\xa0\nExample 1:\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 3 candidates, 2 + 2 + 3 = 7. Note 2 used multiple times.\n7 candidate, 7 = 7.\nThese two combinations.\n\nExample 2:\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n\nExample 3:\nInput: candidates = [2], target = 1\nOutput: []\n\n\xc2\xa0\nConstraints:\n\n1 <= candidates.length <= 30\n1 <= candidates[i] <= 200\nAll elements candidates distinct.\n1 <= target <= 500\n\n' b'Given collection candidate numbers (candidates) target number (target), find unique combinations candidates\xc2\xa0where candidate numbers sum target.\nEach number candidates\xc2\xa0may used combination.\nNote:\xc2\xa0The solution set must contain duplicate combinations.\n\xc2\xa0\nExample 1:\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\nExample 2:\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\xc2\xa0\nConstraints:\n\n1 <=\xc2\xa0candidates.length <= 100\n1 <=\xc2\xa0candidates[i] <= 50\n1 <= target <= 30\n\n' b'Given unsorted integer array nums, return smallest missing positive integer.\nYou must implement algorithm runs O(n) time uses constant extra space.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,0]\nOutput: 3\nExample 2:\nInput: nums = [3,4,-1,1]\nOutput: 2\nExample 3:\nInput: nums = [7,8,9,11,12]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 5 * 105\n-231 <= nums[i] <= 231 - 1\n\n' b'Given n non-negative integers representing elevation map width bar 1, compute much water trap raining.\n\xc2\xa0\nExample 1:\n\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The elevation map (black section) represented array [0,1,0,2,1,0,1,3,2,1,2,1]. In case, 6 units rain water (blue section) trapped.\n\nExample 2:\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n\n\xc2\xa0\nConstraints:\n\nn == height.length\n1 <= n <= 2 * 104\n0 <= height[i] <= 105\n\n' b'Given two non-negative integers num1 num2 represented strings, return product num1 num2, also represented string.\nNote:\xc2\xa0You must use built-in BigInteger library convert inputs integer directly.\n\xc2\xa0\nExample 1:\nInput: num1 = "2", num2 = "3"\nOutput: "6"\nExample 2:\nInput: num1 = "123", num2 = "456"\nOutput: "56088"\n\n\xc2\xa0\nConstraints:\n\n1 <= num1.length, num2.length <= 200\nnum1 num2 consist digits only.\nBoth num1 num2\xc2\xa0do contain leading zero, except number 0 itself.\n\n' b'Given input string (s) pattern (p), implement wildcard pattern matching support \'?\' \'*\' where:\n\n\'?\' Matches single character.\n\'*\' Matches sequence characters (including empty sequence).\n\nThe matching cover entire input string (not partial).\n\xc2\xa0\nExample 1:\nInput: = "aa", p = "a"\nOutput: false\nExplanation: "a" match entire string "aa".\n\nExample 2:\nInput: = "aa", p = "*"\nOutput: true\nExplanation:\xc2\xa0\'*\' matches sequence.\n\nExample 3:\nInput: = "cb", p = "?a"\nOutput: false\nExplanation:\xc2\xa0\'?\' matches \'c\', second letter \'a\', match \'b\'.\n\n\xc2\xa0\nConstraints:\n\n0 <= s.length, p.length <= 2000\ns contains lowercase English letters.\np contains lowercase English letters, \'?\' \'*\'.\n\n' b'Given array non-negative integers nums, initially positioned first index array.\nEach element array represents maximum jump length position.\nYour goal reach last index minimum number jumps.\nYou assume always reach last index.\n\xc2\xa0\nExample 1:\nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number jumps reach last index 2. Jump 1 step index 0 1, 3 steps last index.\n\nExample 2:\nInput: nums = [2,3,0,1,4]\nOutput: 2\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n0 <= nums[i] <= 1000\n\n' b'Given array nums distinct integers, return possible permutations. You return answer order.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nExample 2:\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\nExample 3:\nInput: nums = [1]\nOutput: [[1]]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nAll integers nums unique.\n\n' b'Given collection numbers, nums,\xc2\xa0that might contain duplicates, return possible unique permutations order.\n\xc2\xa0\nExample 1:\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\nExample 2:\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 8\n-10 <= nums[i] <= 10\n\n' b'You given n x n 2D matrix representing image, rotate image 90 degrees (clockwise).\nYou rotate image in-place, means modify input 2D matrix directly. DO NOT allocate another 2D matrix rotation.\n\xc2\xa0\nExample 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n\nExample 2:\n\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\xc2\xa0\nConstraints:\n\nn == matrix.length == matrix[i].length\n1 <= n <= 20\n-1000 <= matrix[i][j] <= 1000\n\n' b'Given array strings strs, group anagrams together. You return answer order.\nAn Anagram word phrase formed rearranging letters different word phrase, typically using original letters exactly once.\n\xc2\xa0\nExample 1:\nInput: strs = ["eat","tea","tan","ate","nat","bat"]\nOutput: [["bat"],["nat","tan"],["ate","eat","tea"]]\nExample 2:\nInput: strs = [""]\nOutput: [[""]]\nExample 3:\nInput: strs = ["a"]\nOutput: [["a"]]\n\n\xc2\xa0\nConstraints:\n\n1 <= strs.length <= 104\n0 <= strs[i].length <= 100\nstrs[i] consists lowercase English letters.\n\n' b'Implement pow(x, n), calculates x raised power n (i.e., xn).\n\xc2\xa0\nExample 1:\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\n\nExample 2:\nInput: x = 2.10000, n = 3\nOutput: 9.26100\n\nExample 3:\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25\n\n\xc2\xa0\nConstraints:\n\n-100.0 < x < 100.0\n-231 <= n <= 231-1\n-104 <= xn <= 104\n\n' b'The n-queens puzzle problem placing n queens n x n chessboard two queens attack other.\nGiven integer n, return distinct solutions n-queens puzzle. You may return answer order.\nEach solution contains distinct board configuration n-queens\' placement, \'Q\' \'.\' indicate queen empty space, respectively.\n\xc2\xa0\nExample 1:\n\nInput: n = 4\nOutput: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]\nExplanation: There exist two distinct solutions 4-queens puzzle shown above\n\nExample 2:\nInput: n = 1\nOutput: [["Q"]]\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 9\n\n' b'The n-queens puzzle problem placing n queens n x n chessboard two queens attack other.\nGiven integer n, return number distinct solutions the\xc2\xa0n-queens puzzle.\n\xc2\xa0\nExample 1:\n\nInput: n = 4\nOutput: 2\nExplanation: There two distinct solutions 4-queens puzzle shown.\n\nExample 2:\nInput: n = 1\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 9\n\n' b'Given integer array nums, find contiguous subarray (containing least one number) largest sum return sum.\nA subarray contiguous part array.\n\xc2\xa0\nExample 1:\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: [4,-1,2,1] largest sum = 6.\n\nExample 2:\nInput: nums = [1]\nOutput: 1\n\nExample 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n\n\xc2\xa0\nFollow up: If figured O(n) solution, try coding another solution using divide conquer approach, subtle.\n' b'Given x n matrix, return elements matrix spiral order.\n\xc2\xa0\nExample 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n\nExample 2:\n\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n\xc2\xa0\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 10\n-100 <= matrix[i][j] <= 100\n\n' b"You given integer array nums. You initially positioned array's first index, element array represents maximum jump length position.\nReturn true reach last index, false otherwise.\n\xc2\xa0\nExample 1:\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step index 0 1, 3 steps last index.\n\nExample 2:\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You always arrive index 3 matter what. Its maximum jump length 0, makes impossible reach last index.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n0 <= nums[i] <= 105\n\n" b'Given array\xc2\xa0of intervals\xc2\xa0where intervals[i] = [starti, endi], merge overlapping intervals, return array non-overlapping intervals cover intervals input.\n\xc2\xa0\nExample 1:\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] [2,6] overlap, merge [1,6].\n\nExample 2:\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] [4,5] considered overlapping.\n\n\xc2\xa0\nConstraints:\n\n1 <= intervals.length <= 104\nintervals[i].length == 2\n0 <= starti <= endi <= 104\n\n' b'You given array non-overlapping intervals intervals intervals[i] = [starti, endi] represent start end ith interval intervals sorted ascending order starti. You also given interval newInterval = [start, end] represents start end another interval.\nInsert newInterval intervals intervals still sorted ascending order starti intervals still overlapping intervals (merge overlapping intervals necessary).\nReturn intervals insertion.\n\xc2\xa0\nExample 1:\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\nExample 2:\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because new interval [4,8] overlaps [3,5],[6,7],[8,10].\n\n\xc2\xa0\nConstraints:\n\n0 <= intervals.length <= 104\nintervals[i].length == 2\n0 <= starti <= endi <= 105\nintervals sorted starti ascending order.\nnewInterval.length == 2\n0 <= start <= end <= 105\n\n' b'Given string consisting words spaces, return length last word string.\nA word maximal substring consisting non-space characters only.\n\xc2\xa0\nExample 1:\nInput: = "Hello World"\nOutput: 5\nExplanation: The last word "World" length 5.\n\nExample 2:\nInput: = " fly moon "\nOutput: 4\nExplanation: The last word "moon" length 4.\n\nExample 3:\nInput: = "luffy still joyboy"\nOutput: 6\nExplanation: The last word "joyboy" length 6.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 104\ns consists English letters spaces \' \'.\nThere least one word s.\n\n' b'Given positive integer n, generate n x n matrix filled elements 1 n2 spiral order.\n\xc2\xa0\nExample 1:\n\nInput: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]\n\nExample 2:\nInput: n = 1\nOutput: [[1]]\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 20\n\n' b'The set [1, 2, 3, ...,\xc2\xa0n] contains total n! unique permutations.\nBy listing labeling permutations order, get following sequence n = 3:\n\n"123"\n"132"\n"213"\n"231"\n"312"\n"321"\n\nGiven n k, return kth permutation sequence.\n\xc2\xa0\nExample 1:\nInput: n = 3, k = 3\nOutput: "213"\nExample 2:\nInput: n = 4, k = 9\nOutput: "2314"\nExample 3:\nInput: n = 3, k = 1\nOutput: "123"\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 9\n1 <= k <= n!\n\n' b'Given head linked\xc2\xa0list, rotate list right k places.\n\xc2\xa0\nExample 1:\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n\nExample 2:\n\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list range [0, 500].\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109\n\n' b'There robot x n grid. The robot initially located top-left corner (i.e., grid[0][0]). The robot tries move bottom-right corner (i.e., grid[m - 1][n - 1]). The robot move either right point time.\nGiven two integers n, return number possible unique paths robot take reach bottom-right corner.\nThe test cases generated answer less equal 2 * 109.\n\xc2\xa0\nExample 1:\n\nInput: = 3, n = 7\nOutput: 28\n\nExample 2:\nInput: = 3, n = 2\nOutput: 3\nExplanation: From top-left corner, total 3 ways reach bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n\n\xc2\xa0\nConstraints:\n\n1 <= m, n <= 100\n\n' b'You given x n integer array grid. There robot initially located top-left corner (i.e., grid[0][0]). The robot tries move bottom-right corner (i.e., grid[m-1][n-1]). The robot move either right point time.\nAn obstacle space marked 1 0 respectively grid. A path robot takes cannot include square obstacle.\nReturn number possible unique paths robot take reach bottom-right corner.\nThe testcases generated answer less equal 2 * 109.\n\xc2\xa0\nExample 1:\n\nInput: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: 2\nExplanation: There one obstacle middle 3x3 grid above.\nThere two ways reach bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\nExample 2:\n\nInput: obstacleGrid = [[0,1],[0,0]]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\nm == obstacleGrid.length\nn == obstacleGrid[i].length\n1 <= m, n <= 100\nobstacleGrid[i][j] 0 1.\n\n' b'Given x n grid filled non-negative numbers, find path top left bottom right, minimizes sum numbers along path.\nNote: You move either right point time.\n\xc2\xa0\nExample 1:\n\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because path 1 \xe2\x86\x92 3 \xe2\x86\x92 1 \xe2\x86\x92 1 \xe2\x86\x92 1 minimizes sum.\n\nExample 2:\nInput: grid = [[1,2,3],[4,5,6]]\nOutput: 12\n\n\xc2\xa0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 200\n0 <= grid[i][j] <= 100\n\n' b'A valid number split components (in order):\n\nA decimal number integer.\n(Optional) An \'e\' \'E\', followed integer.\n\nA decimal number split components (in order):\n\n(Optional) A sign character (either \'+\' \'-\').\nOne following formats:\n\t\nOne digits, followed dot \'.\'.\nOne digits, followed dot \'.\', followed one digits.\nA dot \'.\', followed one digits.\n\n\n\nAn integer split components (in order):\n\n(Optional) A sign character (either \'+\' \'-\').\nOne digits.\n\nFor example, following valid numbers: ["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"], following valid numbers: ["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"].\nGiven string s, return true valid number.\n\xc2\xa0\nExample 1:\nInput: = "0"\nOutput: true\n\nExample 2:\nInput: = "e"\nOutput: false\n\nExample 3:\nInput: = "."\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 20\ns consists English letters (both uppercase lowercase), digits (0-9), plus \'+\', minus \'-\', dot \'.\'.\n\n' b"You given large integer represented integer array digits, digits[i] ith digit integer. The digits ordered significant least significant left-to-right order. The large integer contain leading 0's.\nIncrement large integer one return resulting array digits.\n\xc2\xa0\nExample 1:\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents integer 123.\nIncrementing one gives 123 + 1 = 124.\nThus, result [1,2,4].\n\nExample 2:\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents integer 4321.\nIncrementing one gives 4321 + 1 = 4322.\nThus, result [4,3,2,2].\n\nExample 3:\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents integer 9.\nIncrementing one gives 9 + 1 = 10.\nThus, result [1,0].\n\n\xc2\xa0\nConstraints:\n\n1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits contain leading 0's.\n\n" b'Given two binary strings b, return sum binary string.\n\xc2\xa0\nExample 1:\nInput: = "11", b = "1"\nOutput: "100"\nExample 2:\nInput: = "1010", b = "1011"\nOutput: "10101"\n\n\xc2\xa0\nConstraints:\n\n1 <= a.length, b.length <= 104\na b consist\xc2\xa0only \'0\' \'1\' characters.\nEach string contain leading zeros except zero itself.\n\n' b'Given array strings words width maxWidth, format text line exactly maxWidth characters fully (left right) justified.\nYou pack words greedy approach; is, pack many words line. Pad extra spaces \' \' necessary line exactly maxWidth characters.\nExtra spaces words distributed evenly possible. If number spaces line divide evenly words, empty slots left assigned spaces slots right.\nFor last line text, left-justified extra space inserted words.\nNote:\n\nA word defined character sequence consisting non-space characters only.\nEach word\'s length guaranteed greater 0 exceed maxWidth.\nThe input array words contains least one word.\n\n\xc2\xa0\nExample 1:\nInput: words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16\nOutput:\n[\n\xc2\xa0 \xc2\xa0"This \xc2\xa0 \xc2\xa0is \xc2\xa0 \xc2\xa0an",\n\xc2\xa0 \xc2\xa0"example \xc2\xa0of text",\n\xc2\xa0 \xc2\xa0"justification. \xc2\xa0"\n]\nExample 2:\nInput: words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16\nOutput:\n[\n\xc2\xa0 "What \xc2\xa0 must \xc2\xa0 be",\n\xc2\xa0 "acknowledgment \xc2\xa0",\n\xc2\xa0 "shall \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0"\n]\nExplanation: Note last line "shall " instead "shall be", last line must left-justified instead fully-justified.\nNote second line also left-justified becase contains one word.\nExample 3:\nInput: words = ["Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"], maxWidth = 20\nOutput:\n[\n\xc2\xa0 "Science \xc2\xa0is \xc2\xa0what we",\n "understand \xc2\xa0 \xc2\xa0 \xc2\xa0well",\n\xc2\xa0 "enough explain to",\n\xc2\xa0 "a \xc2\xa0computer. \xc2\xa0Art is",\n\xc2\xa0 "everything \xc2\xa0else \xc2\xa0we",\n\xc2\xa0 "do \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0"\n]\n\xc2\xa0\nConstraints:\n\n1 <= words.length <= 300\n1 <= words[i].length <= 20\nwords[i] consists English letters symbols.\n1 <= maxWidth <= 100\nwords[i].length <= maxWidth\n\n' b'Given non-negative integer x,\xc2\xa0compute return square root x.\nSince return type\xc2\xa0is integer, decimal digits truncated, integer part result\xc2\xa0is returned.\nNote:\xc2\xa0You allowed use built-in exponent function operator, pow(x, 0.5) or\xc2\xa0x ** 0.5.\n\xc2\xa0\nExample 1:\nInput: x = 4\nOutput: 2\n\nExample 2:\nInput: x = 8\nOutput: 2\nExplanation: The square root 8 2.82842..., since decimal part truncated, 2 returned.\n\xc2\xa0\nConstraints:\n\n0 <= x <= 231 - 1\n\n' b'You climbing staircase. It takes n steps reach top.\nEach time either climb 1 2 steps. In many distinct ways climb top?\n\xc2\xa0\nExample 1:\nInput: n = 2\nOutput: 2\nExplanation: There two ways climb top.\n1. 1 step + 1 step\n2. 2 steps\n\nExample 2:\nInput: n = 3\nOutput: 3\nExplanation: There three ways climb top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 45\n\n' b'Given string path, absolute path (starting slash \'/\') file directory Unix-style file system, convert simplified canonical path.\nIn Unix-style file system, period \'.\' refers current directory, double period \'..\' refers directory level, multiple consecutive slashes (i.e. \'//\') treated single slash \'/\'. For problem, format periods \'...\' treated file/directory names.\nThe canonical path following format:\n\nThe path starts single slash \'/\'.\nAny two directories separated single slash \'/\'.\nThe path end trailing \'/\'.\nThe path contains directories path root directory target file directory (i.e., period \'.\' double period \'..\')\n\nReturn simplified canonical path.\n\xc2\xa0\nExample 1:\nInput: path = "/home/"\nOutput: "/home"\nExplanation: Note trailing slash last directory name.\n\nExample 2:\nInput: path = "/../"\nOutput: "/"\nExplanation: Going one level root directory no-op, root level highest level go.\n\nExample 3:\nInput: path = "/home//foo/"\nOutput: "/home/foo"\nExplanation: In canonical path, multiple consecutive slashes replaced single one.\n\n\xc2\xa0\nConstraints:\n\n1 <= path.length <= 3000\npath consists English letters, digits, period \'.\', slash \'/\' \'_\'.\npath valid absolute Unix path.\n\n' b'Given two strings word1 word2, return minimum number operations required convert word1 word2.\nYou following three operations permitted word:\n\nInsert character\nDelete character\nReplace character\n\n\xc2\xa0\nExample 1:\nInput: word1 = "horse", word2 = "ros"\nOutput: 3\nExplanation: \nhorse -> rorse (replace \'h\' \'r\')\nrorse -> rose (remove \'r\')\nrose -> ros (remove \'e\')\n\nExample 2:\nInput: word1 = "intention", word2 = "execution"\nOutput: 5\nExplanation: \nintention -> inention (remove \'t\')\ninention -> enention (replace \'i\' \'e\')\nenention -> exention (replace \'n\' \'x\')\nexention -> exection (replace \'n\' \'c\')\nexection -> execution (insert \'u\')\n\n\xc2\xa0\nConstraints:\n\n0 <= word1.length, word2.length <= 500\nword1 word2 consist lowercase English letters.\n\n' b"Given x n integer matrix matrix, element 0, set entire row column 0's.\nYou must place.\n\xc2\xa0\nExample 1:\n\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n\nExample 2:\n\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\n\xc2\xa0\nConstraints:\n\nm == matrix.length\nn == matrix[0].length\n1 <= m, n <= 200\n-231 <= matrix[i][j] <= 231 - 1\n\n\xc2\xa0\nFollow up:\n\nA straightforward solution using O(mn) space probably bad idea.\nA simple improvement uses O(m + n) space, still best solution.\nCould devise constant space solution?\n\n" b'Write efficient algorithm searches value target x n integer matrix matrix. This matrix following properties:\n\nIntegers row sorted left right.\nThe first integer row greater last integer previous row.\n\n\xc2\xa0\nExample 1:\n\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\n\nExample 2:\n\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\n\n\xc2\xa0\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 100\n-104 <= matrix[i][j], target <= 104\n\n' b"Given array nums n objects colored red, white, blue, sort in-place objects color adjacent, colors order red, white, blue.\nWe use integers 0, 1, 2 represent color red, white, blue, respectively.\nYou must solve problem without using library's sort function.\n\xc2\xa0\nExample 1:\nInput: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\n\nExample 2:\nInput: nums = [2,0,1]\nOutput: [0,1,2]\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= n <= 300\nnums[i] either 0, 1, 2.\n\n\xc2\xa0\nFollow up:\xc2\xa0Could come one-pass algorithm using only\xc2\xa0constant extra space?\n" b'Given two strings lengths n respectively, return minimum window substring every character (including duplicates) included window. If substring, return empty string "".\nThe testcases generated answer unique.\nA substring contiguous sequence characters within string.\n\xc2\xa0\nExample 1:\nInput: = "ADOBECODEBANC", = "ABC"\nOutput: "BANC"\nExplanation: The minimum window substring "BANC" includes \'A\', \'B\', \'C\' string t.\n\nExample 2:\nInput: = "a", = "a"\nOutput: "a"\nExplanation: The entire string minimum window.\n\nExample 3:\nInput: = "a", = "aa"\nOutput: ""\nExplanation: Both \'a\'s must included window.\nSince largest window one \'a\', return empty string.\n\n\xc2\xa0\nConstraints:\n\nm == s.length\nn == t.length\n1 <= m, n\xc2\xa0<= 105\ns consist uppercase lowercase English letters.\n\n\xc2\xa0\nFollow up: Could find algorithm runs O(m + n) time?' b'Given two integers n k, return possible combinations k numbers range [1, n].\nYou may return answer order.\n\xc2\xa0\nExample 1:\nInput: n = 4, k = 2\nOutput:\n[\n [2,4],\n [3,4],\n [2,3],\n [1,2],\n [1,3],\n [1,4],\n]\n\nExample 2:\nInput: n = 1, k = 1\nOutput: [[1]]\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 20\n1 <= k <= n\n\n' b'Given integer array nums unique elements, return possible subsets (the power set).\nThe solution set must contain duplicate subsets. Return solution order.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\nExample 2:\nInput: nums = [0]\nOutput: [[],[0]]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 10\n-10 <= nums[i] <= 10\nAll numbers of\xc2\xa0nums unique.\n\n' b'Given x n grid characters board string word, return true word exists grid.\nThe word constructed letters sequentially adjacent cells, adjacent cells horizontally vertically neighboring. The letter cell may used once.\n\xc2\xa0\nExample 1:\n\nInput: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"\nOutput: true\n\nExample 2:\n\nInput: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"\nOutput: true\n\nExample 3:\n\nInput: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"\nOutput: false\n\n\xc2\xa0\nConstraints:\n\nm == board.length\nn = board[i].length\n1 <= m, n <= 6\n1 <= word.length <= 15\nboard word consists lowercase uppercase English letters.\n\n\xc2\xa0\nFollow up: Could use search pruning make solution faster larger board?\n' b'Given integer array nums sorted non-decreasing order, remove duplicates in-place unique element appears twice. The relative order elements kept same.\nSince impossible change length array languages, must instead result placed first part array nums. More formally, k elements removing duplicates, first k elements nums\xc2\xa0should hold final result. It matter leave beyond first\xc2\xa0k\xc2\xa0elements.\nReturn k placing final result first k slots nums.\nDo allocate extra space another array. You must modifying input array in-place O(1) extra memory.\nCustom Judge:\nThe judge test solution following code:\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer correct length\n\nint k = removeDuplicates(nums); // Calls implementation\n\nassert k == expectedNums.length;\nfor (int = 0; < k; i++) {\n assert nums[i] == expectedNums[i];\n}\n\nIf assertions pass, solution accepted.\n\xc2\xa0\nExample 1:\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function return k = 5, first five elements nums 1, 1, 2, 2 3 respectively.\nIt matter leave beyond returned k (hence underscores).\n\nExample 2:\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function return k = 7, first seven elements nums 0, 0, 1, 1, 2, 3 3 respectively.\nIt matter leave beyond returned k (hence underscores).\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums sorted non-decreasing order.\n\n' b'There integer array nums sorted non-decreasing order (not necessarily distinct values).\nBefore passed function, nums rotated unknown pivot index k (0 <= k < nums.length) resulting array [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might rotated pivot index 5 become [4,5,6,6,7,0,1,2,4,4].\nGiven array nums rotation integer target, return true target nums, false nums.\nYou must decrease overall operation steps much possible.\n\xc2\xa0\nExample 1:\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\nExample 2:\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nnums guaranteed rotated pivot.\n-104 <= target <= 104\n\n\xc2\xa0\nFollow up: This problem similar to\xc2\xa0Search Rotated Sorted Array, but\xc2\xa0nums may contain duplicates. Would affect runtime complexity? How why?\n' b'Given head sorted linked list, delete nodes duplicate numbers, leaving distinct numbers original list. Return linked list sorted well.\n\xc2\xa0\nExample 1:\n\nInput: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]\n\nExample 2:\n\nInput: head = [1,1,1,2,3]\nOutput: [2,3]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list range [0, 300].\n-100 <= Node.val <= 100\nThe list guaranteed sorted ascending order.\n\n' b'Given head sorted linked list, delete duplicates element appears once. Return linked list sorted well.\n\xc2\xa0\nExample 1:\n\nInput: head = [1,1,2]\nOutput: [1,2]\n\nExample 2:\n\nInput: head = [1,1,2,3,3]\nOutput: [1,2,3]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list range [0, 300].\n-100 <= Node.val <= 100\nThe list guaranteed sorted ascending order.\n\n' b"Given array integers heights representing histogram's bar height width bar 1, return area largest rectangle histogram.\n\xc2\xa0\nExample 1:\n\nInput: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The histogram width bar 1.\nThe largest rectangle shown red area, area = 10 units.\n\nExample 2:\n\nInput: heights = [2,4]\nOutput: 4\n\n\xc2\xa0\nConstraints:\n\n1 <= heights.length <= 105\n0 <= heights[i] <= 104\n\n" b'Given rows x cols\xc2\xa0binary matrix filled 0\'s 1\'s, find largest rectangle containing 1\'s return area.\n\xc2\xa0\nExample 1:\n\nInput: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]\nOutput: 6\nExplanation: The maximal rectangle shown picture.\n\nExample 2:\nInput: matrix = [["0"]]\nOutput: 0\n\nExample 3:\nInput: matrix = [["1"]]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\nrows == matrix.length\ncols == matrix[i].length\n1 <= row, cols <= 200\nmatrix[i][j] \'0\' \'1\'.\n\n' b'Given head linked list value x, partition nodes less x come nodes greater equal x.\nYou preserve original relative order nodes two partitions.\n\xc2\xa0\nExample 1:\n\nInput: head = [1,4,3,2,5,2], x = 3\nOutput: [1,2,2,4,3,5]\n\nExample 2:\nInput: head = [2,1], x = 2\nOutput: [1,2]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list range [0, 200].\n-100 <= Node.val <= 100\n-200 <= x <= 200\n\n' b'We scramble string get string using following algorithm:\n\nIf length string 1, stop.\nIf length string > 1, following:\n\t\nSplit string two non-empty substrings random index, i.e., string s, divide x = x + y.\nRandomly\xc2\xa0decide swap two substrings keep order. i.e., step, may become = x + = + x.\nApply step 1 recursively two substrings x y.\n\n\n\nGiven two strings s1 s2 length, return true s2 scrambled string s1, otherwise, return false.\n\xc2\xa0\nExample 1:\nInput: s1 = "great", s2 = "rgeat"\nOutput: true\nExplanation: One possible scenario applied s1 is:\n"great" --> "gr/eat" // divide random index.\n"gr/eat" --> "gr/eat" // random decision swap two substrings keep order.\n"gr/eat" --> "g/r / e/at" // apply algorithm recursively substrings. divide random index them.\n"g/r / e/at" --> "r/g / e/at" // random decision swap first substring keep second substring order.\n"r/g / e/at" --> "r/g / e/ a/t" // apply algorithm recursively, divide "at" "a/t".\n"r/g / e/ a/t" --> "r/g / e/ a/t" // random decision keep substrings order.\nThe algorithm stops now, result string "rgeat" s2.\nAs one possible scenario led s1 scrambled s2, return true.\n\nExample 2:\nInput: s1 = "abcde", s2 = "caebd"\nOutput: false\n\nExample 3:\nInput: s1 = "a", s2 = "a"\nOutput: true\n\n\xc2\xa0\nConstraints:\n\ns1.length == s2.length\n1 <= s1.length <= 30\ns1 s2 consist lowercase English letters.\n\n' b'You given two integer arrays nums1 nums2, sorted non-decreasing order, two integers n, representing number elements nums1 nums2 respectively.\nMerge nums1 nums2 single array sorted non-decreasing order.\nThe final sorted array returned function, instead stored inside array nums1. To accommodate this, nums1 length + n, first elements denote elements merged, last n elements set 0 ignored. nums2 length n.\n\xc2\xa0\nExample 1:\nInput: nums1 = [1,2,3,0,0,0], = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays merging [1,2,3] [2,5,6].\nThe result merge [1,2,2,3,5,6] underlined elements coming nums1.\n\nExample 2:\nInput: nums1 = [1], = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays merging [1] [].\nThe result merge [1].\n\nExample 3:\nInput: nums1 = [0], = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays merging [] [1].\nThe result merge [1].\nNote = 0, elements nums1. The 0 ensure merge result fit nums1.\n\n\xc2\xa0\nConstraints:\n\nnums1.length == + n\nnums2.length == n\n0 <= m, n <= 200\n1 <= + n <= 200\n-109 <= nums1[i], nums2[j] <= 109\n\n\xc2\xa0\nFollow up: Can come algorithm runs O(m + n) time?\n' b'An n-bit gray code sequence sequence 2n integers where:\n\nEvery integer inclusive range [0, 2n - 1],\nThe first integer 0,\nAn integer appears sequence,\nThe binary representation every pair adjacent integers differs exactly one bit, and\nThe binary representation first last integers differs exactly one bit.\n\nGiven integer n, return valid n-bit gray code sequence.\n\xc2\xa0\nExample 1:\nInput: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation [0,1,3,2] [00,01,11,10].\n- 00 01 differ one bit\n- 01 11 differ one bit\n- 11 10 differ one bit\n- 10 00 differ one bit\n[0,2,3,1] also valid gray code sequence, whose binary representation [00,10,11,01].\n- 00 10 differ one bit\n- 10 11 differ one bit\n- 11 01 differ one bit\n- 01 00 differ one bit\n\nExample 2:\nInput: n = 1\nOutput: [0,1]\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 16\n\n' b'Given integer array nums may contain duplicates, return possible subsets (the power set).\nThe solution set must contain duplicate subsets. Return solution order.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\nExample 2:\nInput: nums = [0]\nOutput: [[],[0]]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 10\n-10 <= nums[i] <= 10\n\n' b'A message containing letters A-Z encoded numbers using following mapping:\n\'A\' -> "1"\n\'B\' -> "2"\n...\n\'Z\' -> "26"\n\nTo decode encoded message, digits must grouped mapped back letters using reverse mapping (there may multiple ways). For example, "11106" mapped into:\n\n"AAJF" grouping (1 1 10 6)\n"KJF" grouping (11 10 6)\n\nNote grouping (1 11 06) invalid "06" cannot mapped \'F\' since "6" different "06".\nGiven string containing digits, return number ways decode it.\nThe test cases generated answer fits 32-bit integer.\n\xc2\xa0\nExample 1:\nInput: = "12"\nOutput: 2\nExplanation: "12" could decoded "AB" (1 2) "L" (12).\n\nExample 2:\nInput: = "226"\nOutput: 3\nExplanation: "226" could decoded "BZ" (2 26), "VF" (22 6), "BBF" (2 2 6).\n\nExample 3:\nInput: = "06"\nOutput: 0\nExplanation: "06" cannot mapped "F" leading zero ("6" different "06").\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 100\ns contains digits may contain leading zero(s).\n\n' b'Given head singly linked list two integers left right left <= right, reverse nodes list position left position right, return reversed list.\n\xc2\xa0\nExample 1:\n\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\n\nExample 2:\nInput: head = [5], left = 1, right = 1\nOutput: [5]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list n.\n1 <= n <= 500\n-500 <= Node.val <= 500\n1 <= left <= right <= n\n\n\xc2\xa0\nFollow up: Could one pass?' b'A valid IP address consists exactly four integers separated single dots. Each integer 0 255 (inclusive) cannot leading zeros.\n\nFor example, "0.1.2.201" "192.168.1.1" valid IP addresses, "0.011.255.245", "192.168.1.312" "192.168@1.1" invalid IP addresses.\n\nGiven string containing digits, return possible valid IP addresses formed inserting dots s. You allowed reorder remove digits s. You may return valid IP addresses order.\n\xc2\xa0\nExample 1:\nInput: = "25525511135"\nOutput: ["255.255.11.135","255.255.111.35"]\n\nExample 2:\nInput: = "0000"\nOutput: ["0.0.0.0"]\n\nExample 3:\nInput: = "101023"\nOutput: ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 20\ns consists digits only.\n\n' b"Given root binary tree, return inorder traversal nodes' values.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,null,2,3]\nOutput: [1,3,2]\n\nExample 2:\nInput: root = []\nOutput: []\n\nExample 3:\nInput: root = [1]\nOutput: [1]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 100].\n-100 <= Node.val <= 100\n\n\xc2\xa0\nFollow up: Recursive solution trivial, could iteratively?" b"Given integer n, return structurally unique BST's (binary search trees), exactly n nodes unique values 1 n. Return answer order.\n\xc2\xa0\nExample 1:\n\nInput: n = 3\nOutput: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n\nExample 2:\nInput: n = 1\nOutput: [[1]]\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 8\n\n" b"Given integer n, return number structurally unique BST's (binary search trees) exactly n nodes unique values 1 n.\n\xc2\xa0\nExample 1:\n\nInput: n = 3\nOutput: 5\n\nExample 2:\nInput: n = 1\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 19\n\n" b'Given strings s1, s2, s3, find whether s3 formed interleaving s1 s2.\nAn interleaving two strings configuration divided non-empty substrings that:\n\ns = s1 + s2 + ... + sn\nt = t1 + t2 + ... + tm\n|n - m| <= 1\nThe interleaving s1 + t1 + s2 + t2 + s3 + t3 + ... t1 + s1 + t2 + s2 + t3 + s3 + ...\n\nNote: + b concatenation strings b.\n\xc2\xa0\nExample 1:\n\nInput: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"\nOutput: true\n\nExample 2:\nInput: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"\nOutput: false\n\nExample 3:\nInput: s1 = "", s2 = "", s3 = ""\nOutput: true\n\n\xc2\xa0\nConstraints:\n\n0 <= s1.length, s2.length <= 100\n0 <= s3.length <= 200\ns1, s2, s3 consist lowercase English letters.\n\n\xc2\xa0\nFollow up: Could solve using O(s2.length) additional memory space?\n' b"Given root binary tree, determine valid binary search tree (BST).\nA valid BST defined follows:\n\nThe left subtree node contains nodes keys less node's key.\nThe right subtree node contains nodes keys greater node's key.\nBoth left right subtrees must also binary search trees.\n\n\xc2\xa0\nExample 1:\n\nInput: root = [2,1,3]\nOutput: true\n\nExample 2:\n\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value 5 right child's value 4.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 104].\n-231 <= Node.val <= 231 - 1\n\n" b'You given root binary search tree (BST), values exactly two nodes tree swapped mistake. Recover tree without changing structure.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,3,null,null,2]\nOutput: [3,1,null,null,2]\nExplanation: 3 cannot left child 1 3 > 1. Swapping 1 3 makes BST valid.\n\nExample 2:\n\nInput: root = [3,1,4,null,null,2]\nOutput: [2,1,4,null,null,3]\nExplanation: 2 cannot right subtree 3 2 < 3. Swapping 2 3 makes BST valid.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [2, 1000].\n-231 <= Node.val <= 231 - 1\n\n\xc2\xa0\nFollow up: A solution using O(n) space pretty straight-forward. Could devise constant O(1) space solution?' b'Given roots two binary trees p q, write function check not.\nTwo binary trees considered structurally identical, nodes value.\n\xc2\xa0\nExample 1:\n\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n\nExample 2:\n\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n\nExample 3:\n\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n\n\xc2\xa0\nConstraints:\n\nThe number nodes trees range [0, 100].\n-104 <= Node.val <= 104\n\n' b'Given root binary tree, check whether mirror (i.e., symmetric around center).\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\n\nExample 2:\n\nInput: root = [1,2,2,null,3,null,3]\nOutput: false\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 1000].\n-100 <= Node.val <= 100\n\n\xc2\xa0\nFollow up: Could solve recursively iteratively?' b"Given root binary tree, return level order traversal nodes' values. (i.e., left right, level level).\n\xc2\xa0\nExample 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\n\nExample 2:\nInput: root = [1]\nOutput: [[1]]\n\nExample 3:\nInput: root = []\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 2000].\n-1000 <= Node.val <= 1000\n\n" b"Given root binary tree, return zigzag level order traversal nodes' values. (i.e., left right, right left next level alternate between).\n\xc2\xa0\nExample 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[20,9],[15,7]]\n\nExample 2:\nInput: root = [1]\nOutput: [[1]]\n\nExample 3:\nInput: root = []\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 2000].\n-100 <= Node.val <= 100\n\n" b"Given root binary tree, return maximum depth.\nA binary tree's maximum depth\xc2\xa0is number nodes along longest path root node farthest leaf node.\n\xc2\xa0\nExample 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n\nExample 2:\nInput: root = [1,null,2]\nOutput: 2\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 104].\n-100 <= Node.val <= 100\n\n" b'Given two integer arrays preorder inorder preorder preorder traversal binary tree inorder inorder traversal tree, construct return binary tree.\n\xc2\xa0\nExample 1:\n\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\n\nExample 2:\nInput: preorder = [-1], inorder = [-1]\nOutput: [-1]\n\n\xc2\xa0\nConstraints:\n\n1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder inorder consist unique values.\nEach value inorder also appears preorder.\npreorder guaranteed preorder traversal tree.\ninorder guaranteed inorder traversal tree.\n\n' b'Given two integer arrays inorder postorder inorder inorder traversal binary tree postorder postorder traversal tree, construct return binary tree.\n\xc2\xa0\nExample 1:\n\nInput: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]\n\nExample 2:\nInput: inorder = [-1], postorder = [-1]\nOutput: [-1]\n\n\xc2\xa0\nConstraints:\n\n1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder postorder consist unique values.\nEach value postorder also appears inorder.\ninorder guaranteed inorder traversal tree.\npostorder guaranteed postorder traversal tree.\n\n' b"Given root binary tree, return bottom-up level order traversal nodes' values. (i.e., left right, level level leaf root).\n\xc2\xa0\nExample 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]\n\nExample 2:\nInput: root = [1]\nOutput: [[1]]\n\nExample 3:\nInput: root = []\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 2000].\n-1000 <= Node.val <= 1000\n\n" b'Given integer array nums elements sorted ascending order, convert height-balanced binary search tree.\nA height-balanced binary tree binary tree depth two subtrees every node never differs one.\n\xc2\xa0\nExample 1:\n\nInput: nums = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: [0,-10,5,null,-3,null,9] also accepted:\n\n\nExample 2:\n\nInput: nums = [1,3]\nOutput: [3,1]\nExplanation: [1,null,3] [3,1] height-balanced BSTs.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums sorted strictly increasing order.\n\n' b'Given head singly linked list elements sorted ascending order, convert height balanced BST.\nFor problem, height-balanced binary tree defined binary tree depth two subtrees every node never differ 1.\n\xc2\xa0\nExample 1:\n\nInput: head = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: One possible answer [0,-3,9,-10,null,5], represents shown height balanced BST.\n\nExample 2:\nInput: head = []\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes head range [0, 2 * 104].\n-105 <= Node.val <= 105\n\n' b'Given binary tree, determine height-balanced.\nFor problem, height-balanced binary tree defined as:\n\na binary tree left right subtrees every node differ height 1.\n\n\xc2\xa0\nExample 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: true\n\nExample 2:\n\nInput: root = [1,2,2,3,3,null,null,4,4]\nOutput: false\n\nExample 3:\nInput: root = []\nOutput: true\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 5000].\n-104 <= Node.val <= 104\n\n' b'Given binary tree, find minimum depth.\nThe minimum depth number nodes along shortest path root node nearest leaf node.\nNote:\xc2\xa0A leaf node children.\n\xc2\xa0\nExample 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\n\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 105].\n-1000 <= Node.val <= 1000\n\n' b'Given root binary tree integer targetSum, return true tree root-to-leaf path adding values along path equals targetSum.\nA leaf node children.\n\xc2\xa0\nExample 1:\n\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\nOutput: true\nExplanation: The root-to-leaf path target sum shown.\n\nExample 2:\n\nInput: root = [1,2,3], targetSum = 5\nOutput: false\nExplanation: There two root-to-leaf paths tree:\n(1 --> 2): The sum 3.\n(1 --> 3): The sum 4.\nThere root-to-leaf path sum = 5.\n\nExample 3:\nInput: root = [], targetSum = 0\nOutput: false\nExplanation: Since tree empty, root-to-leaf paths.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 5000].\n-1000 <= Node.val <= 1000\n-1000 <= targetSum <= 1000\n\n' b'Given root binary tree integer targetSum, return root-to-leaf paths sum node values path equals targetSum. Each path returned list node values, node references.\nA root-to-leaf path path starting root ending leaf node. A leaf node children.\n\xc2\xa0\nExample 1:\n\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: [[5,4,11,2],[5,8,4,5]]\nExplanation: There two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22\n\nExample 2:\n\nInput: root = [1,2,3], targetSum = 5\nOutput: []\n\nExample 3:\nInput: root = [1,2], targetSum = 0\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 5000].\n-1000 <= Node.val <= 1000\n-1000 <= targetSum <= 1000\n\n' b'Given root binary tree, flatten tree "linked list":\n\nThe "linked list" use TreeNode class right child pointer points next node list left child pointer always null.\nThe "linked list" order pre-order traversal binary tree.\n\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,5,3,4,null,6]\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\n\nExample 2:\nInput: root = []\nOutput: []\n\nExample 3:\nInput: root = [0]\nOutput: [0]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 2000].\n-100 <= Node.val <= 100\n\n\xc2\xa0\nFollow up: Can flatten tree in-place (with O(1) extra space)?' b'Given two strings t, return number distinct subsequences equals t.\nA string\'s subsequence new string formed original string deleting (can none) characters without disturbing remaining characters\' relative positions. (i.e., "ACE" subsequence "ABCDE" "AEC" not).\nThe test cases generated answer fits 32-bit signed integer.\n\xc2\xa0\nExample 1:\nInput: = "rabbbit", = "rabbit"\nOutput: 3\nExplanation:\nAs shown below, 3 ways generate "rabbit" S.\nrabbbit\nrabbbit\nrabbbit\n\nExample 2:\nInput: = "babgbag", = "bag"\nOutput: 5\nExplanation:\nAs shown below, 5 ways generate "bag" S.\nbabgbag\nbabgbag\nbabgbag\nbabgbag\nbabgbag\n\xc2\xa0\nConstraints:\n\n1 <= s.length, t.length <= 1000\ns consist English letters.\n\n' b"You given perfect binary tree leaves level, every parent two children. The binary tree following definition:\nstruct Node {\n int val;\n Node *left;\n Node *right;\n Node *next;\n}\n\nPopulate next pointer point next right node. If next right node, next pointer set NULL.\nInitially, next pointers set NULL.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3,4,5,6,7]\nOutput: [1,#,2,3,#,4,5,6,7,#]\nExplanation: Given perfect binary tree (Figure A), function populate next pointer point next right node, like Figure B. The serialized output level order connected next pointers, '#' signifying end level.\n\nExample 2:\nInput: root = []\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 212 - 1].\n-1000 <= Node.val <= 1000\n\n\xc2\xa0\nFollow-up:\n\nYou may use constant extra space.\nThe recursive approach fine. You may assume implicit stack space count extra space problem.\n\n" b"Given binary tree\nstruct Node {\n int val;\n Node *left;\n Node *right;\n Node *next;\n}\n\nPopulate next pointer point next right node. If next right node, next pointer set NULL.\nInitially, next pointers set NULL.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3,4,5,null,7]\nOutput: [1,#,2,3,#,4,5,7,#]\nExplanation: Given binary tree (Figure A), function populate next pointer point next right node, like Figure B. The serialized output level order connected next pointers, '#' signifying end level.\n\nExample 2:\nInput: root = []\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 6000].\n-100 <= Node.val <= 100\n\n\xc2\xa0\nFollow-up:\n\nYou may use constant extra space.\nThe recursive approach fine. You may assume implicit stack space count extra space problem.\n\n" b"Given integer numRows, return first numRows Pascal's triangle.\nIn Pascal's triangle, number sum two numbers directly shown:\n\n\xc2\xa0\nExample 1:\nInput: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\nExample 2:\nInput: numRows = 1\nOutput: [[1]]\n\n\xc2\xa0\nConstraints:\n\n1 <= numRows <= 30\n\n" b"Given integer rowIndex, return rowIndexth (0-indexed) row Pascal's triangle.\nIn Pascal's triangle, number sum two numbers directly shown:\n\n\xc2\xa0\nExample 1:\nInput: rowIndex = 3\nOutput: [1,3,3,1]\nExample 2:\nInput: rowIndex = 0\nOutput: [1]\nExample 3:\nInput: rowIndex = 1\nOutput: [1,1]\n\n\xc2\xa0\nConstraints:\n\n0 <= rowIndex <= 33\n\n\xc2\xa0\nFollow up: Could optimize algorithm use O(rowIndex) extra space?\n" b'Given triangle array, return minimum path sum top bottom.\nFor step, may move adjacent number row below. More formally, index current row, may move either index index + 1 next row.\n\xc2\xa0\nExample 1:\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n 2\n 3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum top bottom 2 + 3 + 5 + 1 = 11 (underlined above).\n\nExample 2:\nInput: triangle = [[-10]]\nOutput: -10\n\n\xc2\xa0\nConstraints:\n\n1 <= triangle.length <= 200\ntriangle[0].length == 1\ntriangle[i].length == triangle[i - 1].length + 1\n-104 <= triangle[i][j] <= 104\n\n\xc2\xa0\nFollow up: Could you\xc2\xa0do using O(n) extra space, n total number rows triangle?' b'You given array prices prices[i] price given stock ith day.\nYou want maximize profit choosing single day buy one stock choosing different day future sell stock.\nReturn maximum profit achieve transaction. If cannot achieve profit, return 0.\n\xc2\xa0\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy day 2 (price = 1) sell day 5 (price = 6), profit = 6-1 = 5.\nNote buying day 2 selling day 1 allowed must buy sell.\n\nExample 2:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In case, transactions done max profit = 0.\n\n\xc2\xa0\nConstraints:\n\n1 <= prices.length <= 105\n0 <= prices[i] <= 104\n\n' b'You given integer array prices prices[i] price given stock ith day.\nOn day, may decide buy and/or sell stock. You hold one share stock time. However, buy immediately sell day.\nFind return maximum profit achieve.\n\xc2\xa0\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy day 2 (price = 1) sell day 3 (price = 5), profit = 5-1 = 4.\nThen buy day 4 (price = 3) sell day 5 (price = 6), profit = 6-3 = 3.\nTotal profit 4 + 3 = 7.\n\nExample 2:\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy day 1 (price = 1) sell day 5 (price = 5), profit = 5-1 = 4.\nTotal profit 4.\n\nExample 3:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There way make positive profit, never buy stock achieve maximum profit 0.\n\n\xc2\xa0\nConstraints:\n\n1 <= prices.length <= 3 * 104\n0 <= prices[i] <= 104\n\n' b'You given array prices prices[i] price given stock ith day.\nFind maximum profit achieve. You may complete two transactions.\nNote: You may engage multiple transactions simultaneously (i.e., must sell stock buy again).\n\xc2\xa0\nExample 1:\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy day 4 (price = 0) sell day 6 (price = 3), profit = 3-0 = 3.\nThen buy day 7 (price = 1) sell day 8 (price = 4), profit = 4-1 = 3.\nExample 2:\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy day 1 (price = 1) sell day 5 (price = 5), profit = 5-1 = 4.\nNote cannot buy day 1, buy day 2 sell later, engaging multiple transactions time. You must sell buying again.\n\nExample 3:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In case, transaction done, i.e. max profit = 0.\n\n\xc2\xa0\nConstraints:\n\n1 <= prices.length <= 105\n0 <= prices[i] <= 105\n\n' b"A path binary tree sequence nodes pair adjacent nodes sequence edge connecting them. A node appear sequence once. Note path need pass root.\nThe path sum path sum node's values path.\nGiven root binary tree, return maximum path sum non-empty path.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path 2 -> 1 -> 3 path sum 2 + 1 + 3 = 6.\n\nExample 2:\n\nInput: root = [-10,9,20,null,null,15,7]\nOutput: 42\nExplanation: The optimal path 15 -> 20 -> 7 path sum 15 + 20 + 7 = 42.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 3 * 104].\n-1000 <= Node.val <= 1000\n\n" b'A phrase palindrome if, converting uppercase letters lowercase letters removing non-alphanumeric characters, reads forward backward. Alphanumeric characters include letters numbers.\nGiven string s, return true palindrome, false otherwise.\n\xc2\xa0\nExample 1:\nInput: = "A man, plan, canal: Panama"\nOutput: true\nExplanation: "amanaplanacanalpanama" palindrome.\n\nExample 2:\nInput: = "race car"\nOutput: false\nExplanation: "raceacar" palindrome.\n\nExample 3:\nInput: = " "\nOutput: true\nExplanation: empty string "" removing non-alphanumeric characters.\nSince empty string reads forward backward, palindrome.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 2 * 105\ns consists printable ASCII characters.\n\n' b'A transformation sequence word beginWord word endWord using dictionary wordList sequence words beginWord -> s1 -> s2 -> ... -> sk that:\n\nEvery adjacent pair words differs single letter.\nEvery si 1 <= <= k wordList. Note beginWord need wordList.\nsk == endWord\n\nGiven two words, beginWord endWord, dictionary wordList, return shortest transformation sequences beginWord endWord, empty list sequence exists. Each sequence returned list words [beginWord, s1, s2, ..., sk].\n\xc2\xa0\nExample 1:\nInput: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]\nOutput: [["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]\nExplanation:\xc2\xa0There 2 shortest transformation sequences:\n"hit" -> "hot" -> "dot" -> "dog" -> "cog"\n"hit" -> "hot" -> "lot" -> "log" -> "cog"\n\nExample 2:\nInput: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]\nOutput: []\nExplanation: The endWord "cog" wordList, therefore valid transformation sequence.\n\n\xc2\xa0\nConstraints:\n\n1 <= beginWord.length <= 5\nendWord.length == beginWord.length\n1 <= wordList.length <= 1000\nwordList[i].length == beginWord.length\nbeginWord, endWord, wordList[i] consist lowercase English letters.\nbeginWord != endWord\nAll words wordList unique.\n\n' b'A transformation sequence word beginWord word endWord using dictionary wordList sequence words beginWord -> s1 -> s2 -> ... -> sk that:\n\nEvery adjacent pair words differs single letter.\nEvery si 1 <= <= k wordList. Note beginWord need wordList.\nsk == endWord\n\nGiven two words, beginWord endWord, dictionary wordList, return number words shortest transformation sequence beginWord endWord, 0 sequence exists.\n\xc2\xa0\nExample 1:\nInput: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]\nOutput: 5\nExplanation: One shortest transformation sequence "hit" -> "hot" -> "dot" -> "dog" -> cog", 5 words long.\n\nExample 2:\nInput: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]\nOutput: 0\nExplanation: The endWord "cog" wordList, therefore valid transformation sequence.\n\n\xc2\xa0\nConstraints:\n\n1 <= beginWord.length <= 10\nendWord.length == beginWord.length\n1 <= wordList.length <= 5000\nwordList[i].length == beginWord.length\nbeginWord, endWord, wordList[i] consist lowercase English letters.\nbeginWord != endWord\nAll words wordList unique.\n\n' b'Given unsorted array integers nums, return length longest consecutive elements sequence.\nYou must write algorithm runs in\xc2\xa0O(n)\xc2\xa0time.\n\xc2\xa0\nExample 1:\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence [1, 2, 3, 4]. Therefore length 4.\n\nExample 2:\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\n\n\xc2\xa0\nConstraints:\n\n0 <= nums.length <= 105\n-109 <= nums[i] <= 109\n\n' b'You given root binary tree containing digits 0 9 only.\nEach root-to-leaf path tree represents number.\n\nFor example, root-to-leaf path 1 -> 2 -> 3 represents number 123.\n\nReturn total sum root-to-leaf numbers. Test cases generated answer fit 32-bit integer.\nA leaf node node children.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3]\nOutput: 25\nExplanation:\nThe root-to-leaf path 1->2 represents number 12.\nThe root-to-leaf path 1->3 represents number 13.\nTherefore, sum = 12 + 13 = 25.\n\nExample 2:\n\nInput: root = [4,9,0,5,1]\nOutput: 1026\nExplanation:\nThe root-to-leaf path 4->9->5 represents number 495.\nThe root-to-leaf path 4->9->1 represents number 491.\nThe root-to-leaf path 4->0 represents number 40.\nTherefore, sum = 495 + 491 + 40 = 1026.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 1000].\n0 <= Node.val <= 9\nThe depth tree exceed 10.\n\n' b'Given x n matrix board containing \'X\' \'O\', capture regions 4-directionally\xc2\xa0surrounded \'X\'.\nA region captured flipping \'O\'s \'X\'s surrounded region.\n\xc2\xa0\nExample 1:\n\nInput: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]\nOutput: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]\nExplanation: Surrounded regions border, means \'O\' border board flipped \'X\'. Any \'O\' border connected \'O\' border flipped \'X\'. Two cells connected adjacent cells connected horizontally vertically.\n\nExample 2:\nInput: board = [["X"]]\nOutput: [["X"]]\n\n\xc2\xa0\nConstraints:\n\nm == board.length\nn == board[i].length\n1 <= m, n <= 200\nboard[i][j] \'X\' \'O\'.\n\n' b'Given string s, partition every substring partition palindrome. Return possible palindrome partitioning s.\nA palindrome string string reads backward forward.\n\xc2\xa0\nExample 1:\nInput: = "aab"\nOutput: [["a","a","b"],["aa","b"]]\nExample 2:\nInput: = "a"\nOutput: [["a"]]\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 16\ns contains lowercase English letters.\n\n' b'Given string s, partition every substring partition palindrome.\nReturn minimum cuts needed palindrome partitioning s.\n\xc2\xa0\nExample 1:\nInput: = "aab"\nOutput: 1\nExplanation: The palindrome partitioning ["aa","b"] could produced using 1 cut.\n\nExample 2:\nInput: = "a"\nOutput: 0\n\nExample 3:\nInput: = "ab"\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 2000\ns consists lowercase English letters only.\n\n' b"Given reference node connected undirected graph.\nReturn deep copy (clone) graph.\nEach node graph contains value (int) list (List[Node]) neighbors.\nclass Node {\n public int val;\n public List<Node> neighbors;\n}\n\n\xc2\xa0\nTest case format:\nFor simplicity, node's value node's index (1-indexed). For example, first node val == 1, second node val == 2, on. The graph represented test case using adjacency list.\nAn adjacency list collection unordered lists used represent finite graph. Each list describes set neighbors node graph.\nThe given node always first node val = 1. You must return copy given node reference cloned graph.\n\xc2\xa0\nExample 1:\n\nInput: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]\nExplanation: There 4 nodes graph.\n1st node (val = 1)'s neighbors 2nd node (val = 2) 4th node (val = 4).\n2nd node (val = 2)'s neighbors 1st node (val = 1) 3rd node (val = 3).\n3rd node (val = 3)'s neighbors 2nd node (val = 2) 4th node (val = 4).\n4th node (val = 4)'s neighbors 1st node (val = 1) 3rd node (val = 3).\n\nExample 2:\n\nInput: adjList = [[]]\nOutput: [[]]\nExplanation: Note input contains one empty list. The graph consists one node val = 1 neighbors.\n\nExample 3:\nInput: adjList = []\nOutput: []\nExplanation: This empty graph, nodes.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes graph range [0, 100].\n1 <= Node.val <= 100\nNode.val unique node.\nThere repeated edges self-loops graph.\nThe Graph connected nodes visited starting given node.\n\n" b"There n gas stations along circular route, amount gas ith station gas[i].\nYou car unlimited gas tank costs cost[i] gas travel ith station next (i + 1)th station. You begin journey empty tank one gas stations.\nGiven two integer arrays gas cost, return starting gas station's index travel around circuit clockwise direction, otherwise return -1. If exists solution, guaranteed unique\n\xc2\xa0\nExample 1:\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\nOutput: 3\nExplanation:\nStart station 3 (index 3) fill 4 unit gas. Your tank = 0 + 4 = 4\nTravel station 4. Your tank = 4 - 1 + 5 = 8\nTravel station 0. Your tank = 8 - 2 + 1 = 7\nTravel station 1. Your tank = 7 - 3 + 2 = 6\nTravel station 2. Your tank = 6 - 4 + 3 = 5\nTravel station 3. The cost 5. Your gas enough travel back station 3.\nTherefore, return 3 starting index.\n\nExample 2:\nInput: gas = [2,3,4], cost = [3,4,3]\nOutput: -1\nExplanation:\nYou can't start station 0 1, enough gas travel next station.\nLet's start station 2 fill 4 unit gas. Your tank = 0 + 4 = 4\nTravel station 0. Your tank = 4 - 3 + 2 = 3\nTravel station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back station 2, requires 4 unit gas 3.\nTherefore, can't travel around circuit matter start.\n\n\xc2\xa0\nConstraints:\n\nn == gas.length == cost.length\n1 <= n <= 105\n0 <= gas[i], cost[i] <= 104\n\n" b'There n children standing line. Each child assigned rating value given integer array ratings.\nYou giving candies children subjected following requirements:\n\nEach child must least one candy.\nChildren higher rating get candies neighbors.\n\nReturn minimum number candies need distribute candies children.\n\xc2\xa0\nExample 1:\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You allocate first, second third child 2, 1, 2 candies respectively.\n\nExample 2:\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You allocate first, second third child 1, 2, 1 candies respectively.\nThe third child gets 1 candy satisfies two conditions.\n\n\xc2\xa0\nConstraints:\n\nn == ratings.length\n1 <= n <= 2 * 104\n0 <= ratings[i] <= 2 * 104\n\n' b'Given non-empty\xc2\xa0array integers nums, every element appears twice except one. Find single one.\nYou must\xc2\xa0implement solution linear runtime complexity use\xc2\xa0only constant\xc2\xa0extra space.\n\xc2\xa0\nExample 1:\nInput: nums = [2,2,1]\nOutput: 1\nExample 2:\nInput: nums = [4,1,2,1,2]\nOutput: 4\nExample 3:\nInput: nums = [1]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 3 * 104\n-3 * 104 <= nums[i] <= 3 * 104\nEach element array appears twice except one element appears once.\n\n' b'Given integer array nums where\xc2\xa0every element appears three times except one, appears exactly once. Find single element return it.\nYou must\xc2\xa0implement solution linear runtime complexity use\xc2\xa0only constant\xc2\xa0extra space.\n\xc2\xa0\nExample 1:\nInput: nums = [2,2,3,2]\nOutput: 3\nExample 2:\nInput: nums = [0,1,0,1,0,1,99]\nOutput: 99\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 3 * 104\n-231 <= nums[i] <= 231 - 1\nEach element nums appears exactly three times except one element appears once.\n\n' b'A linked list length n given node contains additional random pointer, could point node list, null.\nConstruct deep copy list. The deep copy consist exactly n brand new nodes, new node value set value corresponding original node. Both next random pointer new nodes point new nodes copied list pointers original list copied list represent list state. None pointers new list point nodes original list.\nFor example, two nodes X Y original list, X.random --> Y, corresponding two nodes x copied list, x.random --> y.\nReturn head copied linked list.\nThe linked list represented input/output list n nodes. Each node represented pair [val, random_index] where:\n\nval: integer representing Node.val\nrandom_index: index node (range 0 n-1) random pointer points to, null point node.\n\nYour code given head original linked list.\n\xc2\xa0\nExample 1:\n\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\n\nExample 2:\n\nInput: head = [[1,1],[2,1]]\nOutput: [[1,1],[2,1]]\n\nExample 3:\n\nInput: head = [[3,null],[3,0],[3,null]]\nOutput: [[3,null],[3,0],[3,null]]\n\n\xc2\xa0\nConstraints:\n\n0 <= n <= 1000\n-104 <= Node.val <= 104\nNode.random null pointing node linked list.\n\n' b'Given string dictionary strings wordDict, return true segmented space-separated sequence one dictionary words.\nNote word dictionary may reused multiple times segmentation.\n\xc2\xa0\nExample 1:\nInput: = "leetcode", wordDict = ["leet","code"]\nOutput: true\nExplanation: Return true "leetcode" segmented "leet code".\n\nExample 2:\nInput: = "applepenapple", wordDict = ["apple","pen"]\nOutput: true\nExplanation: Return true "applepenapple" segmented "apple pen apple".\nNote allowed reuse dictionary word.\n\nExample 3:\nInput: = "catsandog", wordDict = ["cats","dog","sand","and","cat"]\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 300\n1 <= wordDict.length <= 1000\n1 <= wordDict[i].length <= 20\ns wordDict[i] consist lowercase English letters.\nAll strings wordDict unique.\n\n' b'Given string dictionary strings wordDict, add spaces construct sentence word valid dictionary word. Return possible sentences order.\nNote word dictionary may reused multiple times segmentation.\n\xc2\xa0\nExample 1:\nInput: = "catsanddog", wordDict = ["cat","cats","and","sand","dog"]\nOutput: ["cats dog","cat sand dog"]\n\nExample 2:\nInput: = "pineapplepenapple", wordDict = ["apple","pen","applepen","pine","pineapple"]\nOutput: ["pine apple pen apple","pineapple pen apple","pine applepen apple"]\nExplanation: Note allowed reuse dictionary word.\n\nExample 3:\nInput: = "catsandog", wordDict = ["cats","dog","sand","and","cat"]\nOutput: []\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 20\n1 <= wordDict.length <= 1000\n1 <= wordDict[i].length <= 10\ns wordDict[i] consist lowercase English letters.\nAll strings wordDict unique.\n\n' b"Given head, head linked list, determine linked list cycle it.\nThere cycle linked list node list reached continuously following the\xc2\xa0next\xc2\xa0pointer. Internally, pos\xc2\xa0is used denote index node that\xc2\xa0tail's\xc2\xa0next\xc2\xa0pointer connected to.\xc2\xa0Note that\xc2\xa0pos\xc2\xa0is passed parameter.\nReturn\xc2\xa0true cycle linked list. Otherwise, return false.\n\xc2\xa0\nExample 1:\n\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There cycle linked list, tail connects 1st node (0-indexed).\n\nExample 2:\n\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There cycle linked list, tail connects 0th node.\n\nExample 3:\n\nInput: head = [1], pos = -1\nOutput: false\nExplanation: There cycle linked list.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list range [0, 104].\n-105 <= Node.val <= 105\npos -1 valid index linked-list.\n\n\xc2\xa0\nFollow up: Can solve using O(1) (i.e. constant) memory?\n" b"Given head linked list, return node cycle begins. If cycle, return null.\nThere cycle linked list node list reached continuously following next pointer. Internally, pos used denote index node tail's next pointer connected (0-indexed). It -1 cycle. Note pos passed parameter.\nDo modify linked list.\n\xc2\xa0\nExample 1:\n\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects node index 1\nExplanation: There cycle linked list, tail connects second node.\n\nExample 2:\n\nInput: head = [1,2], pos = 0\nOutput: tail connects node index 0\nExplanation: There cycle linked list, tail connects first node.\n\nExample 3:\n\nInput: head = [1], pos = -1\nOutput: cycle\nExplanation: There cycle linked list.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list range [0, 104].\n-105 <= Node.val <= 105\npos -1 valid index linked-list.\n\n\xc2\xa0\nFollow up: Can solve using O(1) (i.e. constant) memory?\n" b"You given head singly linked-list. The list represented as:\nL0 \xe2\x86\x92 L1 \xe2\x86\x92 \xe2\x80\xa6 \xe2\x86\x92 Ln - 1 \xe2\x86\x92 Ln\n\nReorder list following form:\nL0 \xe2\x86\x92 Ln \xe2\x86\x92 L1 \xe2\x86\x92 Ln - 1 \xe2\x86\x92 L2 \xe2\x86\x92 Ln - 2 \xe2\x86\x92 \xe2\x80\xa6\n\nYou may modify values list's nodes. Only nodes may changed.\n\xc2\xa0\nExample 1:\n\nInput: head = [1,2,3,4]\nOutput: [1,4,2,3]\n\nExample 2:\n\nInput: head = [1,2,3,4,5]\nOutput: [1,5,2,4,3]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list range [1, 5 * 104].\n1 <= Node.val <= 1000\n\n" b"Given root binary tree, return preorder traversal nodes' values.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,null,2,3]\nOutput: [1,2,3]\n\nExample 2:\nInput: root = []\nOutput: []\n\nExample 3:\nInput: root = [1]\nOutput: [1]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 100].\n-100 <= Node.val <= 100\n\n\xc2\xa0\nFollow up: Recursive solution trivial, could iteratively?\n" b"Given root a\xc2\xa0binary tree, return postorder traversal nodes' values.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,null,2,3]\nOutput: [3,2,1]\n\nExample 2:\nInput: root = []\nOutput: []\n\nExample 3:\nInput: root = [1]\nOutput: [1]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 100].\n-100 <= Node.val <= 100\n\n\xc2\xa0\nFollow up: Recursive solution trivial, could iteratively?" b'Design data structure follows constraints Least Recently Used (LRU) cache.\nImplement LRUCache class:\n\nLRUCache(int capacity) Initialize LRU cache positive size capacity.\nint get(int key) Return value key key exists, otherwise return -1.\nvoid put(int key, int value)\xc2\xa0Update value key key exists. Otherwise, add key-value pair cache. If number keys exceeds capacity operation, evict least recently used key.\n\nThe functions\xc2\xa0get\xc2\xa0and\xc2\xa0put\xc2\xa0must run O(1) average time complexity.\n\xc2\xa0\nExample 1:\nInput\n["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache {1=1}\nlRUCache.put(2, 2); // cache {1=1, 2=2}\nlRUCache.get(1); // return 1\nlRUCache.put(3, 3); // LRU key 2, evicts key 2, cache {1=1, 3=3}\nlRUCache.get(2); // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key 1, evicts key 1, cache {4=4, 3=3}\nlRUCache.get(1); // return -1 (not found)\nlRUCache.get(3); // return 3\nlRUCache.get(4); // return 4\n\n\xc2\xa0\nConstraints:\n\n1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt 2\xc2\xa0* 105\xc2\xa0calls made get put.\n\n' b"Given head singly linked list, sort list using insertion sort, return sorted list's head.\nThe steps insertion sort algorithm:\n\nInsertion sort iterates, consuming one input element repetition growing sorted output list.\nAt iteration, insertion sort removes one element input data, finds location belongs within sorted list inserts there.\nIt repeats input elements remain.\n\nThe following graphical example insertion sort algorithm. The partially sorted list (black) initially contains first element list. One element (red) removed input data inserted in-place sorted list iteration.\n\n\xc2\xa0\nExample 1:\n\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n\nExample 2:\n\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list range [1, 5000].\n-5000 <= Node.val <= 5000\n\n" b'Given head linked list, return list sorting ascending order.\n\xc2\xa0\nExample 1:\n\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n\nExample 2:\n\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n\nExample 3:\nInput: head = []\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list range [0, 5 * 104].\n-105 <= Node.val <= 105\n\n\xc2\xa0\nFollow up: Can sort linked list O(n logn) time O(1) memory (i.e. constant space)?\n' b'Given array points points[i] = [xi, yi] represents point X-Y plane, return maximum number points lie straight line.\n\xc2\xa0\nExample 1:\n\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: 3\n\nExample 2:\n\nInput: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4\n\n\xc2\xa0\nConstraints:\n\n1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll points unique.\n\n' b'Evaluate value arithmetic expression Reverse Polish Notation.\nValid operators +, -, *, /. Each operand may integer another expression.\nNote division two integers truncate toward zero.\nIt guaranteed given RPN expression always valid. That means expression would always evaluate result, division zero operation.\n\xc2\xa0\nExample 1:\nInput: tokens = ["2","1","+","3","*"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\n\nExample 2:\nInput: tokens = ["4","13","5","/","+"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\n\nExample 3:\nInput: tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]\nOutput: 22\nExplanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n\n\xc2\xa0\nConstraints:\n\n1 <= tokens.length <= 104\ntokens[i] either operator: "+", "-", "*", "/", integer range [-200, 200].\n\n' b'Given input string s, reverse order words.\nA word defined sequence non-space characters. The words separated least one space.\nReturn string words reverse order concatenated single space.\nNote may contain leading trailing spaces multiple spaces two words. The returned string single space separating words. Do include extra spaces.\n\xc2\xa0\nExample 1:\nInput: = "the sky blue"\nOutput: "blue sky the"\n\nExample 2:\nInput: = " hello world "\nOutput: "world hello"\nExplanation: Your reversed string contain leading trailing spaces.\n\nExample 3:\nInput: = "a good example"\nOutput: "example good a"\nExplanation: You need reduce multiple spaces two words single space reversed string.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 104\ns contains English letters (upper-case lower-case), digits, spaces \' \'.\nThere least one word s.\n\n\xc2\xa0\nFollow-up:\xc2\xa0If string data type mutable language, can\xc2\xa0you solve it\xc2\xa0in-place\xc2\xa0with\xc2\xa0O(1)\xc2\xa0extra space?\n' b'Given integer array nums, find contiguous non-empty subarray within array largest product, return product.\nThe test cases generated answer fit 32-bit integer.\nA subarray contiguous subsequence array.\n\xc2\xa0\nExample 1:\nInput: nums = [2,3,-2,4]\nOutput: 6\nExplanation: [2,3] largest product 6.\n\nExample 2:\nInput: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot 2, [-2,-1] subarray.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 2 * 104\n-10 <= nums[i] <= 10\nThe product prefix suffix nums guaranteed fit 32-bit integer.\n\n' b'Suppose array length n sorted ascending order rotated 1 n times. For example, array nums = [0,1,2,4,5,6,7] might become:\n\n[4,5,6,7,0,1,2] rotated 4 times.\n[0,1,2,4,5,6,7] rotated 7 times.\n\nNotice rotating array [a[0], a[1], a[2], ..., a[n-1]] 1 time results array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven sorted rotated array nums unique elements, return minimum element array.\nYou must write algorithm runs in\xc2\xa0O(log n) time.\n\xc2\xa0\nExample 1:\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array [1,2,3,4,5] rotated 3 times.\n\nExample 2:\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array [0,1,2,4,5,6,7] rotated 4 times.\n\nExample 3:\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array [11,13,15,17] rotated 4 times. \n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= n <= 5000\n-5000 <= nums[i] <= 5000\nAll integers nums unique.\nnums sorted rotated 1 n times.\n\n' b'Suppose array length n sorted ascending order rotated 1 n times. For example, array nums = [0,1,4,4,5,6,7] might become:\n\n[4,5,6,7,0,1,4] rotated 4 times.\n[0,1,4,4,5,6,7] rotated 7 times.\n\nNotice rotating array [a[0], a[1], a[2], ..., a[n-1]] 1 time results array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven sorted rotated array nums may contain duplicates, return minimum element array.\nYou must decrease overall operation steps much possible.\n\xc2\xa0\nExample 1:\nInput: nums = [1,3,5]\nOutput: 1\nExample 2:\nInput: nums = [2,2,2,0,1]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= n <= 5000\n-5000 <= nums[i] <= 5000\nnums sorted rotated 1 n times.\n\n\xc2\xa0\nFollow up: This problem similar to\xc2\xa0Find Minimum Rotated Sorted Array, but\xc2\xa0nums may contain duplicates. Would affect runtime complexity? How why?\n\xc2\xa0\n' b'Design stack supports push, pop, top, retrieving minimum element constant time.\nImplement MinStack class:\n\nMinStack() initializes stack object.\nvoid push(int val) pushes element val onto stack.\nvoid pop() removes element top stack.\nint top() gets top element stack.\nint getMin() retrieves minimum element stack.\n\n\xc2\xa0\nExample 1:\nInput\n["MinStack","push","push","push","getMin","pop","top","getMin"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\nOutput\n[null,null,null,null,-3,null,0,-2]\n\nExplanation\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top(); // return 0\nminStack.getMin(); // return -2\n\n\xc2\xa0\nConstraints:\n\n-231 <= val <= 231 - 1\nMethods pop, top getMin operations always called non-empty stacks.\nAt 3 * 104 calls made push, pop, top, getMin.\n\n' b"Given heads two singly linked-lists headA headB, return node two lists intersect. If two linked lists intersection all, return null.\nFor example, following two linked lists begin intersect node c1:\n\nThe test cases generated cycles anywhere entire linked structure.\nNote linked lists must retain original structure function returns.\nCustom Judge:\nThe inputs judge given follows (your program given inputs):\n\nintersectVal - The value node intersection occurs. This 0 intersected node.\nlistA - The first linked list.\nlistB - The second linked list.\nskipA - The number nodes skip ahead listA (starting head) get intersected node.\nskipB - The number nodes skip ahead listB (starting head) get intersected node.\n\nThe judge create linked structure based inputs pass two heads, headA headB\xc2\xa0to program. If correctly return intersected node, solution accepted.\n\xc2\xa0\nExample 1:\n\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\nOutput: Intersected '8'\nExplanation: The intersected node's value 8 (note must 0 two lists intersect).\nFrom head A, reads [4,1,8,4,5]. From head B, reads [5,6,1,8,4,5]. There 2 nodes intersected node A; There 3 nodes intersected node B.\n\nExample 2:\n\nInput: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\nOutput: Intersected '2'\nExplanation: The intersected node's value 2 (note must 0 two lists intersect).\nFrom head A, reads [1,9,1,2,4]. From head B, reads [3,2,4]. There 3 nodes intersected node A; There 1 node intersected node B.\n\nExample 3:\n\nInput: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\nOutput: No intersection\nExplanation: From head A, reads [2,6,4]. From head B, reads [1,5]. Since two lists intersect, intersectVal must 0, skipA skipB arbitrary values.\nExplanation: The two lists intersect, return null.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes listA m.\nThe number nodes listB n.\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <\xc2\xa0m\n0 <= skipB <\xc2\xa0n\nintersectVal 0 listA listB intersect.\nintersectVal == listA[skipA] == listB[skipB] listA listB intersect.\n\n\xc2\xa0\nFollow up: Could write solution runs O(m + n) time use O(1) memory?" b'A peak element element strictly greater neighbors.\nGiven integer array nums, find peak element, return index. If\xc2\xa0the array contains multiple peaks, return index peaks.\nYou may imagine nums[-1] = nums[n] = -\xe2\x88\x9e.\nYou must write algorithm runs in\xc2\xa0O(log n) time.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 peak element function return index number 2.\nExample 2:\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function return either index number 1 peak element 2, index number 5 peak element 6.\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] valid i.\n\n' b'Given integer array nums, return maximum difference two successive elements sorted form. If array contains less two elements, return 0.\nYou must write algorithm runs linear time uses linear extra space.\n\xc2\xa0\nExample 1:\nInput: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form array [1,3,6,9], either (3,6) (6,9) maximum difference 3.\n\nExample 2:\nInput: nums = [10]\nOutput: 0\nExplanation: The array contains less 2 elements, therefore return 0.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 109\n\n' b'Given two version numbers,\xc2\xa0version1 version2, compare them.\n\n\nVersion numbers consist one revisions joined dot\xc2\xa0\'.\'. Each revision\xc2\xa0consists digits\xc2\xa0and may contain leading zeros. Every revision contains least one character. Revisions 0-indexed left right, leftmost revision revision 0, next revision revision 1, on. For example\xc2\xa02.5.33\xc2\xa0and\xc2\xa00.1\xc2\xa0are valid version numbers.\nTo compare version numbers, compare revisions left-to-right order. Revisions compared using their\xc2\xa0integer value ignoring leading zeros. This means revisions\xc2\xa01\xc2\xa0and\xc2\xa0001\xc2\xa0are considered\xc2\xa0equal. If version number specify revision index, then\xc2\xa0treat revision as\xc2\xa00. For example, version\xc2\xa01.0 less version\xc2\xa01.1\xc2\xa0because revision 0s same, revision 1s are\xc2\xa00\xc2\xa0and\xc2\xa01\xc2\xa0respectively, and\xc2\xa00 < 1.\nReturn following:\n\nIf version1 < version2, return -1.\nIf version1 > version2, return 1.\nOtherwise, return 0.\n\n\xc2\xa0\nExample 1:\nInput: version1 = "1.01", version2 = "1.001"\nOutput: 0\nExplanation: Ignoring leading zeroes, "01" "001" represent integer "1".\n\nExample 2:\nInput: version1 = "1.0", version2 = "1.0.0"\nOutput: 0\nExplanation: version1 specify revision 2, means treated "0".\n\nExample 3:\nInput: version1 = "0.1", version2 = "1.1"\nOutput: -1\nExplanation: version1\'s revision 0 "0", version2\'s revision 0 "1". 0 < 1, version1 < version2.\n\n\xc2\xa0\nConstraints:\n\n1 <= version1.length, version2.length <= 500\nversion1 version2\xc2\xa0only contain digits \'.\'.\nversion1 version2\xc2\xa0are valid version numbers.\nAll given revisions in\xc2\xa0version1 version2\xc2\xa0can stored in\xc2\xa0a\xc2\xa032-bit integer.\n\n' b'Given two integers representing numerator denominator fraction, return fraction string format.\nIf fractional part repeating, enclose repeating part parentheses.\nIf multiple answers possible, return them.\nIt guaranteed length answer string less 104 given inputs.\n\xc2\xa0\nExample 1:\nInput: numerator = 1, denominator = 2\nOutput: "0.5"\n\nExample 2:\nInput: numerator = 2, denominator = 1\nOutput: "2"\n\nExample 3:\nInput: numerator = 4, denominator = 333\nOutput: "0.(012)"\n\n\xc2\xa0\nConstraints:\n\n-231 <=\xc2\xa0numerator, denominator <= 231 - 1\ndenominator != 0\n\n' b'Given 1-indexed array integers numbers already sorted non-decreasing order, find two numbers add specific target number. Let two numbers numbers[index1] numbers[index2] 1 <= index1 < index2 <= numbers.length.\nReturn indices two numbers, index1 index2, added one integer array [index1, index2] length 2.\nThe tests generated exactly one solution. You may use element twice.\nYour solution must use constant extra space.\n\xc2\xa0\nExample 1:\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum 2 7 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\n\nExample 2:\nInput: numbers = [2,3,4], target = 6\nOutput: [1,3]\nExplanation: The sum 2 4 6. Therefore index1 = 1, index2 = 3. We return [1, 3].\n\nExample 3:\nInput: numbers = [-1,0], target = -1\nOutput: [1,2]\nExplanation: The sum -1 0 -1. Therefore index1 = 1, index2 = 2. We return [1, 2].\n\n\xc2\xa0\nConstraints:\n\n2 <= numbers.length <= 3 * 104\n-1000 <= numbers[i] <= 1000\nnumbers sorted non-decreasing order.\n-1000 <= target <= 1000\nThe tests generated exactly one solution.\n\n' b'Given integer columnNumber, return corresponding column title appears Excel sheet.\nFor example:\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n\xc2\xa0\nExample 1:\nInput: columnNumber = 1\nOutput: "A"\n\nExample 2:\nInput: columnNumber = 28\nOutput: "AB"\n\nExample 3:\nInput: columnNumber = 701\nOutput: "ZY"\n\n\xc2\xa0\nConstraints:\n\n1 <= columnNumber <= 231 - 1\n\n' b'Given array nums size n, return majority element.\nThe majority element element appears \xe2\x8c\x8an / 2\xe2\x8c\x8b times. You may assume majority element always exists array.\n\xc2\xa0\nExample 1:\nInput: nums = [3,2,3]\nOutput: 3\nExample 2:\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= n <= 5 * 104\n-109 <= nums[i] <= 109\n\n\xc2\xa0\nFollow-up: Could solve problem linear time O(1) space?' b'Given string columnTitle represents column title appears Excel sheet, return corresponding column number.\nFor example:\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n\xc2\xa0\nExample 1:\nInput: columnTitle = "A"\nOutput: 1\n\nExample 2:\nInput: columnTitle = "AB"\nOutput: 28\n\nExample 3:\nInput: columnTitle = "ZY"\nOutput: 701\n\n\xc2\xa0\nConstraints:\n\n1 <= columnTitle.length <= 7\ncolumnTitle consists uppercase English letters.\ncolumnTitle range ["A", "FXSHRXW"].\n\n' b'Given integer n, return number trailing zeroes n!.\nNote n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.\n\xc2\xa0\nExample 1:\nInput: n = 3\nOutput: 0\nExplanation: 3! = 6, trailing zero.\n\nExample 2:\nInput: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.\n\nExample 3:\nInput: n = 0\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n0 <= n <= 104\n\n\xc2\xa0\nFollow up: Could write solution works logarithmic time complexity?\n' b'Implement BSTIterator class represents iterator in-order traversal binary search tree (BST):\n\nBSTIterator(TreeNode root) Initializes object BSTIterator class. The root BST given part constructor. The pointer initialized non-existent number smaller element BST.\nboolean hasNext() Returns true exists number traversal right pointer, otherwise returns false.\nint next() Moves pointer right, returns number pointer.\n\nNotice initializing pointer non-existent smallest number, first call next() return smallest element BST.\nYou may assume next() calls always valid. That is, least next number in-order traversal next() called.\n\xc2\xa0\nExample 1:\n\nInput\n["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\nOutput\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\nExplanation\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next(); // return 3\nbSTIterator.next(); // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next(); // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next(); // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next(); // return 20\nbSTIterator.hasNext(); // return False\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 105].\n0 <= Node.val <= 106\nAt 105 calls made hasNext, next.\n\n\xc2\xa0\nFollow up:\n\nCould implement next() hasNext() run average O(1) time use\xc2\xa0O(h) memory, h height tree?\n\n' b"The demons captured princess imprisoned bottom-right corner dungeon. The dungeon consists x n rooms laid 2D grid. Our valiant knight initially positioned top-left room must fight way dungeon rescue princess.\nThe knight initial health point represented positive integer. If point health point drops 0 below, dies immediately.\nSome rooms guarded demons (represented negative integers), knight loses health upon entering rooms; rooms either empty (represented 0) contain magic orbs increase knight's health (represented positive integers).\nTo reach princess quickly possible, knight decides move rightward downward step.\nReturn knight's minimum initial health rescue princess.\nNote room contain threats power-ups, even first room knight enters bottom-right room princess imprisoned.\n\xc2\xa0\nExample 1:\n\nInput: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\nOutput: 7\nExplanation: The initial health knight must least 7 follows optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n\nExample 2:\nInput: dungeon = [[0]]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\nm == dungeon.length\nn == dungeon[i].length\n1 <= m, n <= 200\n-1000 <= dungeon[i][j] <= 1000\n\n" b'SQL Schema' b'SQL Schema' b'SQL Schema' b'SQL Schema' b'Given list non-negative integers nums, arrange form largest number return it.\nSince result may large, need return string instead integer.\n\xc2\xa0\nExample 1:\nInput: nums = [10,2]\nOutput: "210"\n\nExample 2:\nInput: nums = [3,30,34,5,9]\nOutput: "9534330"\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 109\n\n' b'SQL Schema' b'SQL Schema' b'SQL Schema' b'SQL Schema' b'SQL Schema' b'SQL Schema' b'The DNA sequence composed series nucleotides abbreviated \'A\', \'C\', \'G\', \'T\'.\n\nFor example, "ACGAATTCCG" DNA sequence.\n\nWhen studying DNA, useful identify repeated sequences within DNA.\nGiven string represents DNA sequence, return 10-letter-long sequences (substrings) occur DNA molecule. You may return answer order.\n\xc2\xa0\nExample 1:\nInput: = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"\nOutput: ["AAAAACCCCC","CCCCCAAAAA"]\nExample 2:\nInput: = "AAAAAAAAAAAAA"\nOutput: ["AAAAAAAAAA"]\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 105\ns[i] either \'A\', \'C\', \'G\', \'T\'.\n\n' b'You given integer array prices prices[i] price given stock ith day, integer k.\nFind maximum profit achieve. You may complete k transactions.\nNote: You may engage multiple transactions simultaneously (i.e., must sell stock buy again).\n\xc2\xa0\nExample 1:\nInput: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy day 1 (price = 2) sell day 2 (price = 4), profit = 4-2 = 2.\n\nExample 2:\nInput: k = 2, prices = [3,2,6,5,0,3]\nOutput: 7\nExplanation: Buy day 2 (price = 2) sell day 3 (price = 6), profit = 6-2 = 4. Then buy day 5 (price = 0) sell day 6 (price = 3), profit = 3-0 = 3.\n\n\xc2\xa0\nConstraints:\n\n0 <= k <= 100\n0 <= prices.length <= 1000\n0 <= prices[i] <= 1000\n\n' b'Given array, rotate array right k steps, k non-negative.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps right: [7,1,2,3,4,5,6]\nrotate 2 steps right: [6,7,1,2,3,4,5]\nrotate 3 steps right: [5,6,7,1,2,3,4]\n\nExample 2:\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps right: [99,-1,-100,3]\nrotate 2 steps right: [3,99,-1,-100]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105\n\n\xc2\xa0\nFollow up:\n\nTry come many solutions can. There least three different ways solve problem.\nCould in-place O(1) extra space?\n\n' b"Reverse bits given 32 bits unsigned integer.\nNote:\n\nNote languages, Java, unsigned integer type. In case, input output given signed integer type. They affect implementation, integer's internal binary representation same, whether signed unsigned.\nIn Java, compiler represents signed integers using 2's complement notation. Therefore, Example 2 above, input represents signed integer -3 output represents signed integer -1073741825.\n\n\xc2\xa0\nExample 1:\nInput: n = 00000010100101000001111010011100\nOutput: 964176192 (00111001011110000010100101000000)\nExplanation: The input binary string 00000010100101000001111010011100 represents unsigned integer 43261596, return 964176192 binary representation 00111001011110000010100101000000.\n\nExample 2:\nInput: n = 11111111111111111111111111111101\nOutput: 3221225471 (10111111111111111111111111111111)\nExplanation: The input binary string 11111111111111111111111111111101 represents unsigned integer 4294967293, return 3221225471 binary representation 10111111111111111111111111111111.\n\n\xc2\xa0\nConstraints:\n\nThe input must binary string length 32\n\n\xc2\xa0\nFollow up: If function called many times, would optimize it?\n" b"Write function takes unsigned integer returns number '1' bits (also known Hamming weight).\nNote:\n\nNote languages, Java, unsigned integer type. In case, input given signed integer type. It affect implementation, integer's internal binary representation same, whether signed unsigned.\nIn Java, compiler represents signed integers using 2's complement notation. Therefore, Example 3, input represents signed integer. -3.\n\n\xc2\xa0\nExample 1:\nInput: n = 00000000000000000000000000001011\nOutput: 3\nExplanation: The input binary string 00000000000000000000000000001011 total three '1' bits.\n\nExample 2:\nInput: n = 00000000000000000000000010000000\nOutput: 1\nExplanation: The input binary string 00000000000000000000000010000000 total one '1' bit.\n\nExample 3:\nInput: n = 11111111111111111111111111111101\nOutput: 31\nExplanation: The input binary string 11111111111111111111111111111101 total thirty one '1' bits.\n\n\xc2\xa0\nConstraints:\n\nThe input must binary string length 32.\n\n\xc2\xa0\nFollow up: If function called many times, would optimize it?" b"Write bash script calculate frequency word text file words.txt.\nFor simplicity sake, may assume:\n\nwords.txt contains lowercase characters space ' ' characters.\nEach word must consist lowercase characters only.\nWords separated one whitespace characters.\n\nExample:\nAssume words.txt following content:\nthe day sunny the\nthe sunny is\n\nYour script output following, sorted descending frequency:\nthe 4\nis 3\nsunny 2\nday 1\n\nNote:\n\nDon't worry handling ties, guaranteed word's frequency count unique.\nCould write one-line using Unix pipes?\n\n" b'Given text file file.txt contains list phone numbers (one per line), write one-liner bash script print valid phone numbers.\nYou may assume valid phone number must appear one following two formats: (xxx) xxx-xxxx xxx-xxx-xxxx. (x means digit)\nYou may also assume line text file must contain leading trailing white spaces.\nExample:\nAssume file.txt following content:\n987-123-4567\n123 456 7890\n(123) 456-7890\n\nYour script output following valid phone numbers:\n987-123-4567\n(123) 456-7890\n\n' b"Given text file file.txt, transpose content.\nYou may assume row number columns, field separated ' ' character.\nExample:\nIf file.txt following content:\nname age\nalice 21\nryan 30\n\nOutput following:\nname alice ryan\nage 21 30\n\n" b"Given text file\xc2\xa0file.txt, print\xc2\xa0just 10th line the\xc2\xa0file.\nExample:\nAssume file.txt following content:\nLine 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7\nLine 8\nLine 9\nLine 10\n\nYour script output tenth line, is:\nLine 10\n\nNote:\n1. If file contains less 10 lines, output?\n2. There's least three different solutions. Try explore possibilities.\n" b'SQL Schema' b'SQL Schema' b'You professional robber planning rob houses along street. Each house certain amount money stashed, constraint stopping robbing adjacent houses security systems connected automatically contact police two adjacent houses broken night.\nGiven integer array nums representing amount money house, return maximum amount money rob tonight without alerting police.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) rob house 3 (money = 3).\nTotal amount rob = 1 + 3 = 4.\n\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) rob house 5 (money = 1).\nTotal amount rob = 2 + 9 + 1 = 12.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 400\n\n' b'Given root binary tree, imagine standing right side it, return values nodes see ordered top bottom.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4]\n\nExample 2:\nInput: root = [1,null,3]\nOutput: [1,3]\n\nExample 3:\nInput: root = []\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 100].\n-100 <= Node.val <= 100\n\n' b'Given x n 2D binary grid grid represents map \'1\'s (land) \'0\'s (water), return number islands.\nAn island surrounded water formed connecting adjacent lands horizontally vertically. You may assume four edges grid surrounded water.\n\xc2\xa0\nExample 1:\nInput: grid = [\n ["1","1","1","1","0"],\n ["1","1","0","1","0"],\n ["1","1","0","0","0"],\n ["0","0","0","0","0"]\n]\nOutput: 1\n\nExample 2:\nInput: grid = [\n ["1","1","0","0","0"],\n ["1","1","0","0","0"],\n ["0","0","1","0","0"],\n ["0","0","0","1","1"]\n]\nOutput: 3\n\n\xc2\xa0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 300\ngrid[i][j] \'0\' \'1\'.\n\n' b'Given two integers left right represent range [left, right], return bitwise AND numbers range, inclusive.\n\xc2\xa0\nExample 1:\nInput: left = 5, right = 7\nOutput: 4\n\nExample 2:\nInput: left = 0, right = 0\nOutput: 0\n\nExample 3:\nInput: left = 1, right = 2147483647\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n0 <= left <= right <= 231 - 1\n\n' b'Write algorithm determine number n happy.\nA happy number number defined following process:\n\nStarting positive integer, replace number sum squares digits.\nRepeat process number equals 1 (where stay), loops endlessly cycle include 1.\nThose numbers process ends 1 happy.\n\nReturn true n happy number, false not.\n\xc2\xa0\nExample 1:\nInput: n = 19\nOutput: true\nExplanation:\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n\nExample 2:\nInput: n = 2\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 231 - 1\n\n' b'Given head linked list integer val, remove nodes linked list Node.val == val, return new head.\n\xc2\xa0\nExample 1:\n\nInput: head = [1,2,6,3,4,5,6], val = 6\nOutput: [1,2,3,4,5]\n\nExample 2:\nInput: head = [], val = 1\nOutput: []\n\nExample 3:\nInput: head = [7,7,7,7], val = 7\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list range [0, 104].\n1 <= Node.val <= 50\n0 <= val <= 50\n\n' b'Given integer n, return number prime numbers strictly less n.\n\xc2\xa0\nExample 1:\nInput: n = 10\nOutput: 4\nExplanation: There 4 prime numbers less 10, 2, 3, 5, 7.\n\nExample 2:\nInput: n = 0\nOutput: 0\n\nExample 3:\nInput: n = 1\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n0 <= n <= 5 * 106\n\n' b'Given two strings t, determine isomorphic.\nTwo strings isomorphic characters replaced get t.\nAll occurrences character must replaced another character preserving order characters. No two characters may map character, character may map itself.\n\xc2\xa0\nExample 1:\nInput: = "egg", = "add"\nOutput: true\nExample 2:\nInput: = "foo", = "bar"\nOutput: false\nExample 3:\nInput: = "paper", = "title"\nOutput: true\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 5 * 104\nt.length == s.length\ns consist valid ascii character.\n\n' b'Given head singly linked list, reverse list, return reversed list.\n\xc2\xa0\nExample 1:\n\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n\nExample 2:\n\nInput: head = [1,2]\nOutput: [2,1]\n\nExample 3:\nInput: head = []\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list range [0, 5000].\n-5000 <= Node.val <= 5000\n\n\xc2\xa0\nFollow up: A linked list reversed either iteratively recursively. Could implement both?\n' b'There total numCourses courses take, labeled 0 numCourses - 1. You given array prerequisites prerequisites[i] = [ai, bi] indicates must take course bi first want take course ai.\n\nFor example, pair [0, 1], indicates take course 0 first take course 1.\n\nReturn true finish courses. Otherwise, return false.\n\xc2\xa0\nExample 1:\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There total 2 courses take. \nTo take course 1 finished course 0. So possible.\n\nExample 2:\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There total 2 courses take. \nTo take course 1 finished course 0, take course 0 also finished course 1. So impossible.\n\n\xc2\xa0\nConstraints:\n\n1 <= numCourses <= 2000\n0 <= prerequisites.length <= 5000\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nAll pairs prerequisites[i] unique.\n\n' b'A trie (pronounced "try") prefix tree tree data structure used efficiently store retrieve keys dataset strings. There various applications data structure, autocomplete spellchecker.\nImplement Trie class:\n\nTrie() Initializes trie object.\nvoid insert(String word) Inserts string word trie.\nboolean search(String word) Returns true string word trie (i.e., inserted before), false otherwise.\nboolean startsWith(String prefix) Returns true previously inserted string word prefix prefix, false otherwise.\n\n\xc2\xa0\nExample 1:\nInput\n["Trie", "insert", "search", "search", "startsWith", "insert", "search"]\n[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]\nOutput\n[null, null, true, false, true, null, true]\n\nExplanation\nTrie trie = new Trie();\ntrie.insert("apple");\ntrie.search("apple"); // return True\ntrie.search("app"); // return False\ntrie.startsWith("app"); // return True\ntrie.insert("app");\ntrie.search("app"); // return True\n\n\xc2\xa0\nConstraints:\n\n1 <= word.length, prefix.length <= 2000\nword prefix consist lowercase English letters.\nAt 3 * 104 calls total made insert, search, startsWith.\n\n' b'Given array positive integers nums positive integer target, return minimal length contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] sum greater equal target. If subarray, return 0 instead.\n\xc2\xa0\nExample 1:\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] minimal length problem constraint.\n\nExample 2:\nInput: target = 4, nums = [1,4,4]\nOutput: 1\n\nExample 3:\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <= target <= 109\n1 <= nums.length <= 105\n1 <= nums[i] <= 105\n\n\xc2\xa0\nFollow up: If figured O(n) solution, try coding another solution time complexity O(n log(n)).' b'There total numCourses courses take, labeled 0 numCourses - 1. You given array prerequisites prerequisites[i] = [ai, bi] indicates must take course bi first want take course ai.\n\nFor example, pair [0, 1], indicates take course 0 first take course 1.\n\nReturn ordering courses take finish courses. If many valid answers, return them. If impossible finish courses, return empty array.\n\xc2\xa0\nExample 1:\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There total 2 courses take. To take course 1 finished course 0. So correct course order [0,1].\n\nExample 2:\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There total 4 courses take. To take course 3 finished courses 1 2. Both courses 1 2 taken finished course 0.\nSo one correct course order [0,1,2,3]. Another correct ordering [0,2,1,3].\n\nExample 3:\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\n\n\xc2\xa0\nConstraints:\n\n1 <= numCourses <= 2000\n0 <= prerequisites.length <= numCourses * (numCourses - 1)\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nai != bi\nAll pairs [ai, bi] distinct.\n\n' b'Design data structure supports adding new words finding string matches previously added string.\nImplement WordDictionary class:\n\nWordDictionary()\xc2\xa0Initializes object.\nvoid addWord(word) Adds word data structure, matched later.\nbool search(word)\xc2\xa0Returns true string data structure matches word\xc2\xa0or false otherwise. word may contain dots \'.\' dots matched letter.\n\n\xc2\xa0\nExample:\nInput\n["WordDictionary","addWord","addWord","addWord","search","search","search","search"]\n[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]\nOutput\n[null,null,null,null,false,true,true,true]\n\nExplanation\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord("bad");\nwordDictionary.addWord("dad");\nwordDictionary.addWord("mad");\nwordDictionary.search("pad"); // return False\nwordDictionary.search("bad"); // return True\nwordDictionary.search(".ad"); // return True\nwordDictionary.search("b.."); // return True\n\n\xc2\xa0\nConstraints:\n\n1 <= word.length <= 25\nword addWord consists lowercase English letters.\nword search consist \'.\' lowercase English letters.\nThere 3 dots word search queries.\nAt 104 calls made addWord search.\n\n' b'Given x n board\xc2\xa0of characters list strings words, return words board.\nEach word must constructed letters sequentially adjacent cells, adjacent cells horizontally vertically neighboring. The letter cell may used word.\n\xc2\xa0\nExample 1:\n\nInput: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]\nOutput: ["eat","oath"]\n\nExample 2:\n\nInput: board = [["a","b"],["c","d"]], words = ["abcb"]\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nm == board.length\nn == board[i].length\n1 <= m, n <= 12\nboard[i][j] lowercase English letter.\n1 <= words.length <= 3 * 104\n1 <= words[i].length <= 10\nwords[i] consists lowercase English letters.\nAll strings words unique.\n\n' b'You professional robber planning rob houses along street. Each house certain amount money stashed. All houses place arranged circle. That means first house neighbor last one. Meanwhile, adjacent houses security system connected, and\xc2\xa0it automatically contact police two adjacent houses broken night.\nGiven integer array nums representing amount money house, return maximum amount money rob tonight without alerting police.\n\xc2\xa0\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) rob house 3 (money = 2), adjacent houses.\n\nExample 2:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) rob house 3 (money = 3).\nTotal amount rob = 1 + 3 = 4.\n\nExample 3:\nInput: nums = [1,2,3]\nOutput: 3\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 1000\n\n' b'You given string s. You convert palindrome adding characters front it.\nReturn shortest palindrome find performing transformation.\n\xc2\xa0\nExample 1:\nInput: = "aacecaaa"\nOutput: "aaacecaaa"\nExample 2:\nInput: = "abcd"\nOutput: "dcbabcd"\n\n\xc2\xa0\nConstraints:\n\n0 <= s.length <= 5 * 104\ns consists lowercase English letters only.\n\n' b'Given integer array nums integer k, return kth largest element array.\nNote kth largest element sorted order, kth distinct element.\n\xc2\xa0\nExample 1:\nInput: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\nExample 2:\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4\n\n\xc2\xa0\nConstraints:\n\n1 <= k <= nums.length <= 104\n-104 <= nums[i] <= 104\n\n' b'Find valid combinations k numbers sum n following conditions true:\n\nOnly numbers 1 9 used.\nEach number used once.\n\nReturn list possible valid combinations. The list must contain combination twice, combinations may returned order.\n\xc2\xa0\nExample 1:\nInput: k = 3, n = 7\nOutput: [[1,2,4]]\nExplanation:\n1 + 2 + 4 = 7\nThere valid combinations.\nExample 2:\nInput: k = 3, n = 9\nOutput: [[1,2,6],[1,3,5],[2,3,4]]\nExplanation:\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere valid combinations.\n\nExample 3:\nInput: k = 4, n = 1\nOutput: []\nExplanation: There valid combinations.\nUsing 4 different numbers range [1,9], smallest sum get 1+2+3+4 = 10 since 10 > 1, valid combination.\n\n\xc2\xa0\nConstraints:\n\n2 <= k <= 9\n1 <= n <= 60\n\n' b'Given integer array nums, return true value appears least twice array, return false every element distinct.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: true\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: false\nExample 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109\n\n' b'A city\'s skyline outer contour silhouette formed buildings city viewed distance. Given locations heights buildings, return skyline formed buildings collectively.\nThe geometric information building given array buildings buildings[i] = [lefti, righti, heighti]:\n\nlefti x coordinate left edge ith building.\nrighti x coordinate right edge ith building.\nheighti height ith building.\n\nYou may assume buildings perfect rectangles grounded absolutely flat surface height 0.\nThe skyline represented list "key points" sorted x-coordinate form [[x1,y1],[x2,y2],...]. Each key point left endpoint horizontal segment skyline except last point list, always y-coordinate 0 used mark skyline\'s termination rightmost building ends. Any ground leftmost rightmost buildings part skyline\'s contour.\nNote: There must consecutive horizontal lines equal height output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] acceptable; three lines height 5 merged one final output such: [...,[2 3],[4 5],[12 7],...]\n\xc2\xa0\nExample 1:\n\nInput: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\nOutput: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\nExplanation:\nFigure A shows buildings input.\nFigure B shows skyline formed buildings. The red points figure B represent key points output list.\n\nExample 2:\nInput: buildings = [[0,2,3],[2,5,3]]\nOutput: [[0,3],[5,0]]\n\n\xc2\xa0\nConstraints:\n\n1 <= buildings.length <= 104\n0 <= lefti < righti <= 231 - 1\n1 <= heighti <= 231 - 1\nbuildings sorted lefti in\xc2\xa0non-decreasing order.\n\n' b'Given integer array nums integer k, return true two distinct indices j array nums[i] == nums[j] abs(i - j) <= k.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3,1], k = 3\nOutput: true\n\nExample 2:\nInput: nums = [1,0,1,1], k = 1\nOutput: true\n\nExample 3:\nInput: nums = [1,2,3,1,2,3], k = 2\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109\n0 <= k <= 105\n\n' b'Given integer array nums two integers k t, return true two distinct indices j array abs(nums[i] - nums[j]) <= abs(i - j) <= k.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3,1], k = 3, = 0\nOutput: true\nExample 2:\nInput: nums = [1,0,1,1], k = 1, = 2\nOutput: true\nExample 3:\nInput: nums = [1,5,9,1,5,9], k = 2, = 3\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 2 * 104\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 104\n0 <= <= 231 - 1\n\n' b'Given x n binary matrix filled 0\'s 1\'s, find largest square containing 1\'s return area.\n\xc2\xa0\nExample 1:\n\nInput: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]\nOutput: 4\n\nExample 2:\n\nInput: matrix = [["0","1"],["1","0"]]\nOutput: 1\n\nExample 3:\nInput: matrix = [["0"]]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 300\nmatrix[i][j] \'0\' \'1\'.\n\n' b'Given root complete binary tree, return number nodes tree.\nAccording Wikipedia, every level, except possibly last, completely filled complete binary tree, nodes last level far left possible. It 1 2h nodes inclusive last level h.\nDesign algorithm runs less than\xc2\xa0O(n)\xc2\xa0time complexity.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3,4,5,6]\nOutput: 6\n\nExample 2:\nInput: root = []\nOutput: 0\n\nExample 3:\nInput: root = [1]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 5 * 104].\n0 <= Node.val <= 5 * 104\nThe tree guaranteed complete.\n\n' b'Given coordinates two rectilinear rectangles 2D plane, return total area covered two rectangles.\nThe first rectangle defined bottom-left corner (ax1, ay1) top-right corner (ax2, ay2).\nThe second rectangle defined bottom-left corner (bx1, by1) top-right corner (bx2, by2).\n\xc2\xa0\nExample 1:\n\nInput: ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\nOutput: 45\n\nExample 2:\nInput: ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2\nOutput: 16\n\n\xc2\xa0\nConstraints:\n\n-104 <= ax1, ay1, ax2, ay2, bx1, by1, bx2, by2 <= 104\n\n' b'Given string representing valid expression, implement basic calculator evaluate it, return result evaluation.\nNote: You allowed use built-in function evaluates strings mathematical expressions, eval().\n\xc2\xa0\nExample 1:\nInput: = "1 + 1"\nOutput: 2\n\nExample 2:\nInput: = " 2-1 + 2 "\nOutput: 3\n\nExample 3:\nInput: = "(1+(4+5+2)-3)+(6+8)"\nOutput: 23\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 3 * 105\ns consists digits, \'+\', \'-\', \'(\', \')\', \' \'.\ns represents valid expression.\n\'+\' used unary operation (i.e., "+1" "+(2 + 3)" invalid).\n\'-\' could used unary operation (i.e., "-1" "-(2 + 3)" valid).\nThere two consecutive operators input.\nEvery number running calculation fit signed 32-bit integer.\n\n' b'Implement last-in-first-out (LIFO) stack using two queues. The implemented stack support functions normal stack (push, top, pop, empty).\nImplement MyStack class:\n\nvoid push(int x) Pushes element x top stack.\nint pop() Removes element top stack returns it.\nint top() Returns element top stack.\nboolean empty() Returns true stack empty, false otherwise.\n\nNotes:\n\nYou must use standard operations queue, means push back, peek/pop front, size empty operations valid.\nDepending language, queue may supported natively. You may simulate queue using list deque (double-ended queue) long use queue\'s standard operations.\n\n\xc2\xa0\nExample 1:\nInput\n["MyStack", "push", "push", "top", "pop", "empty"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 2, 2, false]\n\nExplanation\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False\n\n\xc2\xa0\nConstraints:\n\n1 <= x <= 9\nAt 100 calls made push, pop, top, empty.\nAll calls pop top valid.\n\n\xc2\xa0\nFollow-up: Can implement stack using one queue?\n' b'Given root binary tree, invert tree, return root.\n\xc2\xa0\nExample 1:\n\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n\nExample 2:\n\nInput: root = [2,1,3]\nOutput: [2,3,1]\n\nExample 3:\nInput: root = []\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 100].\n-100 <= Node.val <= 100\n\n' b'Given string represents expression, evaluate expression return value.\xc2\xa0\nThe integer division truncate toward zero.\nYou may assume given expression always valid. All intermediate results range [-231, 231 - 1].\nNote: You allowed use built-in function evaluates strings mathematical expressions, eval().\n\xc2\xa0\nExample 1:\nInput: = "3+2*2"\nOutput: 7\nExample 2:\nInput: = " 3/2 "\nOutput: 1\nExample 3:\nInput: = " 3+5 / 2 "\nOutput: 5\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 3 * 105\ns consists integers operators (\'+\', \'-\', \'*\', \'/\') separated number spaces.\ns represents valid expression.\nAll integers expression non-negative integers range [0, 231 - 1].\nThe answer guaranteed fit 32-bit integer.\n\n' b'You given sorted unique integer array nums.\nA range [a,b] set integers b (inclusive).\nReturn smallest sorted list ranges cover numbers array exactly. That is, element nums covered exactly one ranges, integer x x one ranges nums.\nEach range [a,b] list output as:\n\n"a->b" != b\n"a" == b\n\n\xc2\xa0\nExample 1:\nInput: nums = [0,1,2,4,5,7]\nOutput: ["0->2","4->5","7"]\nExplanation: The ranges are:\n[0,2] --> "0->2"\n[4,5] --> "4->5"\n[7,7] --> "7"\n\nExample 2:\nInput: nums = [0,2,3,4,6,8,9]\nOutput: ["0","2->4","6","8->9"]\nExplanation: The ranges are:\n[0,0] --> "0"\n[2,4] --> "2->4"\n[6,6] --> "6"\n[8,9] --> "8->9"\n\n\xc2\xa0\nConstraints:\n\n0 <= nums.length <= 20\n-231 <= nums[i] <= 231 - 1\nAll values nums unique.\nnums sorted ascending order.\n\n' b'Given integer array size n, find elements appear \xe2\x8c\x8a n/3 \xe2\x8c\x8b times.\n\xc2\xa0\nExample 1:\nInput: nums = [3,2,3]\nOutput: [3]\n\nExample 2:\nInput: nums = [1]\nOutput: [1]\n\nExample 3:\nInput: nums = [1,2]\nOutput: [1,2]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 5 * 104\n-109 <= nums[i] <= 109\n\n\xc2\xa0\nFollow up: Could solve problem linear time O(1) space?\n' b'Given root binary search tree, integer k, return kth smallest value (1-indexed) values nodes tree.\n\xc2\xa0\nExample 1:\n\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\n\nExample 2:\n\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree n.\n1 <= k <= n <= 104\n0 <= Node.val <= 104\n\n\xc2\xa0\nFollow up: If BST modified often (i.e., insert delete operations) need find kth smallest frequently, would optimize?\n' b'Given integer n, return true power two. Otherwise, return false.\nAn integer n power two, exists integer x n == 2x.\n\xc2\xa0\nExample 1:\nInput: n = 1\nOutput: true\nExplanation: 20 = 1\n\nExample 2:\nInput: n = 16\nOutput: true\nExplanation: 24 = 16\n\nExample 3:\nInput: n = 3\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n-231 <= n <= 231 - 1\n\n\xc2\xa0\nFollow up: Could solve without loops/recursion?' b'Implement first first (FIFO) queue using two stacks. The implemented queue support functions normal queue (push, peek, pop, empty).\nImplement MyQueue class:\n\nvoid push(int x) Pushes element x back queue.\nint pop() Removes element front queue returns it.\nint peek() Returns element front queue.\nboolean empty() Returns true queue empty, false otherwise.\n\nNotes:\n\nYou must use standard operations stack, means push top, peek/pop top, size, empty operations valid.\nDepending language, stack may supported natively. You may simulate stack using list deque (double-ended queue) long use stack\'s standard operations.\n\n\xc2\xa0\nExample 1:\nInput\n["MyQueue", "push", "push", "peek", "pop", "empty"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 1, 1, false]\n\nExplanation\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost front queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue [2]\nmyQueue.empty(); // return false\n\n\xc2\xa0\nConstraints:\n\n1 <= x <= 9\nAt 100\xc2\xa0calls made push, pop, peek, empty.\nAll calls pop peek valid.\n\n\xc2\xa0\nFollow-up: Can implement queue operation amortized O(1) time complexity? In words, performing n operations take overall O(n) time even one operations may take longer.\n' b'Given integer n, count total number digit 1 appearing non-negative integers less equal n.\n\xc2\xa0\nExample 1:\nInput: n = 13\nOutput: 6\n\nExample 2:\nInput: n = 0\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n0 <= n <= 109\n\n' b'Given head singly linked list, return true palindrome.\n\xc2\xa0\nExample 1:\n\nInput: head = [1,2,2,1]\nOutput: true\n\nExample 2:\n\nInput: head = [1,2]\nOutput: false\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list range [1, 105].\n0 <= Node.val <= 9\n\n\xc2\xa0\nFollow up: Could O(n) time O(1) space?' b'Given binary search tree (BST), find lowest common ancestor (LCA) two given nodes BST.\nAccording definition LCA Wikipedia: \xe2\x80\x9cThe lowest common ancestor defined two nodes p q lowest node T p q descendants (where allow node descendant itself).\xe2\x80\x9d\n\xc2\xa0\nExample 1:\n\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\nExplanation: The LCA nodes 2 8 6.\n\nExample 2:\n\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\nExplanation: The LCA nodes 2 4 2, since node descendant according LCA definition.\n\nExample 3:\nInput: root = [2,1], p = 2, q = 1\nOutput: 2\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [2, 105].\n-109 <= Node.val <= 109\nAll Node.val unique.\np != q\np q exist BST.\n\n' b'Given binary tree, find lowest common ancestor (LCA) two given nodes tree.\nAccording definition LCA Wikipedia: \xe2\x80\x9cThe lowest common ancestor defined two nodes p q lowest node T p q descendants (where allow node descendant itself).\xe2\x80\x9d\n\xc2\xa0\nExample 1:\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA nodes 5 1 3.\n\nExample 2:\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA nodes 5 4 5, since node descendant according LCA definition.\n\nExample 3:\nInput: root = [1,2], p = 1, q = 2\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [2, 105].\n-109 <= Node.val <= 109\nAll Node.val unique.\np != q\np q exist tree.\n\n' b'Write function delete node singly-linked list. You given access head list, instead given access node deleted directly.\nIt guaranteed node deleted tail node list.\n\xc2\xa0\nExample 1:\n\nInput: head = [4,5,1,9], node = 5\nOutput: [4,1,9]\nExplanation: You given second node value 5, linked list become 4 -> 1 -> 9 calling function.\n\nExample 2:\n\nInput: head = [4,5,1,9], node = 1\nOutput: [4,5,9]\nExplanation: You given third node value 1, linked list become 4 -> 5 -> 9 calling function.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes given list range [2, 1000].\n-1000 <= Node.val <= 1000\nThe value node list unique.\nThe node deleted list tail node\n\n' b'Given integer array nums, return array answer answer[i] equal product elements nums except nums[i].\nThe product prefix suffix nums guaranteed fit 32-bit integer.\nYou must write algorithm runs in\xc2\xa0O(n)\xc2\xa0time without using division operation.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\nExample 2:\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n\n\xc2\xa0\nConstraints:\n\n2 <= nums.length <= 105\n-30 <= nums[i] <= 30\nThe product prefix suffix nums guaranteed fit 32-bit integer.\n\n\xc2\xa0\nFollow up:\xc2\xa0Can solve problem O(1)\xc2\xa0extra\xc2\xa0space complexity? (The output array count extra space space complexity analysis.)\n' b'You given array integers\xc2\xa0nums, sliding window size k moving left array right. You see k numbers window. Each time sliding window moves right one position.\nReturn max sliding window.\n\xc2\xa0\nExample 1:\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]\nExplanation: \nWindow position Max\n--------------- -----\n[1 3 -1] -3 5 3 6 7 3\n 1 [3 -1 -3] 5 3 6 7 3\n 1 3 [-1 -3 5] 3 6 7 5\n 1 3 -1 [-3 5 3] 6 7 5\n 1 3 -1 -3 [5 3 6] 7 6\n 1 3 -1 -3 5 [3 6 7] 7\n\nExample 2:\nInput: nums = [1], k = 1\nOutput: [1]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n1 <= k <= nums.length\n\n' b'Write efficient algorithm searches value target x n integer matrix matrix. This matrix following properties:\n\nIntegers row sorted ascending left right.\nIntegers column sorted ascending top bottom.\n\n\xc2\xa0\nExample 1:\n\nInput: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\nOutput: true\n\nExample 2:\n\nInput: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\nOutput: false\n\n\xc2\xa0\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= n, <= 300\n-109 <= matrix[i][j] <= 109\nAll integers row sorted ascending order.\nAll integers column sorted ascending order.\n-109 <= target <= 109\n\n' b'Given string expression numbers operators, return possible results computing different possible ways group numbers operators. You may return answer order.\n\xc2\xa0\nExample 1:\nInput: expression = "2-1-1"\nOutput: [0,2]\nExplanation:\n((2-1)-1) = 0 \n(2-(1-1)) = 2\n\nExample 2:\nInput: expression = "2*3-4*5"\nOutput: [-34,-14,-10,-10,10]\nExplanation:\n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10\n\n\xc2\xa0\nConstraints:\n\n1 <= expression.length <= 20\nexpression consists digits operator \'+\', \'-\', \'*\'.\nAll integer values input expression range [0, 99].\n\n' b'Given two strings t, return true anagram s, false otherwise.\nAn Anagram word phrase formed rearranging letters different word phrase, typically using original letters exactly once.\n\xc2\xa0\nExample 1:\nInput: = "anagram", = "nagaram"\nOutput: true\nExample 2:\nInput: = "rat", = "car"\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length, t.length <= 5 * 104\ns consist lowercase English letters.\n\n\xc2\xa0\nFollow up: What inputs contain Unicode characters? How would adapt solution case?\n' b'Given root binary tree, return root-to-leaf paths order.\nA leaf node children.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3,null,5]\nOutput: ["1->2->5","1->3"]\n\nExample 2:\nInput: root = [1]\nOutput: ["1"]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 100].\n-100 <= Node.val <= 100\n\n' b'Given integer num, repeatedly add digits result one digit, return it.\n\xc2\xa0\nExample 1:\nInput: num = 38\nOutput: 2\nExplanation: The process is\n38 --> 3 + 8 --> 11\n11 --> 1 + 1 --> 2 \nSince 2 one digit, return it.\n\nExample 2:\nInput: num = 0\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n0 <= num <= 231 - 1\n\n\xc2\xa0\nFollow up: Could without loop/recursion O(1) runtime?\n' b'Given integer array nums, exactly two elements appear elements appear exactly twice. Find two elements appear once. You return answer order.\nYou must write an\xc2\xa0algorithm runs linear runtime complexity uses\xc2\xa0only constant extra space.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,1,3,2,5]\nOutput: [3,5]\nExplanation: [5, 3] also valid answer.\n\nExample 2:\nInput: nums = [-1,0]\nOutput: [-1,0]\n\nExample 3:\nInput: nums = [0,1]\nOutput: [1,0]\n\n\xc2\xa0\nConstraints:\n\n2 <= nums.length <= 3 * 104\n-231 <= nums[i] <= 231 - 1\nEach integer nums appear twice, two integers appear once.\n\n' b'SQL Schema' b'An ugly number positive integer whose prime factors limited 2, 3, 5.\nGiven integer n, return true n ugly number.\n\xc2\xa0\nExample 1:\nInput: n = 6\nOutput: true\nExplanation: 6 = 2 \xc3\x97 3\n\nExample 2:\nInput: n = 1\nOutput: true\nExplanation: 1 prime factors, therefore prime factors limited 2, 3, 5.\n\nExample 3:\nInput: n = 14\nOutput: false\nExplanation: 14 ugly since includes prime factor 7.\n\n\xc2\xa0\nConstraints:\n\n-231 <= n <= 231 - 1\n\n' b'An ugly number positive integer whose prime factors limited 2, 3, 5.\nGiven integer n, return nth ugly number.\n\xc2\xa0\nExample 1:\nInput: n = 10\nOutput: 12\nExplanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] sequence first 10 ugly numbers.\n\nExample 2:\nInput: n = 1\nOutput: 1\nExplanation: 1 prime factors, therefore prime factors limited 2, 3, 5.\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 1690\n\n' b'Given array nums containing n distinct numbers range [0, n], return number range missing array.\n\xc2\xa0\nExample 1:\nInput: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since 3 numbers, numbers range [0,3]. 2 missing number range since appear nums.\n\nExample 2:\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since 2 numbers, numbers range [0,2]. 2 missing number range since appear nums.\n\nExample 3:\nInput: nums = [9,6,4,2,3,5,7,0,1]\nOutput: 8\nExplanation: n = 9 since 9 numbers, numbers range [0,9]. 8 missing number range since appear nums.\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= n <= 104\n0 <= nums[i] <= n\nAll numbers nums unique.\n\n\xc2\xa0\nFollow up: Could implement solution using O(1) extra space complexity O(n) runtime complexity?\n' b'Convert non-negative integer num English words representation.\n\xc2\xa0\nExample 1:\nInput: num = 123\nOutput: "One Hundred Twenty Three"\n\nExample 2:\nInput: num = 12345\nOutput: "Twelve Thousand Three Hundred Forty Five"\n\nExample 3:\nInput: num = 1234567\nOutput: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"\n\n\xc2\xa0\nConstraints:\n\n0 <= num <= 231 - 1\n\n' b"Given array integers citations citations[i] number citations researcher received ith paper, return compute researcher's h-index.\nAccording definition h-index Wikipedia: A scientist index h h n papers least h citations each, n \xe2\x88\x92 h papers h citations each.\nIf several possible values h, maximum one taken h-index.\n\xc2\xa0\nExample 1:\nInput: citations = [3,0,6,1,5]\nOutput: 3\nExplanation: [3,0,6,1,5] means researcher 5 papers total received 3, 0, 6, 1, 5 citations respectively.\nSince researcher 3 papers least 3 citations remaining two 3 citations each, h-index 3.\n\nExample 2:\nInput: citations = [1,3,1]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\nn == citations.length\n1 <= n <= 5000\n0 <= citations[i] <= 1000\n\n" b"Given array integers citations citations[i] number citations researcher received ith paper citations\xc2\xa0is sorted ascending order, return compute researcher's h-index.\nAccording definition h-index Wikipedia: A scientist index h h n papers least h citations each, n \xe2\x88\x92 h papers h citations each.\nIf several possible values h, maximum one taken h-index.\nYou must write algorithm runs logarithmic time.\n\xc2\xa0\nExample 1:\nInput: citations = [0,1,3,5,6]\nOutput: 3\nExplanation: [0,1,3,5,6] means researcher 5 papers total received 0, 1, 3, 5, 6 citations respectively.\nSince researcher 3 papers least 3 citations remaining two 3 citations each, h-index 3.\n\nExample 2:\nInput: citations = [1,2,100]\nOutput: 2\n\n\xc2\xa0\nConstraints:\n\nn == citations.length\n1 <= n <= 105\n0 <= citations[i] <= 1000\ncitations sorted ascending order.\n\n" b'You product manager currently leading team develop new product. Unfortunately, latest version product fails quality check. Since version developed based previous version, versions bad version also bad.\nSuppose n versions [1, 2, ..., n] want find first bad one, causes following ones bad.\nYou given API bool isBadVersion(version) returns whether version bad. Implement function find first bad version. You minimize number calls API.\n\xc2\xa0\nExample 1:\nInput: n = 5, bad = 4\nOutput: 4\nExplanation:\ncall isBadVersion(3) -> false\ncall isBadVersion(5)\xc2\xa0-> true\ncall isBadVersion(4)\xc2\xa0-> true\nThen 4 first bad version.\n\nExample 2:\nInput: n = 1, bad = 1\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= bad <= n <= 231 - 1\n\n' b'Given integer n, return least number perfect square numbers sum n.\nA perfect square integer square integer; words, product integer itself. For example, 1, 4, 9, 16 perfect squares 3 11 not.\n\xc2\xa0\nExample 1:\nInput: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.\n\nExample 2:\nInput: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9.\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 104\n\n' b'Given string num contains digits integer target, return possibilities insert binary operators \'+\', \'-\', and/or \'*\' digits num resultant expression evaluates target value.\nNote operands returned expressions contain leading zeros.\n\xc2\xa0\nExample 1:\nInput: num = "123", target = 6\nOutput: ["1*2*3","1+2+3"]\nExplanation: Both "1*2*3" "1+2+3" evaluate 6.\n\nExample 2:\nInput: num = "232", target = 8\nOutput: ["2*3+2","2+3*2"]\nExplanation: Both "2*3+2" "2+3*2" evaluate 8.\n\nExample 3:\nInput: num = "3456237490", target = 9191\nOutput: []\nExplanation: There expressions created "3456237490" evaluate 9191.\n\n\xc2\xa0\nConstraints:\n\n1 <= num.length <= 10\nnum consists digits.\n-231 <= target <= 231 - 1\n\n' b"Given integer array nums, move 0's end maintaining relative order non-zero elements.\nNote must in-place without making copy array.\n\xc2\xa0\nExample 1:\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\nExample 2:\nInput: nums = [0]\nOutput: [0]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1\n\n\xc2\xa0\nFollow up: Could minimize total number operations done?" b'Design iterator supports peek operation existing iterator addition hasNext next operations.\nImplement PeekingIterator class:\n\nPeekingIterator(Iterator<int> nums) Initializes object given integer iterator iterator.\nint next() Returns next element array moves pointer next element.\nboolean hasNext() Returns true still elements array.\nint peek() Returns next element array without moving pointer.\n\nNote: Each language may different implementation constructor Iterator, support int next() boolean hasNext() functions.\n\xc2\xa0\nExample 1:\nInput\n["PeekingIterator", "next", "peek", "next", "next", "hasNext"]\n[[[1, 2, 3]], [], [], [], [], []]\nOutput\n[null, 1, 2, 2, 3, false]\n\nExplanation\nPeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]\npeekingIterator.next(); // return 1, pointer moves next element [1,2,3].\npeekingIterator.peek(); // return 2, pointer move [1,2,3].\npeekingIterator.next(); // return 2, pointer moves next element [1,2,3]\npeekingIterator.next(); // return 3, pointer moves next element [1,2,3]\npeekingIterator.hasNext(); // return False\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 1000\nAll calls next peek valid.\nAt 1000 calls made next, hasNext, peek.\n\n\xc2\xa0\nFollow up: How would extend design generic work types, integer?' b'Given array integers nums containing\xc2\xa0n + 1 integers integer range [1, n] inclusive.\nThere one repeated number nums, return this\xc2\xa0repeated\xc2\xa0number.\nYou must solve problem without modifying array nums\xc2\xa0and uses constant extra space.\n\xc2\xa0\nExample 1:\nInput: nums = [1,3,4,2,2]\nOutput: 2\n\nExample 2:\nInput: nums = [3,1,3,4,2]\nOutput: 3\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 105\nnums.length == n + 1\n1 <= nums[i] <= n\nAll integers nums appear except precisely one integer appears two times.\n\n\xc2\xa0\nFollow up:\n\nHow prove least one duplicate number must exist nums?\nCan solve problem linear runtime complexity?\n\n' b'According to\xc2\xa0Wikipedia\'s article: "The Game Life, also known simply Life, cellular automaton devised British mathematician John Horton Conway 1970."\nThe board made x n grid cells, cell initial state: live (represented 1) dead (represented 0). Each cell interacts eight neighbors (horizontal, vertical, diagonal) using following four rules (taken Wikipedia article):\n\nAny live cell fewer two live neighbors dies caused under-population.\nAny live cell two three live neighbors lives next generation.\nAny live cell three live neighbors dies, over-population.\nAny dead cell exactly three live neighbors becomes live cell, reproduction.\n\nThe next state created applying rules simultaneously every cell current state, births deaths occur simultaneously. Given current state x n grid board, return next state.\n\xc2\xa0\nExample 1:\n\nInput: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\nOutput: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n\nExample 2:\n\nInput: board = [[1,1],[1,0]]\nOutput: [[1,1],[1,1]]\n\n\xc2\xa0\nConstraints:\n\nm == board.length\nn == board[i].length\n1 <= m, n <= 25\nboard[i][j] 0 1.\n\n\xc2\xa0\nFollow up:\n\nCould solve in-place? Remember board needs updated simultaneously: You cannot update cells first use updated values update cells.\nIn question, represent board using 2D array. In principle, board infinite, would cause problems active area encroaches upon border array (i.e., live cells reach border). How would address problems?\n\n' b'Given pattern string s, find s\xc2\xa0follows pattern.\nHere follow means full match, bijection letter pattern non-empty word s.\n\xc2\xa0\nExample 1:\nInput: pattern = "abba", = "dog cat cat dog"\nOutput: true\n\nExample 2:\nInput: pattern = "abba", = "dog cat cat fish"\nOutput: false\n\nExample 3:\nInput: pattern = "aaaa", = "dog cat cat dog"\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= pattern.length <= 300\npattern contains lower-case English letters.\n1 <= s.length <= 3000\ns contains lowercase English letters spaces \' \'.\ns contain leading trailing spaces.\nAll words separated single space.\n\n' b'You playing following Nim Game friend:\n\nInitially, heap stones table.\nYou friend alternate taking turns, go first.\nOn turn, person whose turn remove 1 3 stones heap.\nThe one removes last stone winner.\n\nGiven n, number stones heap, return true win game assuming friend play optimally, otherwise return false.\n\xc2\xa0\nExample 1:\nInput: n = 4\nOutput: false\nExplanation: These possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes last stone. Your friend wins.\nIn outcomes, friend wins.\n\nExample 2:\nInput: n = 1\nOutput: true\n\nExample 3:\nInput: n = 2\nOutput: true\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 231 - 1\n\n' b'The median middle value ordered integer list. If size list even, middle value median mean two middle values.\n\nFor example, arr = [2,3,4], median 3.\nFor example, arr = [2,3], median (2 + 3) / 2 = 2.5.\n\nImplement MedianFinder class:\n\nMedianFinder() initializes MedianFinder object.\nvoid addNum(int num) adds integer num data stream data structure.\ndouble findMedian() returns median elements far. Answers within 10-5 actual answer accepted.\n\n\xc2\xa0\nExample 1:\nInput\n["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]\n[[], [1], [2], [], [3], []]\nOutput\n[null, null, null, 1.5, null, 2.0]\n\nExplanation\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1); // arr = [1]\nmedianFinder.addNum(2); // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3); // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n\n\xc2\xa0\nConstraints:\n\n-105 <= num <= 105\nThere least one element data structure calling findMedian.\nAt 5 * 104 calls made addNum findMedian.\n\n\xc2\xa0\nFollow up:\n\nIf integer numbers stream range [0, 100], would optimize solution?\nIf 99% integer numbers stream range [0, 100], would optimize solution?\n\n' b'Serialization process converting data structure object sequence bits stored file memory buffer, transmitted across network connection link reconstructed later another computer environment.\nDesign algorithm serialize deserialize binary tree. There restriction serialization/deserialization algorithm work. You need ensure binary tree serialized string string deserialized original tree structure.\nClarification: The input/output format LeetCode serializes binary tree. You necessarily need follow format, please creative come different approaches yourself.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]\n\nExample 2:\nInput: root = []\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 104].\n-1000 <= Node.val <= 1000\n\n' b'You playing Bulls Cows game friend.\nYou write secret number ask friend guess number is. When friend makes guess, provide hint following info:\n\nThe number "bulls", digits guess correct position.\nThe number "cows", digits guess secret number located wrong position. Specifically, non-bull digits guess could rearranged become bulls.\n\nGiven secret number secret friend\'s guess guess, return hint friend\'s guess.\nThe hint formatted "xAyB", x number bulls number cows. Note secret guess may contain duplicate digits.\n\xc2\xa0\nExample 1:\nInput: secret = "1807", guess = "7810"\nOutput: "1A3B"\nExplanation: Bulls connected \'|\' cows underlined:\n"1807"\n |\n"7810"\nExample 2:\nInput: secret = "1123", guess = "0111"\nOutput: "1A1B"\nExplanation: Bulls connected \'|\' cows underlined:\n"1123" "1123"\n | |\n"0111" "0111"\nNote one two unmatched 1s counted cow since non-bull digits rearranged allow one 1 bull.\n\n\xc2\xa0\nConstraints:\n\n1 <= secret.length, guess.length <= 1000\nsecret.length == guess.length\nsecret guess consist digits only.\n\n' b'Given integer array nums, return length longest strictly increasing subsequence.\nA subsequence sequence derived array deleting elements without changing order remaining elements. For example, [3,6,2,7] subsequence array [0,3,1,6,2,2,7].\n\xc2\xa0\nExample 1:\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence [2,3,7,101], therefore length 4.\n\nExample 2:\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\n\nExample 3:\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 2500\n-104 <= nums[i] <= 104\n\n\xc2\xa0\nFollow up:\xc2\xa0Can come algorithm runs in\xc2\xa0O(n log(n)) time complexity?\n' b'Given string contains parentheses letters, remove minimum number invalid parentheses make input string valid.\nReturn possible results. You may return answer order.\n\xc2\xa0\nExample 1:\nInput: = "()())()"\nOutput: ["(())()","()()()"]\n\nExample 2:\nInput: = "(a)())()"\nOutput: ["(a())()","(a)()()"]\n\nExample 3:\nInput: = ")("\nOutput: [""]\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 25\ns consists lowercase English letters parentheses \'(\' \')\'.\nThere 20 parentheses s.\n\n' b'Given integer array nums, handle multiple queries following type:\n\nCalculate sum elements nums indices left right inclusive left <= right.\n\nImplement NumArray class:\n\nNumArray(int[] nums) Initializes object integer array nums.\nint sumRange(int left, int right) Returns sum elements nums indices left right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).\n\n\xc2\xa0\nExample 1:\nInput\n["NumArray", "sumRange", "sumRange", "sumRange"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\nOutput\n[null, 1, -1, -3]\n\nExplanation\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n-105 <= nums[i] <= 105\n0 <= left <= right < nums.length\nAt 104 calls made sumRange.\n\n' b'Given 2D matrix matrix, handle multiple queries following type:\n\nCalculate sum elements matrix inside rectangle defined upper left corner (row1, col1) lower right corner (row2, col2).\n\nImplement NumMatrix class:\n\nNumMatrix(int[][] matrix) Initializes object integer matrix matrix.\nint sumRegion(int row1, int col1, int row2, int col2) Returns sum elements matrix inside rectangle defined upper left corner (row1, col1) lower right corner (row2, col2).\n\n\xc2\xa0\nExample 1:\n\nInput\n["NumMatrix", "sumRegion", "sumRegion", "sumRegion"]\n[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]\nOutput\n[null, 8, 11, 12]\n\nExplanation\nNumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum red rectangle)\nnumMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum green rectangle)\nnumMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum blue rectangle)\n\n\xc2\xa0\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 200\n-105 <= matrix[i][j] <= 105\n-109 <= sum(matrix[i][j]) <= 109\n0 <= row1 <= row2 < m\n0 <= col1 <= col2 < n\nAt 104 calls made sumRegion.\n\n' b'An additive number string whose digits form additive sequence.\nA valid additive sequence contain least three numbers. Except first two numbers, subsequent number sequence must sum preceding two.\nGiven string containing digits, return true additive number false otherwise.\nNote: Numbers additive sequence cannot leading zeros, sequence 1, 2, 03 1, 02, 3 invalid.\n\xc2\xa0\nExample 1:\nInput: "112358"\nOutput: true\nExplanation: \nThe digits form additive sequence: 1, 1, 2, 3, 5, 8. \n1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n\nExample 2:\nInput: "199100199"\nOutput: true\nExplanation: \nThe additive sequence is: 1, 99, 100, 199.\xc2\xa0\n1 + 99 = 100, 99 + 100 = 199\n\n\xc2\xa0\nConstraints:\n\n1 <= num.length <= 35\nnum consists digits.\n\n\xc2\xa0\nFollow up: How would handle overflow large input integers?\n' b'Given integer array nums, handle multiple queries following types:\n\nUpdate value element nums.\nCalculate sum elements nums indices left right inclusive left <= right.\n\nImplement NumArray class:\n\nNumArray(int[] nums) Initializes object integer array nums.\nvoid update(int index, int val) Updates value nums[index] val.\nint sumRange(int left, int right) Returns sum elements nums indices left right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).\n\n\xc2\xa0\nExample 1:\nInput\n["NumArray", "sumRange", "update", "sumRange"]\n[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]\nOutput\n[null, 9, null, 8]\n\nExplanation\nNumArray numArray = new NumArray([1, 3, 5]);\nnumArray.sumRange(0, 2); // return 1 + 3 + 5 = 9\nnumArray.update(1, 2); // nums = [1, 2, 5]\nnumArray.sumRange(0, 2); // return 1 + 2 + 5 = 8\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 3 * 104\n-100 <= nums[i] <= 100\n0 <= index < nums.length\n-100 <= val <= 100\n0 <= left <= right < nums.length\nAt 3 * 104 calls made update sumRange.\n\n' b'You given array prices prices[i] price given stock ith day.\nFind maximum profit achieve. You may complete many transactions like (i.e., buy one sell one share stock multiple times) following restrictions:\n\nAfter sell stock, cannot buy stock next day (i.e., cooldown one day).\n\nNote: You may engage multiple transactions simultaneously (i.e., must sell stock buy again).\n\xc2\xa0\nExample 1:\nInput: prices = [1,2,3,0,2]\nOutput: 3\nExplanation: transactions = [buy, sell, cooldown, buy, sell]\n\nExample 2:\nInput: prices = [1]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <= prices.length <= 5000\n0 <= prices[i] <= 1000\n\n' b"A tree undirected graph two vertices connected by\xc2\xa0exactly\xc2\xa0one path. In words, connected graph without simple cycles tree.\nGiven tree n nodes\xc2\xa0labelled 0 n - 1, array of\xc2\xa0n - 1\xc2\xa0edges edges[i] = [ai, bi] indicates undirected edge two nodes\xc2\xa0ai and\xc2\xa0bi tree,\xc2\xa0you choose node tree root. When select node x root, result tree height h. Among possible rooted trees, minimum height (i.e. min(h))\xc2\xa0 called minimum height trees (MHTs).\nReturn list MHTs' root labels.\xc2\xa0You return answer order.\nThe height rooted tree number edges longest downward path root leaf.\n\xc2\xa0\nExample 1:\n\nInput: n = 4, edges = [[1,0],[1,2],[1,3]]\nOutput: [1]\nExplanation: As shown, height tree 1 root node label 1 MHT.\n\nExample 2:\n\nInput: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\nOutput: [3,4]\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 2 * 104\nedges.length == n - 1\n0 <= ai, bi < n\nai != bi\nAll pairs (ai, bi) distinct.\nThe given input guaranteed tree repeated edges.\n\n" b'You given n balloons, indexed 0 n - 1. Each balloon painted number represented array nums. You asked burst balloons.\nIf burst ith balloon, get nums[i - 1] * nums[i] * nums[i + 1] coins. If - 1 + 1 goes bounds array, treat balloon 1 painted it.\nReturn maximum coins collect bursting balloons wisely.\n\xc2\xa0\nExample 1:\nInput: nums = [3,1,5,8]\nOutput: 167\nExplanation:\nnums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\ncoins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167\nExample 2:\nInput: nums = [1,5]\nOutput: 10\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= n <= 300\n0 <= nums[i] <= 100\n\n' b'A super ugly number positive integer whose prime factors array primes.\nGiven integer n array integers primes, return nth super ugly number.\nThe nth super ugly number guaranteed fit 32-bit signed integer.\n\xc2\xa0\nExample 1:\nInput: n = 12, primes = [2,7,13,19]\nOutput: 32\nExplanation: [1,2,4,7,8,13,14,16,19,26,28,32] sequence first 12 super ugly numbers given primes = [2,7,13,19].\n\nExample 2:\nInput: n = 1, primes = [2,3,5]\nOutput: 1\nExplanation: 1 prime factors, therefore prime factors array primes = [2,3,5].\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 105\n1 <= primes.length <= 100\n2 <= primes[i] <= 1000\nprimes[i] guaranteed prime number.\nAll values primes unique sorted ascending order.\n\n' b'You given integer array nums return new counts array. The counts array property counts[i] number smaller elements right nums[i].\n\xc2\xa0\nExample 1:\nInput: nums = [5,2,6,1]\nOutput: [2,1,1,0]\nExplanation:\nTo right 5 2 smaller elements (2 1).\nTo right 2 1 smaller element (1).\nTo right 6 1 smaller element (1).\nTo right 1 0 smaller element.\n\nExample 2:\nInput: nums = [-1]\nOutput: [0]\n\nExample 3:\nInput: nums = [-1,-1]\nOutput: [0,0]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n\n' b'Given string s, remove duplicate letters every letter appears once. You must make sure result smallest lexicographical order among possible results.\n\xc2\xa0\nExample 1:\nInput: = "bcabc"\nOutput: "abc"\n\nExample 2:\nInput: = "cbacdcbc"\nOutput: "acdb"\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 104\ns consists lowercase English letters.\n\n\xc2\xa0\nNote: This question 1081: https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/\n' b'Given string array words, return maximum value length(word[i]) * length(word[j]) two words share common letters. If two words exist, return 0.\n\xc2\xa0\nExample 1:\nInput: words = ["abcw","baz","foo","bar","xtfn","abcdef"]\nOutput: 16\nExplanation: The two words "abcw", "xtfn".\n\nExample 2:\nInput: words = ["a","ab","abc","d","cd","bcd","abcd"]\nOutput: 4\nExplanation: The two words "ab", "cd".\n\nExample 3:\nInput: words = ["a","aa","aaa","aaaa"]\nOutput: 0\nExplanation: No pair words.\n\n\xc2\xa0\nConstraints:\n\n2 <= words.length <= 1000\n1 <= words[i].length <= 1000\nwords[i] consists lowercase English letters.\n\n' b"There n bulbs initially off. You first turn bulbs, then\xc2\xa0you turn every second bulb.\nOn third round, toggle every third bulb (turning turning on). For ith round, toggle every bulb. For nth round, toggle last bulb.\nReturn number bulbs n rounds.\n\xc2\xa0\nExample 1:\n\nInput: n = 3\nOutput: 1\nExplanation: At first, three bulbs [off, off, off].\nAfter first round, three bulbs [on, on, on].\nAfter second round, three bulbs [on, off, on].\nAfter third round, three bulbs [on, off, off]. \nSo return 1 one bulb on.\nExample 2:\nInput: n = 0\nOutput: 0\n\nExample 3:\nInput: n = 1\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n0 <= n <= 109\n\n" b'You given two integer arrays nums1 nums2 lengths n respectively. nums1 nums2 represent digits two numbers. You also given integer k.\nCreate maximum number length k <= + n digits two numbers. The relative order digits array must preserved.\nReturn array k digits representing answer.\n\xc2\xa0\nExample 1:\nInput: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\nOutput: [9,8,6,5,3]\n\nExample 2:\nInput: nums1 = [6,7], nums2 = [6,0,4], k = 5\nOutput: [6,7,6,0,4]\n\nExample 3:\nInput: nums1 = [3,9], nums2 = [8,9], k = 3\nOutput: [9,8,9]\n\n\xc2\xa0\nConstraints:\n\nm == nums1.length\nn == nums2.length\n1 <= m, n <= 500\n0 <= nums1[i], nums2[i] <= 9\n1 <= k <= + n\n\n' b'You given integer array coins representing coins different denominations integer amount representing total amount money.\nReturn fewest number coins need make amount. If amount money cannot made combination coins, return -1.\nYou may assume infinite number kind coin.\n\xc2\xa0\nExample 1:\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\n\nExample 2:\nInput: coins = [2], amount = 3\nOutput: -1\n\nExample 3:\nInput: coins = [1], amount = 0\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <= coins.length <= 12\n1 <= coins[i] <= 231 - 1\n0 <= amount <= 104\n\n' b'Given integer array nums, reorder nums[0] < nums[1] > nums[2] < nums[3]....\nYou may assume input array always valid answer.\n\xc2\xa0\nExample 1:\nInput: nums = [1,5,1,1,6,4]\nOutput: [1,6,1,5,1,4]\nExplanation: [1,4,1,5,1,6] also accepted.\n\nExample 2:\nInput: nums = [1,3,2,2,3,1]\nOutput: [2,3,1,3,1,2]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 5 * 104\n0 <= nums[i] <= 5000\nIt guaranteed answer given input nums.\n\n\xc2\xa0\nFollow Up: Can O(n) time and/or in-place O(1) extra space?' b'Given integer n, return true power three. Otherwise, return false.\nAn integer n power three, exists integer x n == 3x.\n\xc2\xa0\nExample 1:\nInput: n = 27\nOutput: true\n\nExample 2:\nInput: n = 0\nOutput: false\n\nExample 3:\nInput: n = 9\nOutput: true\n\n\xc2\xa0\nConstraints:\n\n-231 <= n <= 231 - 1\n\n\xc2\xa0\nFollow up: Could solve without loops/recursion?' b'Given integer array nums two integers lower upper, return number range sums lie [lower, upper] inclusive.\nRange sum S(i, j) defined sum elements nums indices j inclusive, <= j.\n\xc2\xa0\nExample 1:\nInput: nums = [-2,5,-1], lower = -2, upper = 2\nOutput: 3\nExplanation: The three ranges are: [0,0], [2,2], [0,2] respective sums are: -2, -1, 2.\n\nExample 2:\nInput: nums = [0], lower = 0, upper = 0\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n-105 <= lower <= upper <= 105\nThe answer guaranteed fit 32-bit integer.\n\n' b'Given head singly linked list, group nodes odd indices together followed nodes even indices, return reordered list.\nThe first node considered odd, second node even, on.\nNote relative order inside even odd groups remain input.\nYou must solve problem\xc2\xa0in O(1)\xc2\xa0extra space complexity O(n) time complexity.\n\xc2\xa0\nExample 1:\n\nInput: head = [1,2,3,4,5]\nOutput: [1,3,5,2,4]\n\nExample 2:\n\nInput: head = [2,1,3,5,6,4,7]\nOutput: [2,3,6,7,1,5,4]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes linked list range [0, 104].\n-106 <= Node.val <= 106\n\n' b'Given x n integers matrix, return length longest increasing path matrix.\nFrom cell, either move four directions: left, right, up, down. You may move diagonally move outside boundary (i.e., wrap-around allowed).\n\xc2\xa0\nExample 1:\n\nInput: matrix = [[9,9,4],[6,6,8],[2,1,1]]\nOutput: 4\nExplanation: The longest increasing path [1, 2, 6, 9].\n\nExample 2:\n\nInput: matrix = [[3,4,5],[3,2,6],[2,2,1]]\nOutput: 4\nExplanation: The longest increasing path [3, 4, 5, 6]. Moving diagonally allowed.\n\nExample 3:\nInput: matrix = [[1]]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 200\n0 <= matrix[i][j] <= 231 - 1\n\n' b'Given sorted integer array nums integer n, add/patch elements array number range [1, n] inclusive formed sum elements array.\nReturn minimum number patches required.\n\xc2\xa0\nExample 1:\nInput: nums = [1,3], n = 6\nOutput: 1\nExplanation:\nCombinations nums [1], [3], [1,3], form possible sums of: 1, 3, 4.\nNow add/patch 2 nums, combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\nPossible sums 1, 2, 3, 4, 5, 6, covers range [1, 6].\nSo need 1 patch.\n\nExample 2:\nInput: nums = [1,5,10], n = 20\nOutput: 2\nExplanation: The two patches [2, 4].\n\nExample 3:\nInput: nums = [1,2,2], n = 5\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 104\nnums sorted ascending order.\n1 <= n <= 231 - 1\n\n' b'One way serialize binary tree use preorder traversal. When encounter non-null node, record node\'s value. If null node, record using sentinel value \'#\'.\n\nFor example, binary tree serialized string "9,3,4,#,#,1,#,#,2,#,6,#,#", \'#\' represents null node.\nGiven string comma-separated values preorder, return true correct preorder traversal serialization binary tree.\nIt guaranteed comma-separated value string must either integer character \'#\' representing null pointer.\nYou may assume input format always valid.\n\nFor example, could never contain two consecutive commas, "1,,3".\n\nNote:\xc2\xa0You allowed reconstruct tree.\n\xc2\xa0\nExample 1:\nInput: preorder = "9,3,4,#,#,1,#,#,2,#,6,#,#"\nOutput: true\nExample 2:\nInput: preorder = "1,#"\nOutput: false\nExample 3:\nInput: preorder = "9,#,#,1"\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= preorder.length <= 104\npreorder consist integers range [0, 100] \'#\' separated commas \',\'.\n\n' b'You given list airline tickets tickets[i] = [fromi, toi] represent departure arrival airports one flight. Reconstruct itinerary order return it.\nAll tickets belong man departs "JFK", thus, itinerary must begin "JFK". If multiple valid itineraries, return itinerary smallest lexical order read single string.\n\nFor example, itinerary ["JFK", "LGA"] smaller lexical order ["JFK", "LGB"].\n\nYou may assume tickets form least one valid itinerary. You must use tickets once.\n\xc2\xa0\nExample 1:\n\nInput: tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]\nOutput: ["JFK","MUC","LHR","SFO","SJC"]\n\nExample 2:\n\nInput: tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]\nOutput: ["JFK","ATL","JFK","SFO","ATL","SFO"]\nExplanation: Another possible reconstruction ["JFK","SFO","ATL","JFK","ATL","SFO"] larger lexical order.\n\n\xc2\xa0\nConstraints:\n\n1 <= tickets.length <= 300\ntickets[i].length == 2\nfromi.length == 3\ntoi.length == 3\nfromi toi consist uppercase English letters.\nfromi != toi\n\n' b'Given integer array nums, return true exists triple indices (i, j, k) < j < k nums[i] < nums[j] < nums[k]. If indices exists, return false.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3,4,5]\nOutput: true\nExplanation: Any triplet < j < k valid.\n\nExample 2:\nInput: nums = [5,4,3,2,1]\nOutput: false\nExplanation: No triplet exists.\n\nExample 3:\nInput: nums = [2,1,5,0,4,6]\nOutput: true\nExplanation: The triplet (3, 4, 5) valid nums[3] == 0 < nums[4] == 4 < nums[5] == 6.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 5 * 105\n-231 <= nums[i] <= 231 - 1\n\n\xc2\xa0\nFollow up: Could implement solution runs O(n) time complexity O(1) space complexity?' b'You given array integers distance.\nYou start point (0,0) X-Y plane move distance[0] meters north, distance[1] meters west, distance[2] meters south, distance[3] meters east, on. In words, move, direction changes counter-clockwise.\nReturn true path crosses itself, false not.\n\xc2\xa0\nExample 1:\n\nInput: distance = [2,1,1,2]\nOutput: true\n\nExample 2:\n\nInput: distance = [1,2,3,4]\nOutput: false\n\nExample 3:\n\nInput: distance = [1,1,1,1]\nOutput: true\n\n\xc2\xa0\nConstraints:\n\n1 <=\xc2\xa0distance.length <= 105\n1 <=\xc2\xa0distance[i] <= 105\n\n' b'Given list unique words, return pairs the\xc2\xa0distinct indices (i, j) given list, concatenation two words\xc2\xa0words[i] + words[j] palindrome.\n\xc2\xa0\nExample 1:\nInput: words = ["abcd","dcba","lls","s","sssll"]\nOutput: [[0,1],[1,0],[3,2],[2,4]]\nExplanation: The palindromes ["dcbaabcd","abcddcba","slls","llssssll"]\n\nExample 2:\nInput: words = ["bat","tab","cat"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes ["battab","tabbat"]\n\nExample 3:\nInput: words = ["a",""]\nOutput: [[0,1],[1,0]]\n\n\xc2\xa0\nConstraints:\n\n1 <= words.length <= 5000\n0 <= words[i].length <= 300\nwords[i] consists lower-case English letters.\n\n' b'The thief found new place thievery again. There one entrance area, called root.\nBesides root, house one one parent house. After tour, smart thief realized houses place form binary tree. It automatically contact police two directly-linked houses broken night.\nGiven root binary tree, return maximum amount money thief rob without alerting police.\n\xc2\xa0\nExample 1:\n\nInput: root = [3,2,3,null,3,null,1]\nOutput: 7\nExplanation: Maximum amount money thief rob = 3 + 3 + 1 = 7.\n\nExample 2:\n\nInput: root = [3,4,5,1,3,null,1]\nOutput: 9\nExplanation: Maximum amount money thief rob = 4 + 5 = 9.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 104].\n0 <= Node.val <= 104\n\n' b"Given integer n, return array ans length n + 1 (0 <= <= n), ans[i] number 1's binary representation i.\n\xc2\xa0\nExample 1:\nInput: n = 2\nOutput: [0,1,1]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\n\nExample 2:\nInput: n = 5\nOutput: [0,1,1,2,1,2]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\n\n\xc2\xa0\nConstraints:\n\n0 <= n <= 105\n\n\xc2\xa0\nFollow up:\n\nIt easy come solution runtime O(n log n). Can linear time O(n) possibly single pass?\nCan without using built-in function (i.e., like __builtin_popcount C++)?\n\n" b'You given nested list integers nestedList. Each element either integer list whose elements may also integers lists. Implement iterator flatten it.\nImplement NestedIterator class:\n\nNestedIterator(List<NestedInteger> nestedList) Initializes iterator nested list nestedList.\nint next() Returns next integer nested list.\nboolean hasNext() Returns true still integers nested list false otherwise.\n\nYour code tested following pseudocode:\ninitialize iterator nestedList\nres = []\nwhile iterator.hasNext()\n append iterator.next() end res\nreturn res\n\nIf res matches expected flattened list, code judged correct.\n\xc2\xa0\nExample 1:\nInput: nestedList = [[1,1],2,[1,1]]\nOutput: [1,1,2,1,1]\nExplanation: By calling next repeatedly hasNext returns false, order elements returned next be: [1,1,2,1,1].\n\nExample 2:\nInput: nestedList = [1,[4,[6]]]\nOutput: [1,4,6]\nExplanation: By calling next repeatedly hasNext returns false, order elements returned next be: [1,4,6].\n\n\xc2\xa0\nConstraints:\n\n1 <= nestedList.length <= 500\nThe values integers nested list range [-106, 106].\n\n' b'Given integer n, return true power four. Otherwise, return false.\nAn integer n power four, exists integer x n == 4x.\n\xc2\xa0\nExample 1:\nInput: n = 16\nOutput: true\nExample 2:\nInput: n = 5\nOutput: false\nExample 3:\nInput: n = 1\nOutput: true\n\n\xc2\xa0\nConstraints:\n\n-231 <= n <= 231 - 1\n\n\xc2\xa0\nFollow up: Could solve without loops/recursion?' b'Given integer n, break sum k positive integers, k >= 2, maximize product integers.\nReturn maximum product get.\n\xc2\xa0\nExample 1:\nInput: n = 2\nOutput: 1\nExplanation: 2 = 1 + 1, 1 \xc3\x97 1 = 1.\n\nExample 2:\nInput: n = 10\nOutput: 36\nExplanation: 10 = 3 + 3 + 4, 3 \xc3\x97 3 \xc3\x97 4 = 36.\n\n\xc2\xa0\nConstraints:\n\n2 <= n <= 58\n\n' b'Write function reverses string. The input string given array characters s.\nYou must modifying input array in-place O(1) extra memory.\n\xc2\xa0\nExample 1:\nInput: = ["h","e","l","l","o"]\nOutput: ["o","l","l","e","h"]\nExample 2:\nInput: = ["H","a","n","n","a","h"]\nOutput: ["h","a","n","n","a","H"]\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 105\ns[i] printable ascii character.\n\n' b'Given string s, reverse vowels string return it.\nThe vowels \'a\', \'e\', \'i\', \'o\', \'u\', appear cases.\n\xc2\xa0\nExample 1:\nInput: = "hello"\nOutput: "holle"\nExample 2:\nInput: = "leetcode"\nOutput: "leotcede"\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 3 * 105\ns consist printable ASCII characters.\n\n' b"Given integer array nums integer k, return k frequent elements. You may return answer order.\n\xc2\xa0\nExample 1:\nInput: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\nExample 2:\nInput: nums = [1], k = 1\nOutput: [1]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\nk range [1, number unique elements array].\nIt guaranteed answer unique.\n\n\xc2\xa0\nFollow up: Your algorithm's time complexity must better O(n log n), n array's size.\n" b'Given two integer arrays nums1 nums2, return array intersection. Each element result must unique may return result order.\n\xc2\xa0\nExample 1:\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2]\n\nExample 2:\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [9,4]\nExplanation: [4,9] also accepted.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums1.length, nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 1000\n\n' b"Given two integer arrays nums1 nums2, return array intersection. Each element result must appear many times shows arrays may return result order.\n\xc2\xa0\nExample 1:\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2,2]\n\nExample 2:\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [4,9]\nExplanation: [9,4] also accepted.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums1.length, nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 1000\n\n\xc2\xa0\nFollow up:\n\nWhat given array already sorted? How would optimize algorithm?\nWhat nums1's size small compared nums2's size? Which algorithm better?\nWhat elements nums2 stored disk, memory limited cannot load elements memory once?\n\n" b'Given data stream input non-negative integers a1, a2, ..., an, summarize numbers seen far list disjoint intervals.\nImplement SummaryRanges class:\n\nSummaryRanges() Initializes object empty stream.\nvoid addNum(int val) Adds integer val stream.\nint[][] getIntervals() Returns summary integers stream currently list disjoint intervals [starti, endi].\n\n\xc2\xa0\nExample 1:\nInput\n["SummaryRanges", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]\nOutput\n[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]\n\nExplanation\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1); // arr = [1]\nsummaryRanges.getIntervals(); // return [[1, 1]]\nsummaryRanges.addNum(3); // arr = [1, 3]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3]]\nsummaryRanges.addNum(7); // arr = [1, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]\nsummaryRanges.addNum(2); // arr = [1, 2, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [7, 7]]\nsummaryRanges.addNum(6); // arr = [1, 2, 3, 6, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [6, 7]]\n\n\xc2\xa0\nConstraints:\n\n0 <= val <= 104\nAt 3 * 104 calls made addNum getIntervals.\n\n\xc2\xa0\nFollow up: What lots merges number disjoint intervals small compared size data stream?\n' b"You given 2D array integers envelopes envelopes[i] = [wi, hi] represents width height envelope.\nOne envelope fit another width height one envelope greater envelope's width height.\nReturn maximum number envelopes Russian doll (i.e., put one inside other).\nNote: You cannot rotate envelope.\n\xc2\xa0\nExample 1:\nInput: envelopes = [[5,4],[6,4],[6,7],[2,3]]\nOutput: 3\nExplanation: The maximum number envelopes Russian doll 3 ([2,3] => [5,4] => [6,7]).\n\nExample 2:\nInput: envelopes = [[1,1],[1,1],[1,1]]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= envelopes.length <= 105\nenvelopes[i].length == 2\n1 <= wi, hi <= 105\n\n" b'Design simplified version Twitter users post tweets, follow/unfollow another user, able see 10 recent tweets user\'s news feed.\nImplement Twitter class:\n\nTwitter() Initializes twitter object.\nvoid postTweet(int userId, int tweetId) Composes new tweet ID tweetId user userId. Each call function made unique tweetId.\nList<Integer> getNewsFeed(int userId) Retrieves 10 recent tweet IDs user\'s news feed. Each item news feed must posted users user followed user themself. Tweets must ordered recent least recent.\nvoid follow(int followerId, int followeeId) The user ID followerId started following user ID followeeId.\nvoid unfollow(int followerId, int followeeId) The user ID followerId started unfollowing user ID followeeId.\n\n\xc2\xa0\nExample 1:\nInput\n["Twitter", "postTweet", "getNewsFeed", "follow", "postTweet", "getNewsFeed", "unfollow", "getNewsFeed"]\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\nOutput\n[null, null, [5], null, null, [6, 5], null, [5]]\n\nExplanation\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // User 1 posts new tweet (id = 5).\ntwitter.getNewsFeed(1); // User 1\'s news feed return list 1 tweet id -> [5]. return [5]\ntwitter.follow(1, 2); // User 1 follows user 2.\ntwitter.postTweet(2, 6); // User 2 posts new tweet (id = 6).\ntwitter.getNewsFeed(1); // User 1\'s news feed return list 2 tweet ids -> [6, 5]. Tweet id 6 precede tweet id 5 posted tweet id 5.\ntwitter.unfollow(1, 2); // User 1 unfollows user 2.\ntwitter.getNewsFeed(1); // User 1\'s news feed return list 1 tweet id -> [5], since user 1 longer following user 2.\n\n\xc2\xa0\nConstraints:\n\n1 <= userId, followerId, followeeId <= 500\n0 <= tweetId <= 104\nAll tweets unique IDs.\nAt 3 * 104 calls made postTweet, getNewsFeed, follow, unfollow.\n\n' b'Given integer n, return count numbers unique digits, x, 0 <= x < 10n.\n\xc2\xa0\nExample 1:\nInput: n = 2\nOutput: 91\nExplanation: The answer total numbers range 0 \xe2\x89\xa4 x < 100, excluding 11,22,33,44,55,66,77,88,99\n\nExample 2:\nInput: n = 0\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n0 <= n <= 8\n\n' b'Given x n matrix matrix integer k, return max sum rectangle matrix sum larger k.\nIt guaranteed rectangle sum larger k.\n\xc2\xa0\nExample 1:\n\nInput: matrix = [[1,0,1],[0,-2,3]], k = 2\nOutput: 2\nExplanation: Because sum blue rectangle [[0, 1], [-2, 3]] 2, 2 max number larger k (k = 2).\n\nExample 2:\nInput: matrix = [[2,2,-1]], k = 3\nOutput: 3\n\n\xc2\xa0\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 100\n-100 <= matrix[i][j] <= 100\n-105 <= k <= 105\n\n\xc2\xa0\nFollow up: What number rows much larger number columns?\n' b'You given two jugs capacities jug1Capacity jug2Capacity liters. There infinite amount water supply available. Determine whether possible measure exactly targetCapacity liters using two jugs.\nIf targetCapacity liters water measurable, must targetCapacity liters water contained within one buckets end.\nOperations allowed:\n\nFill jugs water.\nEmpty jugs.\nPour water one jug another till jug completely full, first jug empty.\n\n\xc2\xa0\nExample 1:\nInput: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4\nOutput: true\nExplanation: The famous Die Hard example \n\nExample 2:\nInput: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5\nOutput: false\n\nExample 3:\nInput: jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3\nOutput: true\n\n\xc2\xa0\nConstraints:\n\n1 <= jug1Capacity, jug2Capacity, targetCapacity <= 106\n\n' b'Given positive integer num, write function returns True num perfect square else False.\nFollow up: Do use built-in library function sqrt.\n\xc2\xa0\nExample 1:\nInput: num = 16\nOutput: true\nExample 2:\nInput: num = 14\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= num <= 2^31 - 1\n\n' b'Given set distinct positive integers nums, return largest subset answer every pair (answer[i], answer[j]) elements subset satisfies:\n\nanswer[i] % answer[j] == 0, or\nanswer[j] % answer[i] == 0\n\nIf multiple solutions, return them.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3]\nOutput: [1,2]\nExplanation: [1,3] also accepted.\n\nExample 2:\nInput: nums = [1,2,4,8]\nOutput: [1,2,4,8]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 2 * 109\nAll integers nums unique.\n\n' b'Given two integers b, return sum two integers without using operators + -.\n\xc2\xa0\nExample 1:\nInput: = 1, b = 2\nOutput: 3\nExample 2:\nInput: = 2, b = 3\nOutput: 5\n\n\xc2\xa0\nConstraints:\n\n-1000 <= a, b <= 1000\n\n' b'Your task calculate ab mod 1337 positive integer b extremely large positive integer given form array.\n\xc2\xa0\nExample 1:\nInput: = 2, b = [3]\nOutput: 8\n\nExample 2:\nInput: = 2, b = [1,0]\nOutput: 1024\n\nExample 3:\nInput: = 1, b = [4,3,3,8,5,2]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= <= 231 - 1\n1 <= b.length <= 2000\n0 <= b[i] <= 9\nb contain leading zeros.\n\n' b'You given two integer arrays nums1 nums2 sorted ascending order integer k.\nDefine pair (u, v) consists one element first array one element second array.\nReturn k pairs (u1, v1), (u2, v2), ..., (uk, vk) smallest sums.\n\xc2\xa0\nExample 1:\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]]\nExplanation: The first 3 pairs returned sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n\nExample 2:\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [[1,1],[1,1]]\nExplanation: The first 2 pairs returned sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n\nExample 3:\nInput: nums1 = [1,2], nums2 = [3], k = 3\nOutput: [[1,3],[2,3]]\nExplanation: All possible pairs returned sequence: [1,3],[2,3]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums1.length, nums2.length <= 105\n-109 <= nums1[i], nums2[i] <= 109\nnums1 nums2 sorted ascending order.\n1 <= k <= 104\n\n' b'We playing Guess Game. The game follows:\nI pick number 1 n. You guess number I picked.\nEvery time guess wrong, I tell whether number I picked higher lower guess.\nYou call pre-defined API int guess(int num), returns three possible results:\n\n-1: Your guess higher number I picked (i.e. num > pick).\n1: Your guess lower number I picked (i.e. num < pick).\n0: guess equal number I picked (i.e. num == pick).\n\nReturn number I picked.\n\xc2\xa0\nExample 1:\nInput: n = 10, pick = 6\nOutput: 6\n\nExample 2:\nInput: n = 1, pick = 1\nOutput: 1\n\nExample 3:\nInput: n = 2, pick = 1\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 231 - 1\n1 <= pick <= n\n\n' b'We playing Guessing Game. The game work follows:\n\nI pick number between\xc2\xa01\xc2\xa0and\xc2\xa0n.\nYou guess number.\nIf guess right number, win game.\nIf guess wrong number, I tell whether number I picked higher lower, continue guessing.\nEvery time guess wrong number\xc2\xa0x, pay\xc2\xa0x\xc2\xa0dollars. If run money, lose game.\n\nGiven particular\xc2\xa0n, return\xc2\xa0the minimum amount money need to\xc2\xa0guarantee win regardless number I pick.\n\xc2\xa0\nExample 1:\n\nInput: n = 10\nOutput: 16\nExplanation: The winning strategy follows:\n- The range [1,10]. Guess 7.\n\xc2\xa0 - If number, total $0. Otherwise, pay $7.\n\xc2\xa0 - If number higher, range [8,10]. Guess 9.\n\xc2\xa0 - If number, total $7. Otherwise, pay $9.\n\xc2\xa0 - If number higher, must 10. Guess 10. Your total $7 + $9 = $16.\n\xc2\xa0 - If number lower, must 8. Guess 8. Your total $7 + $9 = $16.\n\xc2\xa0 - If number lower, range [1,6]. Guess 3.\n\xc2\xa0 - If number, total $7. Otherwise, pay $3.\n\xc2\xa0 - If number higher, range [4,6]. Guess 5.\n\xc2\xa0 - If number, total $7 + $3 = $10. Otherwise, pay $5.\n\xc2\xa0 - If number higher, must 6. Guess 6. Your total $7 + $3 + $5 = $15.\n\xc2\xa0 - If number lower, must 4. Guess 4. Your total $7 + $3 + $5 = $15.\n\xc2\xa0 - If number lower, range [1,2]. Guess 1.\n\xc2\xa0 - If number, total $7 + $3 = $10. Otherwise, pay $1.\n\xc2\xa0 - If number higher, must 2. Guess 2. Your total $7 + $3 + $1 = $11.\nThe worst case scenarios pay $16. Hence, need $16 guarantee win.\n\nExample 2:\nInput: n = 1\nOutput: 0\nExplanation:\xc2\xa0There one possible number, guess 1 pay anything.\n\nExample 3:\nInput: n = 2\nOutput: 1\nExplanation:\xc2\xa0There two possible numbers, 1 2.\n- Guess 1.\n\xc2\xa0 - If number, total $0. Otherwise, pay $1.\n\xc2\xa0 - If number higher, must 2. Guess 2. Your total $1.\nThe worst case pay $1.\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 200\n\n' b'A wiggle sequence sequence differences successive numbers strictly alternate positive negative. The first difference (if one exists) may either positive negative. A sequence one element sequence two non-equal elements trivially wiggle sequences.\n\nFor example, [1, 7, 4, 9, 2, 5] wiggle sequence differences (6, -3, 5, -7, 3) alternate positive negative.\nIn contrast, [1, 4, 7, 2, 5] [1, 7, 4, 5, 5] wiggle sequences. The first first two differences positive, second last difference zero.\n\nA subsequence obtained deleting elements (possibly zero) original sequence, leaving remaining elements original order.\nGiven integer array nums, return length longest wiggle subsequence nums.\n\xc2\xa0\nExample 1:\nInput: nums = [1,7,4,9,2,5]\nOutput: 6\nExplanation: The entire sequence wiggle sequence differences (6, -3, 5, -7, 3).\n\nExample 2:\nInput: nums = [1,17,5,10,13,15,10,5,16,8]\nOutput: 7\nExplanation: There several subsequences achieve length.\nOne [1, 17, 10, 13, 10, 16, 8] differences (16, -7, 3, -3, 6, -8).\n\nExample 3:\nInput: nums = [1,2,3,4,5,6,7,8,9]\nOutput: 2\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 1000\n0 <= nums[i] <= 1000\n\n\xc2\xa0\nFollow up: Could solve O(n) time?\n' b'Given array distinct integers nums target integer target, return number possible combinations add to\xc2\xa0target.\nThe test cases generated answer fit 32-bit integer.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3], target = 4\nOutput: 7\nExplanation:\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote different sequences counted different combinations.\n\nExample 2:\nInput: nums = [9], target = 3\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 200\n1 <= nums[i] <= 1000\nAll elements nums unique.\n1 <= target <= 1000\n\n\xc2\xa0\nFollow up: What negative numbers allowed given array? How change problem? What limitation need add question allow negative numbers?\n' b'Given n x n matrix rows columns sorted ascending order, return kth smallest element matrix.\nNote kth smallest element sorted order, kth distinct element.\nYou must find solution memory complexity better O(n2).\n\xc2\xa0\nExample 1:\nInput: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\nOutput: 13\nExplanation: The elements matrix [1,5,9,10,11,12,13,13,15], 8th smallest number 13\n\nExample 2:\nInput: matrix = [[-5]], k = 1\nOutput: -5\n\n\xc2\xa0\nConstraints:\n\nn == matrix.length == matrix[i].length\n1 <= n <= 300\n-109 <= matrix[i][j] <= 109\nAll rows columns matrix guaranteed sorted non-decreasing order.\n1 <= k <= n2\n\n\xc2\xa0\nFollow up:\n\nCould solve problem constant memory (i.e., O(1) memory complexity)?\nCould solve problem O(n) time complexity? The solution may advanced interview may find reading paper fun.\n\n' b'Implement RandomizedSet class:\n\nRandomizedSet() Initializes RandomizedSet object.\nbool insert(int val) Inserts item val set present. Returns true item present, false otherwise.\nbool remove(int val) Removes item val set present. Returns true item present, false otherwise.\nint getRandom() Returns random element current set elements (it\'s guaranteed least one element exists method called). Each element must probability returned.\n\nYou must implement functions class function works in\xc2\xa0average\xc2\xa0O(1)\xc2\xa0time complexity.\n\xc2\xa0\nExample 1:\nInput\n["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]\n[[], [1], [2], [2], [], [1], [2], []]\nOutput\n[null, true, false, true, 2, true, false, 2]\n\nExplanation\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 set. Returns true 1 inserted successfully.\nrandomizedSet.remove(2); // Returns false 2 exist set.\nrandomizedSet.insert(2); // Inserts 2 set, returns true. Set contains [1,2].\nrandomizedSet.getRandom(); // getRandom() return either 1 2 randomly.\nrandomizedSet.remove(1); // Removes 1 set, returns true. Set contains [2].\nrandomizedSet.insert(2); // 2 already set, return false.\nrandomizedSet.getRandom(); // Since 2 number set, getRandom() always return 2.\n\n\xc2\xa0\nConstraints:\n\n-231 <= val <= 231 - 1\nAt 2 *\xc2\xa0105 calls made insert, remove, getRandom.\nThere least one element data structure getRandom called.\n\n' b'RandomizedCollection data structure contains collection numbers, possibly duplicates (i.e., multiset). It support inserting removing specific elements also removing random element.\nImplement RandomizedCollection class:\n\nRandomizedCollection() Initializes empty RandomizedCollection object.\nbool insert(int val) Inserts item val multiset, even item already present. Returns true item present, false otherwise.\nbool remove(int val) Removes item val multiset present. Returns true item present, false otherwise. Note val multiple occurrences multiset, remove one them.\nint getRandom() Returns random element current multiset elements. The probability element returned linearly related number values multiset contains.\n\nYou must implement functions class function works average O(1) time complexity.\nNote: The test cases generated getRandom called least one item RandomizedCollection.\n\xc2\xa0\nExample 1:\nInput\n["RandomizedCollection", "insert", "insert", "insert", "getRandom", "remove", "getRandom"]\n[[], [1], [1], [2], [], [1], []]\nOutput\n[null, true, false, true, 2, true, 1]\n\nExplanation\nRandomizedCollection randomizedCollection = new RandomizedCollection();\nrandomizedCollection.insert(1); // return true since collection contain 1.\n // Inserts 1 collection.\nrandomizedCollection.insert(1); // return false since collection contains 1.\n // Inserts another 1 collection. Collection contains [1,1].\nrandomizedCollection.insert(2); // return true since collection contain 2.\n // Inserts 2 collection. Collection contains [1,1,2].\nrandomizedCollection.getRandom(); // getRandom should:\n // - return 1 probability 2/3, or\n // - return 2 probability 1/3.\nrandomizedCollection.remove(1); // return true since collection contains 1.\n // Removes 1 collection. Collection contains [1,2].\nrandomizedCollection.getRandom(); // getRandom return 1 2, equally likely.\n\n\xc2\xa0\nConstraints:\n\n-231 <= val <= 231 - 1\nAt 2 * 105 calls total made insert, remove, getRandom.\nThere least one element data structure getRandom called.\n\n' b'Given singly linked list, return random node\'s value linked list. Each node must probability chosen.\nImplement Solution class:\n\nSolution(ListNode head) Initializes object head singly-linked list head.\nint getRandom() Chooses node randomly list returns value. All nodes list equally likely chosen.\n\n\xc2\xa0\nExample 1:\n\nInput\n["Solution", "getRandom", "getRandom", "getRandom", "getRandom", "getRandom"]\n[[[1, 2, 3]], [], [], [], [], []]\nOutput\n[null, 1, 3, 2, 2, 3]\n\nExplanation\nSolution solution = new Solution([1, 2, 3]);\nsolution.getRandom(); // return 1\nsolution.getRandom(); // return 3\nsolution.getRandom(); // return 2\nsolution.getRandom(); // return 2\nsolution.getRandom(); // return 3\n// getRandom() return either 1, 2, 3 randomly. Each element equal probability returning.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes linked list range [1, 104].\n-104 <= Node.val <= 104\nAt 104 calls made getRandom.\n\n\xc2\xa0\nFollow up:\n\nWhat linked list extremely large length unknown you?\nCould solve efficiently without using extra space?\n\n' b'Given two strings ransomNote magazine, return true ransomNote constructed using letters magazine false otherwise.\nEach letter magazine used ransomNote.\n\xc2\xa0\nExample 1:\nInput: ransomNote = "a", magazine = "b"\nOutput: false\nExample 2:\nInput: ransomNote = "aa", magazine = "ab"\nOutput: false\nExample 3:\nInput: ransomNote = "aa", magazine = "aab"\nOutput: true\n\n\xc2\xa0\nConstraints:\n\n1 <= ransomNote.length, magazine.length <= 105\nransomNote magazine consist lowercase English letters.\n\n' b'Given integer array nums, design algorithm randomly shuffle array. All permutations array equally likely result shuffling.\nImplement Solution class:\n\nSolution(int[] nums) Initializes object integer array nums.\nint[] reset() Resets array original configuration returns it.\nint[] shuffle() Returns random shuffling array.\n\n\xc2\xa0\nExample 1:\nInput\n["Solution", "shuffle", "reset", "shuffle"]\n[[[1, 2, 3]], [], [], []]\nOutput\n[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n\nExplanation\nSolution solution = new Solution([1, 2, 3]);\nsolution.shuffle(); // Shuffle array [1,2,3] return result.\n // Any permutation [1,2,3] must equally likely returned.\n // Example: return [3, 1, 2]\nsolution.reset(); // Resets array back original configuration [1,2,3]. Return [1, 2, 3]\nsolution.shuffle(); // Returns random shuffling array [1,2,3]. Example: return [1, 3, 2]\n\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 50\n-106 <= nums[i] <= 106\nAll elements nums unique.\nAt 104 calls total made reset shuffle.\n\n' b'Given string represents serialization nested list, implement parser deserialize return deserialized NestedInteger.\nEach element either integer list whose elements may also integers lists.\n\xc2\xa0\nExample 1:\nInput: = "324"\nOutput: 324\nExplanation: You return NestedInteger object contains single integer 324.\n\nExample 2:\nInput: = "[123,[456,[789]]]"\nOutput: [123,[456,[789]]]\nExplanation: Return NestedInteger object containing nested list 2 elements:\n1. An integer containing value 123.\n2. A nested list containing two elements:\n i. An integer containing value 456.\n ii. A nested list one element:\n a. An integer containing value 789\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 5 * 104\ns consists digits, square brackets "[]", negative sign \'-\', commas \',\'.\ns serialization valid NestedInteger.\nAll values input range [-106, 106].\n\n' b'Given integer n, return numbers range [1, n] sorted lexicographical order.\nYou must write algorithm runs in\xc2\xa0O(n)\xc2\xa0time uses O(1) extra space.\xc2\xa0\n\xc2\xa0\nExample 1:\nInput: n = 13\nOutput: [1,10,11,12,13,2,3,4,5,6,7,8,9]\nExample 2:\nInput: n = 2\nOutput: [1,2]\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 5 * 104\n\n' b'Given string s, find first non-repeating character return index. If exist, return -1.\n\xc2\xa0\nExample 1:\nInput: = "leetcode"\nOutput: 0\nExample 2:\nInput: = "loveleetcode"\nOutput: 2\nExample 3:\nInput: = "aabb"\nOutput: -1\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 105\ns consists lowercase English letters.\n\n' b'Suppose file system stores files directories. An example one system represented following picture:\n\nHere, dir directory root. dir contains two subdirectories, subdir1 subdir2. subdir1 contains file file1.ext subdirectory subsubdir1. subdir2 contains subdirectory subsubdir2, contains file file2.ext.\nIn text form, looks like (with \xe2\x9f\xb6 representing tab character):\ndir\n\xe2\x9f\xb6 subdir1\n\xe2\x9f\xb6 \xe2\x9f\xb6 file1.ext\n\xe2\x9f\xb6 \xe2\x9f\xb6 subsubdir1\n\xe2\x9f\xb6 subdir2\n\xe2\x9f\xb6 \xe2\x9f\xb6 subsubdir2\n\xe2\x9f\xb6 \xe2\x9f\xb6 \xe2\x9f\xb6 file2.ext\n\nIf write representation code, look like this: "dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext". Note \'\\n\' \'\\t\' new-line tab characters.\nEvery file directory unique absolute path file system, order directories must opened reach file/directory itself, concatenated \'/\'s. Using example, absolute path file2.ext "dir/subdir2/subsubdir2/file2.ext". Each directory name consists letters, digits, and/or spaces. Each file name form name.extension, name extension consist letters, digits, and/or spaces.\nGiven string input representing file system explained format, return length longest absolute path file abstracted file system. If file system, return 0.\nNote testcases generated file system valid file directory name length 0.\n\xc2\xa0\nExample 1:\n\nInput: input = "dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext"\nOutput: 20\nExplanation: We one file, absolute path "dir/subdir2/file.ext" length 20.\n\nExample 2:\n\nInput: input = "dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext"\nOutput: 32\nExplanation: We two files:\n"dir/subdir1/file1.ext" length 21\n"dir/subdir2/subsubdir2/file2.ext" length 32.\nWe return 32 since longest absolute path file.\n\nExample 3:\nInput: input = "a"\nOutput: 0\nExplanation: We files, single directory named "a".\n\n\xc2\xa0\nConstraints:\n\n1 <= input.length <= 104\ninput may contain lowercase uppercase English letters, new line character \'\\n\', tab character \'\\t\', dot \'.\', space \' \', digits.\nAll file directory names positive length.\n\n' b'You given two strings t.\nString generated random shuffling string add one letter random position.\nReturn letter added t.\n\xc2\xa0\nExample 1:\nInput: = "abcd", = "abcde"\nOutput: "e"\nExplanation: \'e\' letter added.\n\nExample 2:\nInput: = "", = "y"\nOutput: "y"\n\n\xc2\xa0\nConstraints:\n\n0 <= s.length <= 1000\nt.length == s.length + 1\ns consist lowercase English letters.\n\n' b'You list arr integers range [1, n] sorted strictly increasing order. Apply following algorithm arr:\n\nStarting left right, remove first number every number afterward reach end list.\nRepeat previous step again, time right left, remove rightmost number every number remaining numbers.\nKeep repeating steps again, alternating left right right left, single number remains.\n\nGiven integer n, return last number remains arr.\n\xc2\xa0\nExample 1:\nInput: n = 9\nOutput: 6\nExplanation:\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\narr = [2, 4, 6, 8]\narr = [2, 6]\narr = [6]\n\nExample 2:\nInput: n = 1\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 109\n\n' b'Given array rectangles rectangles[i] = [xi, yi, ai, bi] represents axis-aligned rectangle. The bottom-left point rectangle (xi, yi) top-right point (ai, bi).\nReturn true rectangles together form exact cover rectangular region.\n\xc2\xa0\nExample 1:\n\nInput: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\nOutput: true\nExplanation: All 5 rectangles together form exact cover rectangular region.\n\nExample 2:\n\nInput: rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]\nOutput: false\nExplanation: Because gap two rectangular regions.\n\nExample 3:\n\nInput: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]\nOutput: false\nExplanation: Because two rectangles overlap other.\n\n\xc2\xa0\nConstraints:\n\n1 <= rectangles.length <= 2 * 104\nrectangles[i].length == 4\n-105 <= xi, yi, ai, bi <= 105\n\n' b'Given two strings t, return true subsequence t, false otherwise.\nA subsequence string new string formed original string deleting (can none) characters without disturbing relative positions remaining characters. (i.e., "ace" subsequence "abcde" "aec" not).\n\xc2\xa0\nExample 1:\nInput: = "abc", = "ahbgdc"\nOutput: true\nExample 2:\nInput: = "axc", = "ahbgdc"\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n0 <= s.length <= 100\n0 <= t.length <= 104\ns consist lowercase English letters.\n\n\xc2\xa0\nFollow up: Suppose lots incoming s, say s1, s2, ..., sk k >= 109, want check one one see subsequence. In scenario, would change code?' b"Given integer array data representing data, return whether valid UTF-8 encoding (i.e. translates sequence valid UTF-8 encoded characters).\nA character UTF8 1 4 bytes long, subjected following rules:\n\nFor 1-byte character, first bit 0, followed Unicode code.\nFor n-bytes character, first n bits one's, n + 1 bit 0, followed n - 1 bytes significant 2 bits 10.\n\nThis UTF-8 encoding would work:\n Number Bytes | UTF-8 Octet Sequence\n | (binary)\n --------------------+-----------------------------------------\n 1 | 0xxxxxxx\n 2 | 110xxxxx 10xxxxxx\n 3 | 1110xxxx 10xxxxxx 10xxxxxx\n 4 | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\nx denotes bit binary form byte may either 0 1.\nNote: The input array integers. Only least significant 8 bits integer used store data. This means integer represents 1 byte data.\n\xc2\xa0\nExample 1:\nInput: data = [197,130,1]\nOutput: true\nExplanation: data represents octet sequence: 11000101 10000010 00000001.\nIt valid utf-8 encoding 2-bytes character followed 1-byte character.\n\nExample 2:\nInput: data = [235,140,4]\nOutput: false\nExplanation: data represented octet sequence: 11101011 10001100 00000100.\nThe first 3 bits one's 4th bit 0 means 3-bytes character.\nThe next byte continuation byte starts 10 that's correct.\nBut second continuation byte start 10, invalid.\n\n\xc2\xa0\nConstraints:\n\n1 <= data.length <= 2 * 104\n0 <= data[i] <= 255\n\n" b'Given encoded string, return decoded string.\nThe encoding rule is: k[encoded_string], encoded_string inside square brackets repeated exactly k times. Note k guaranteed positive integer.\nYou may assume input string always valid; extra white spaces, square brackets well-formed, etc. Furthermore, may assume original data contain digits digits repeat numbers, k. For example, input like 3a 2[4].\nThe test cases generated length output never exceed 105.\n\xc2\xa0\nExample 1:\nInput: = "3[a]2[bc]"\nOutput: "aaabcbc"\n\nExample 2:\nInput: = "3[a2[c]]"\nOutput: "accaccacc"\n\nExample 3:\nInput: = "2[abc]3[cd]ef"\nOutput: "abcabccdcdcdef"\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 30\ns consists lowercase English letters, digits, square brackets \'[]\'.\ns guaranteed valid input.\nAll integers range [1, 300].\n\n' b'Given string integer k, return length longest substring frequency character substring greater equal k.\n\xc2\xa0\nExample 1:\nInput: = "aaabb", k = 3\nOutput: 3\nExplanation: The longest substring "aaa", \'a\' repeated 3 times.\n\nExample 2:\nInput: = "ababbc", k = 2\nOutput: 5\nExplanation: The longest substring "ababb", \'a\' repeated 2 times \'b\' repeated 3 times.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 104\ns consists lowercase English letters.\n1 <= k <= 105\n\n' b'You given integer array nums length n.\nAssume arrk array obtained rotating nums k positions clock-wise. We define rotation function F nums follow:\n\nF(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].\n\nReturn maximum value F(0), F(1), ..., F(n-1).\nThe test cases generated answer fits 32-bit integer.\n\xc2\xa0\nExample 1:\nInput: nums = [4,3,2,6]\nOutput: 26\nExplanation:\nF(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\nSo maximum value F(0), F(1), F(2), F(3) F(3) = 26.\n\nExample 2:\nInput: nums = [100]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= n <= 105\n-100 <= nums[i] <= 100\n\n' b'Given positive integer n,\xc2\xa0you apply one following\xc2\xa0operations:\n\nIf n even, replace n n / 2.\nIf n odd, replace n either n + 1 n - 1.\n\nReturn minimum number operations needed n become 1.\n\xc2\xa0\nExample 1:\nInput: n = 8\nOutput: 3\nExplanation: 8 -> 4 -> 2 -> 1\n\nExample 2:\nInput: n = 7\nOutput: 4\nExplanation: 7 -> 8 -> 4 -> 2 -> 1\nor 7 -> 6 -> 3 -> 2 -> 1\n\nExample 3:\nInput: n = 4\nOutput: 2\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 231 - 1\n\n' b'Given integer array nums possible duplicates, randomly output index given target number. You assume given target number must exist array.\nImplement Solution class:\n\nSolution(int[] nums) Initializes object array nums.\nint pick(int target) Picks random index nums nums[i] == target. If multiple valid i\'s, index equal probability returning.\n\n\xc2\xa0\nExample 1:\nInput\n["Solution", "pick", "pick", "pick"]\n[[[1, 2, 3, 3, 3]], [3], [1], [3]]\nOutput\n[null, 4, 0, 2]\n\nExplanation\nSolution solution = new Solution([1, 2, 3, 3, 3]);\nsolution.pick(3); // It return either index 2, 3, 4 randomly. Each index equal probability returning.\nsolution.pick(1); // It return 0. Since array nums[0] equal 1.\nsolution.pick(3); // It return either index 2, 3, 4 randomly. Each index equal probability returning.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 2 * 104\n-231 <= nums[i] <= 231 - 1\ntarget integer nums.\nAt 104 calls made pick.\n\n' b'You given array variable pairs equations array real numbers values, equations[i] = [Ai, Bi] values[i] represent equation Ai / Bi = values[i]. Each Ai Bi string represents single variable.\nYou also given queries, queries[j] = [Cj, Dj] represents jth query must find answer Cj / Dj = ?.\nReturn answers queries. If single answer cannot determined, return -1.0.\nNote: The input always valid. You may assume evaluating queries result division zero contradiction.\n\xc2\xa0\nExample 1:\nInput: equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\nExplanation: \nGiven: / b = 2.0, b / c = 3.0\nqueries are: / c = ?, b / = ?, / e = ?, / = ?, x / x = ?\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\n\nExample 2:\nInput: equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]\nOutput: [3.75000,0.40000,5.00000,0.20000]\n\nExample 3:\nInput: equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\n\n\xc2\xa0\nConstraints:\n\n1 <= equations.length <= 20\nequations[i].length == 2\n1 <= Ai.length, Bi.length <= 5\nvalues.length == equations.length\n0.0 < values[i] <= 20.0\n1 <= queries.length <= 20\nqueries[i].length == 2\n1 <= Cj.length, Dj.length <= 5\nAi, Bi, Cj, Dj consist lower case English letters digits.\n\n' b'Given integer n, return nth digit infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].\n\xc2\xa0\nExample 1:\nInput: n = 3\nOutput: 3\n\nExample 2:\nInput: n = 11\nOutput: 0\nExplanation: The 11th digit sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 0, part number 10.\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 231 - 1\n\n' b'A binary watch 4 LEDs top represent hours (0-11), 6 LEDs bottom represent\xc2\xa0the minutes (0-59). Each LED represents zero one, least significant bit right.\n\nFor example, binary watch reads "4:51".\n\n\nGiven integer turnedOn represents number LEDs currently (ignoring PM), return possible times watch could represent. You may return answer order.\nThe hour must contain leading zero.\n\nFor example, "01:00" valid. It "1:00".\n\nThe minute must consist two digits may contain leading zero.\n\nFor example, "10:2" valid. It "10:02".\n\n\xc2\xa0\nExample 1:\nInput: turnedOn = 1\nOutput: ["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]\nExample 2:\nInput: turnedOn = 9\nOutput: []\n\n\xc2\xa0\nConstraints:\n\n0 <= turnedOn <= 10\n\n' b'Given string num representing non-negative integer num, integer k, return smallest possible integer removing k digits num.\n\xc2\xa0\nExample 1:\nInput: num = "1432219", k = 3\nOutput: "1219"\nExplanation: Remove three digits 4, 3, 2 form new number 1219 smallest.\n\nExample 2:\nInput: num = "10200", k = 1\nOutput: "200"\nExplanation: Remove leading 1 number 200. Note output must contain leading zeroes.\n\nExample 3:\nInput: num = "10", k = 2\nOutput: "0"\nExplanation: Remove digits number left nothing 0.\n\n\xc2\xa0\nConstraints:\n\n1 <= k <= num.length <= 105\nnum consists digits.\nnum leading zeros except zero itself.\n\n' b"A frog crossing river. The river divided number units, unit, may may exist stone. The frog jump stone, must jump water.\nGiven list stones' positions (in units) sorted ascending order, determine frog cross river landing last stone. Initially, frog first stone assumes first jump must 1 unit.\nIf frog's last jump k units, next jump must either k - 1, k, k + 1 units. The frog jump forward direction.\n\xc2\xa0\nExample 1:\nInput: stones = [0,1,3,5,6,8,12,17]\nOutput: true\nExplanation: The frog jump last stone jumping 1 unit 2nd stone, 2 units 3rd stone, 2 units 4th stone, 3 units 6th stone, 4 units 7th stone, 5 units 8th stone.\n\nExample 2:\nInput: stones = [0,1,2,3,4,8,9,11]\nOutput: false\nExplanation: There way jump last stone gap 5th 6th stone large.\n\n\xc2\xa0\nConstraints:\n\n2 <= stones.length <= 2000\n0 <= stones[i] <= 231 - 1\nstones[0] == 0\nstones\xc2\xa0is sorted strictly increasing order.\n\n" b'Given root binary tree, return sum left leaves.\nA leaf node children. A left leaf leaf left child another node.\n\xc2\xa0\nExample 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: 24\nExplanation: There two left leaves binary tree, values 9 15 respectively.\n\nExample 2:\nInput: root = [1]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 1000].\n-1000 <= Node.val <= 1000\n\n' b'Given integer num, return string representing hexadecimal representation. For negative integers, two\xe2\x80\x99s complement method used.\nAll letters answer string lowercase characters, leading zeros answer except zero itself.\nNote:\xc2\xa0You allowed use built-in library method directly solve problem.\n\xc2\xa0\nExample 1:\nInput: num = 26\nOutput: "1a"\nExample 2:\nInput: num = -1\nOutput: "ffffffff"\n\n\xc2\xa0\nConstraints:\n\n-231 <= num <= 231 - 1\n\n' b'You given array people, people, attributes people queue (not necessarily order). Each people[i] = [hi, ki] represents ith person height hi exactly ki people front height greater equal hi.\nReconstruct return queue represented input array people. The returned queue formatted array queue, queue[j] = [hj, kj] attributes jth person queue (queue[0] person front queue).\n\xc2\xa0\nExample 1:\nInput: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\nOutput: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\nExplanation:\nPerson 0 height 5 people taller height front.\nPerson 1 height 7 people taller height front.\nPerson 2 height 5 two persons taller height front, person 0 1.\nPerson 3 height 6 one person taller height front, person 1.\nPerson 4 height 4 four people taller height front, people 0, 1, 2, 3.\nPerson 5 height 7 one person taller height front, person 1.\nHence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] reconstructed queue.\n\nExample 2:\nInput: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]\nOutput: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]\n\n\xc2\xa0\nConstraints:\n\n1 <= people.length <= 2000\n0 <= hi <= 106\n0 <= ki < people.length\nIt guaranteed queue reconstructed.\n\n' b'Given x n integer matrix heightMap representing height unit cell 2D elevation map, return volume water trap raining.\n\xc2\xa0\nExample 1:\n\nInput: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\nOutput: 4\nExplanation: After rain, water trapped blocks.\nWe two small ponds 1 3 units trapped.\nThe total volume water trapped 4.\n\nExample 2:\n\nInput: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\nOutput: 10\n\n\xc2\xa0\nConstraints:\n\nm == heightMap.length\nn == heightMap[i].length\n1 <= m, n <= 200\n0 <= heightMap[i][j] <= 2 * 104\n\n' b'Given string consists lowercase uppercase letters, return length longest palindrome\xc2\xa0that built letters.\nLetters case sensitive, example,\xc2\xa0"Aa" considered palindrome here.\n\xc2\xa0\nExample 1:\nInput: = "abccccdd"\nOutput: 7\nExplanation:\nOne longest palindrome built "dccaccd", whose length 7.\n\nExample 2:\nInput: = "a"\nOutput: 1\n\nExample 3:\nInput: = "bb"\nOutput: 2\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 2000\ns consists lowercase and/or uppercase English\xc2\xa0letters only.\n\n' b'Given array nums consists non-negative integers integer m, split array non-empty continuous subarrays.\nWrite algorithm minimize largest sum among subarrays.\n\xc2\xa0\nExample 1:\nInput: nums = [7,2,5,10,8], = 2\nOutput: 18\nExplanation:\nThere four ways split nums two subarrays.\nThe best way split [7,2,5] [10,8],\nwhere largest sum among two subarrays 18.\n\nExample 2:\nInput: nums = [1,2,3,4,5], = 2\nOutput: 9\n\nExample 3:\nInput: nums = [1,4,4], = 3\nOutput: 4\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 1000\n0 <= nums[i] <= 106\n1 <= <= min(50, nums.length)\n\n' b'Given integer n, return string array answer (1-indexed) where:\n\nanswer[i] == "FizzBuzz" divisible 3 5.\nanswer[i] == "Fizz" divisible 3.\nanswer[i] == "Buzz" divisible 5.\nanswer[i] == (as string) none conditions true.\n\n\xc2\xa0\nExample 1:\nInput: n = 3\nOutput: ["1","2","Fizz"]\nExample 2:\nInput: n = 5\nOutput: ["1","2","Fizz","4","Buzz"]\nExample 3:\nInput: n = 15\nOutput: ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 104\n\n' b'An integer array called arithmetic consists least three elements difference two consecutive elements same.\n\nFor example, [1,3,5,7,9], [7,7,7,7], [3,-1,-5,-9] arithmetic sequences.\n\nGiven integer array nums, return number arithmetic subarrays nums.\nA subarray contiguous subsequence array.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3,4]\nOutput: 3\nExplanation: We 3 arithmetic slices nums: [1, 2, 3], [2, 3, 4] [1,2,3,4] itself.\n\nExample 2:\nInput: nums = [1]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 5000\n-1000 <= nums[i] <= 1000\n\n' b"Given integer array nums, return third distinct maximum number array. If third maximum exist, return maximum number.\n\xc2\xa0\nExample 1:\nInput: nums = [3,2,1]\nOutput: 1\nExplanation:\nThe first distinct maximum 3.\nThe second distinct maximum 2.\nThe third distinct maximum 1.\n\nExample 2:\nInput: nums = [1,2]\nOutput: 2\nExplanation:\nThe first distinct maximum 2.\nThe second distinct maximum 1.\nThe third distinct maximum exist, maximum (2) returned instead.\n\nExample 3:\nInput: nums = [2,2,3,1]\nOutput: 1\nExplanation:\nThe first distinct maximum 3.\nThe second distinct maximum 2 (both 2's counted together since value).\nThe third distinct maximum 1.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1\n\n\xc2\xa0\nFollow up: Can find O(n) solution?" b'Given two non-negative integers, num1 num2 represented string, return sum num1 num2 string.\nYou must solve problem without using built-in library handling large integers (such BigInteger). You must also convert inputs integers directly.\n\xc2\xa0\nExample 1:\nInput: num1 = "11", num2 = "123"\nOutput: "134"\n\nExample 2:\nInput: num1 = "456", num2 = "77"\nOutput: "533"\n\nExample 3:\nInput: num1 = "0", num2 = "0"\nOutput: "0"\n\n\xc2\xa0\nConstraints:\n\n1 <= num1.length, num2.length <= 104\nnum1 num2 consist digits.\nnum1 num2 don\'t leading zeros except zero itself.\n\n' b'Given non-empty array nums containing positive integers, find array partitioned two subsets sum elements subsets equal.\n\xc2\xa0\nExample 1:\nInput: nums = [1,5,11,5]\nOutput: true\nExplanation: The array partitioned [1, 5, 5] [11].\n\nExample 2:\nInput: nums = [1,2,3,5]\nOutput: false\nExplanation: The array cannot partitioned equal sum subsets.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 200\n1 <= nums[i] <= 100\n\n' b"There x n rectangular island borders Pacific Ocean Atlantic Ocean. The Pacific Ocean touches island's left top edges, Atlantic Ocean touches island's right bottom edges.\nThe island partitioned grid square cells. You given x n integer matrix heights heights[r][c] represents height sea level cell coordinate (r, c).\nThe island receives lot rain, rain water flow neighboring cells directly north, south, east, west neighboring cell's height less equal current cell's height. Water flow cell adjacent ocean ocean.\nReturn 2D list grid coordinates result result[i] = [ri, ci] denotes rain water flow cell (ri, ci) Pacific Atlantic oceans.\n\xc2\xa0\nExample 1:\n\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n\nExample 2:\nInput: heights = [[2,1],[1,2]]\nOutput: [[0,0],[0,1],[1,0],[1,1]]\n\n\xc2\xa0\nConstraints:\n\nm == heights.length\nn == heights[r].length\n1 <= m, n <= 200\n0 <= heights[r][c] <= 105\n\n" b'Given x n matrix board cell battleship \'X\' empty \'.\', return number battleships board.\nBattleships placed horizontally vertically board. In words, made shape 1 x k (1 row, k columns) k x 1 (k rows, 1 column), k size. At least one horizontal vertical cell separates two battleships (i.e., adjacent battleships).\n\xc2\xa0\nExample 1:\n\nInput: board = [["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]]\nOutput: 2\n\nExample 2:\nInput: board = [["."]]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\nm == board.length\nn == board[i].length\n1 <= m, n <= 200\nboard[i][j] either \'.\' \'X\'.\n\n\xc2\xa0\nFollow up: Could one-pass, using O(1) extra memory without modifying values board?\n' b'A password considered strong conditions met:\n\nIt least 6 characters 20 characters.\nIt contains least one lowercase letter, least one uppercase letter, least one digit.\nIt does\xc2\xa0not contain three repeating characters row (i.e.,\xc2\xa0"...aaa..." weak, "...aa...a..." strong, assuming conditions met).\n\nGiven string password, return minimum number steps required make password strong. password already strong, return 0.\nIn one step, can:\n\nInsert one character password,\nDelete one character password, or\nReplace\xc2\xa0one character password another character.\n\n\xc2\xa0\nExample 1:\nInput: password = "a"\nOutput: 5\nExample 2:\nInput: password = "aA1"\nOutput: 3\nExample 3:\nInput: password = "1337C0d3"\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <= password.length <= 50\npassword consists letters, digits, dot\xc2\xa0\'.\' exclamation mark \'!\'.\n\n' b'Given integer array nums, return maximum result nums[i] XOR nums[j], 0 <= <= j < n.\n\xc2\xa0\nExample 1:\nInput: nums = [3,10,5,25,2,8]\nOutput: 28\nExplanation: The maximum result 5 XOR 25 = 28.\n\nExample 2:\nInput: nums = [14,70,53,83,49,91,36,80,92,51,66,70]\nOutput: 127\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 2 * 105\n0 <= nums[i] <= 231 - 1\n\n' b'Given string containing out-of-order English representation digits 0-9, return digits ascending order.\n\xc2\xa0\nExample 1:\nInput: = "owoztneoer"\nOutput: "012"\nExample 2:\nInput: = "fviefuro"\nOutput: "45"\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 105\ns[i] one characters ["e","g","f","i","h","o","n","s","r","u","t","w","v","x","z"].\ns guaranteed valid.\n\n' b'You given string integer k. You choose character string change uppercase English character. You perform operation k times.\nReturn length longest substring containing letter get performing operations.\n\xc2\xa0\nExample 1:\nInput: = "ABAB", k = 2\nOutput: 4\nExplanation: Replace two \'A\'s two \'B\'s vice versa.\n\nExample 2:\nInput: = "AABABBA", k = 1\nOutput: 4\nExplanation: Replace one \'A\' middle \'B\' form "AABBBBA".\nThe substring "BBBB" longest repeating letters, 4.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 105\ns consists uppercase English letters.\n0 <= k <= s.length\n\n' b"Given n * n matrix grid 0's 1's only. We want represent grid Quad-Tree.\nReturn root Quad-Tree representing grid.\nNotice assign value node True False isLeaf False, accepted answer.\nA Quad-Tree tree data structure internal node exactly four children. Besides, node two attributes:\n\nval: True node represents grid 1's False node represents grid 0's.\nisLeaf: True node leaf node tree False node four children.\n\nclass Node {\n public boolean val;\n public boolean isLeaf;\n public Node topLeft;\n public Node topRight;\n public Node bottomLeft;\n public Node bottomRight;\n}\nWe construct Quad-Tree two-dimensional area using following steps:\n\nIf current grid value (i.e 1's 0's) set isLeaf True set val value grid set four children Null stop.\nIf current grid different values, set isLeaf False set val value divide current grid four sub-grids shown photo.\nRecurse children proper sub-grid.\n\n\nIf want know Quad-Tree, refer wiki.\nQuad-Tree format:\nThe output represents serialized format Quad-Tree using level order traversal, null signifies path terminator node exists below.\nIt similar serialization binary tree. The difference node represented list [isLeaf, val].\nIf value isLeaf val True represent 1 list [isLeaf, val] value isLeaf val False represent 0.\n\xc2\xa0\nExample 1:\n\nInput: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation example shown below:\nNotice 0 represnts False 1 represents True photo representing Quad-Tree.\n\n\nExample 2:\n\nInput: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values grid same. We divide grid four sub-grids.\nThe topLeft, bottomLeft bottomRight value.\nThe topRight different values divide 4 sub-grids value.\nExplanation shown photo below:\n\n\n\xc2\xa0\nConstraints:\n\nn == grid.length == grid[i].length\nn == 2x 0 <= x <= 6\n\n" b"Given n-ary tree, return level order traversal nodes' values.\nNary-Tree input serialization represented level order traversal, group children separated null value (See examples).\n\xc2\xa0\nExample 1:\n\nInput: root = [1,null,3,2,4,null,5,6]\nOutput: [[1],[3,2,4],[5,6]]\n\nExample 2:\n\nInput: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n\n\xc2\xa0\nConstraints:\n\nThe height n-ary tree less equal 1000\nThe total number nodes [0, 104]\n\n" b'You given doubly linked list, contains nodes next pointer, previous pointer, additional child pointer. This child pointer may may point separate doubly linked list, also containing special nodes. These child lists may one children own, on, produce multilevel data structure shown example below.\nGiven head first level list, flatten list nodes appear single-level, doubly linked list. Let curr node child list. The nodes child list appear curr curr.next flattened list.\nReturn head flattened list. The nodes list must child pointers set null.\n\xc2\xa0\nExample 1:\n\nInput: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\nOutput: [1,2,3,7,8,11,12,9,10,4,5,6]\nExplanation: The multilevel linked list input shown.\nAfter flattening multilevel linked list becomes:\n\n\nExample 2:\n\nInput: head = [1,2,null,3]\nOutput: [1,3,2]\nExplanation: The multilevel linked list input shown.\nAfter flattening multilevel linked list becomes:\n\n\nExample 3:\nInput: head = []\nOutput: []\nExplanation: There could empty list input.\n\n\xc2\xa0\nConstraints:\n\nThe number Nodes exceed 1000.\n1 <= Node.val <= 105\n\n\xc2\xa0\nHow multilevel linked list represented test cases:\nWe use multilevel linked list Example 1 above:\n 1---2---3---4---5---6--NULL\n |\n 7---8---9---10--NULL\n |\n 11--12--NULL\nThe serialization level follows:\n[1,2,3,4,5,6,null]\n[7,8,9,10,null]\n[11,12,null]\n\nTo serialize levels together, add nulls level signify node connects upper node previous level. The serialization becomes:\n[1, 2, 3, 4, 5, 6, null]\n |\n[null, null, 7, 8, 9, 10, null]\n |\n[ null, 11, 12, null]\n\nMerging serialization level removing trailing nulls obtain:\n[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n\n' b'Design data structure store strings\' count ability return strings minimum maximum counts.\nImplement AllOne class:\n\nAllOne() Initializes object data structure.\ninc(String key) Increments count string key 1. If key exist data structure, insert count 1.\ndec(String key) Decrements count string key 1. If count key 0 decrement, remove data structure. It guaranteed key exists data structure decrement.\ngetMaxKey() Returns one keys maximal count. If element exists, return empty string "".\ngetMinKey() Returns one keys minimum count. If element exists, return empty string "".\n\nNote function must run O(1) average time complexity.\n\xc2\xa0\nExample 1:\nInput\n["AllOne", "inc", "inc", "getMaxKey", "getMinKey", "inc", "getMaxKey", "getMinKey"]\n[[], ["hello"], ["hello"], [], [], ["leet"], [], []]\nOutput\n[null, null, null, "hello", "hello", null, "hello", "leet"]\n\nExplanation\nAllOne allOne = new AllOne();\nallOne.inc("hello");\nallOne.inc("hello");\nallOne.getMaxKey(); // return "hello"\nallOne.getMinKey(); // return "hello"\nallOne.inc("leet");\nallOne.getMaxKey(); // return "hello"\nallOne.getMinKey(); // return "leet"\n\n\xc2\xa0\nConstraints:\n\n1 <= key.length <= 10\nkey consists lowercase English letters.\nIt guaranteed call dec, key existing data structure.\nAt 5 * 104\xc2\xa0calls made inc, dec, getMaxKey, getMinKey.\n\n' b'A gene string represented 8-character long string, choices \'A\', \'C\', \'G\', \'T\'.\nSuppose need investigate mutation gene string start gene string end one mutation defined one single character changed gene string.\n\nFor example, "AACCGGTT" --> "AACCGGTA" one mutation.\n\nThere also gene bank bank records valid gene mutations. A gene must bank make valid gene string.\nGiven two gene strings start end gene bank bank, return minimum number mutations needed mutate start end. If mutation, return -1.\nNote starting point assumed valid, might included bank.\n\xc2\xa0\nExample 1:\nInput: start = "AACCGGTT", end = "AACCGGTA", bank = ["AACCGGTA"]\nOutput: 1\n\nExample 2:\nInput: start = "AACCGGTT", end = "AAACGGTA", bank = ["AACCGGTA","AACCGCTA","AAACGGTA"]\nOutput: 2\n\nExample 3:\nInput: start = "AAAAACCC", end = "AACCCCCC", bank = ["AAAACCCC","AAACCCCC","AACCCCCC"]\nOutput: 3\n\n\xc2\xa0\nConstraints:\n\nstart.length == 8\nend.length == 8\n0 <= bank.length <= 10\nbank[i].length == 8\nstart, end, bank[i] consist characters [\'A\', \'C\', \'G\', \'T\'].\n\n' b'Given string s, return number segments string.\nA segment defined contiguous sequence non-space characters.\n\xc2\xa0\nExample 1:\nInput: = "Hello, name John"\nOutput: 5\nExplanation: The five segments ["Hello,", "my", "name", "is", "John"]\n\nExample 2:\nInput: = "Hello"\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n0 <= s.length <= 300\ns consists lowercase uppercase English letters, digits, one following characters "!@#$%^&*()_+-=\',.:".\nThe space character \' \'.\n\n' b"Given array intervals intervals intervals[i] = [starti, endi], return minimum number intervals need remove make rest intervals non-overlapping.\n\xc2\xa0\nExample 1:\nInput: intervals = [[1,2],[2,3],[3,4],[1,3]]\nOutput: 1\nExplanation: [1,3] removed rest intervals non-overlapping.\n\nExample 2:\nInput: intervals = [[1,2],[1,2],[1,2]]\nOutput: 2\nExplanation: You need remove two [1,2] make rest intervals non-overlapping.\n\nExample 3:\nInput: intervals = [[1,2],[2,3]]\nOutput: 0\nExplanation: You need remove intervals since they're already non-overlapping.\n\n\xc2\xa0\nConstraints:\n\n1 <= intervals.length <= 105\nintervals[i].length == 2\n-5 * 104 <= starti < endi <= 5 * 104\n\n" b'You given array intervals, intervals[i] = [starti, endi] starti unique.\nThe right interval interval interval j startj >= endi startj minimized. Note may equal j.\nReturn array right interval indices interval i. If right interval exists interval i, put -1 index i.\n\xc2\xa0\nExample 1:\nInput: intervals = [[1,2]]\nOutput: [-1]\nExplanation: There one interval collection, outputs -1.\n\nExample 2:\nInput: intervals = [[3,4],[2,3],[1,2]]\nOutput: [-1,0,1]\nExplanation: There right interval [3,4].\nThe right interval [2,3] [3,4] since start0 = 3 smallest start >= end1 = 3.\nThe right interval [1,2] [2,3] since start1 = 2 smallest start >= end2 = 2.\n\nExample 3:\nInput: intervals = [[1,4],[2,3],[3,4]]\nOutput: [-1,2,-1]\nExplanation: There right interval [1,4] [3,4].\nThe right interval [2,3] [3,4] since start2 = 3 smallest start >= end1 = 3.\n\n\xc2\xa0\nConstraints:\n\n1 <= intervals.length <= 2 * 104\nintervals[i].length == 2\n-106 <= starti <= endi <= 106\nThe start point interval unique.\n\n' b'Given root binary tree integer targetSum, return number paths sum values\xc2\xa0along path equals\xc2\xa0targetSum.\nThe path need start end root leaf, must go downwards (i.e., traveling parent nodes child nodes).\n\xc2\xa0\nExample 1:\n\nInput: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\nOutput: 3\nExplanation: The paths sum 8 shown.\n\nExample 2:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: 3\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 1000].\n-109 <= Node.val <= 109\n-1000 <= targetSum <= 1000\n\n' b'Given two strings p, return array start indices p\'s anagrams s. You may return answer order.\nAn Anagram word phrase formed rearranging letters different word phrase, typically using original letters exactly once.\n\xc2\xa0\nExample 1:\nInput: = "cbaebabacd", p = "abc"\nOutput: [0,6]\nExplanation:\nThe substring start index = 0 "cba", anagram "abc".\nThe substring start index = 6 "bac", anagram "abc".\n\nExample 2:\nInput: = "abab", p = "ab"\nOutput: [0,1,2]\nExplanation:\nThe substring start index = 0 "ab", anagram "ab".\nThe substring start index = 1 "ba", anagram "ab".\nThe substring start index = 2 "ab", anagram "ab".\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length, p.length <= 3 * 104\ns p consist lowercase English letters.\n\n' b'Given two integers n k, return kth lexicographically smallest integer range [1, n].\n\xc2\xa0\nExample 1:\nInput: n = 13, k = 2\nOutput: 10\nExplanation: The lexicographical order [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], second smallest number 10.\n\nExample 2:\nInput: n = 1, k = 1\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= k <= n <= 109\n\n' b'You n coins want build staircase coins. The staircase consists k rows ith row exactly coins. The last row staircase may incomplete.\nGiven integer n, return number complete rows staircase build.\n\xc2\xa0\nExample 1:\n\nInput: n = 5\nOutput: 2\nExplanation: Because 3rd row incomplete, return 2.\n\nExample 2:\n\nInput: n = 8\nOutput: 3\nExplanation: Because 4th row incomplete, return 3.\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 231 - 1\n\n' b'Given integer array nums length n integers nums range [1, n] integer appears twice, return array integers appears twice.\nYou must write algorithm runs in\xc2\xa0O(n)\xc2\xa0time uses constant extra space.\n\xc2\xa0\nExample 1:\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [2,3]\nExample 2:\nInput: nums = [1,1,2]\nOutput: [1]\nExample 3:\nInput: nums = [1]\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= n <= 105\n1 <= nums[i] <= n\nEach element nums appears twice.\n\n' b'Given array characters chars, compress using following algorithm:\nBegin empty string s. For group consecutive repeating characters chars:\n\nIf group\'s length 1, append character s.\nOtherwise, append character followed group\'s length.\n\nThe compressed string returned separately, instead, stored input character array chars. Note group lengths 10 longer split multiple characters chars.\nAfter done modifying input array, return new length array.\nYou must write algorithm uses constant extra space.\n\xc2\xa0\nExample 1:\nInput: chars = ["a","a","b","b","c","c","c"]\nOutput: Return 6, first 6 characters input array be: ["a","2","b","2","c","3"]\nExplanation: The groups "aa", "bb", "ccc". This compresses "a2b2c3".\n\nExample 2:\nInput: chars = ["a"]\nOutput: Return 1, first character input array be: ["a"]\nExplanation: The group "a", remains uncompressed since it\'s single character.\n\nExample 3:\nInput: chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]\nOutput: Return 4, first 4 characters input array be: ["a","b","1","2"].\nExplanation: The groups "a" "bbbbbbbbbbbb". This compresses "ab12".\n\xc2\xa0\nConstraints:\n\n1 <= chars.length <= 2000\nchars[i] lowercase English letter, uppercase English letter, digit, symbol.\n\n' b'You given two non-empty linked lists representing two non-negative integers. The significant digit comes first nodes contains single digit. Add two numbers return sum linked list.\nYou may assume two numbers contain leading zero, except number 0 itself.\n\xc2\xa0\nExample 1:\n\nInput: l1 = [7,2,4,3], l2 = [5,6,4]\nOutput: [7,8,0,7]\n\nExample 2:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [8,0,7]\n\nExample 3:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes linked list range [1, 100].\n0 <= Node.val <= 9\nIt guaranteed list represents number leading zeros.\n\n\xc2\xa0\nFollow up:\xc2\xa0Could solve without reversing input lists?\n' b'Given integer array nums, return number arithmetic subsequences nums.\nA sequence numbers called arithmetic consists least three elements difference two consecutive elements same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], [3, -1, -5, -9] arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] arithmetic sequence.\n\nA subsequence array sequence formed removing elements (possibly none) array.\n\nFor example, [2,5,10] subsequence [1,2,1,2,4,1,5,10].\n\nThe test cases generated answer fits 32-bit integer.\n\xc2\xa0\nExample 1:\nInput: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]\n\nExample 2:\nInput: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence array arithmetic.\n\n\xc2\xa0\nConstraints:\n\n1\xc2\xa0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\n\n' b'You given n points plane distinct, points[i] = [xi, yi]. A boomerang tuple points (i, j, k) distance j equals distance k (the order tuple matters).\nReturn number boomerangs.\n\xc2\xa0\nExample 1:\nInput: points = [[0,0],[1,0],[2,0]]\nOutput: 2\nExplanation: The two boomerangs [[1,0],[0,0],[2,0]] [[1,0],[2,0],[0,0]].\n\nExample 2:\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: 2\n\nExample 3:\nInput: points = [[1,1]]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\nn == points.length\n1 <= n <= 500\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll points unique.\n\n' b'Given array nums n integers nums[i] range [1, n], return array integers range [1, n] appear nums.\n\xc2\xa0\nExample 1:\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]\nExample 2:\nInput: nums = [1,1]\nOutput: [2]\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= n <= 105\n1 <= nums[i] <= n\n\n\xc2\xa0\nFollow up: Could without extra space O(n) runtime? You may assume returned list count extra space.\n' b'Serialization converting data structure object sequence bits stored file memory buffer, transmitted across network connection link reconstructed later another computer environment.\nDesign algorithm serialize deserialize binary search tree. There restriction serialization/deserialization algorithm work. You need ensure binary search tree serialized string, string deserialized original tree structure.\nThe encoded string compact possible.\n\xc2\xa0\nExample 1:\nInput: root = [2,1,3]\nOutput: [2,1,3]\nExample 2:\nInput: root = []\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 104].\n0 <= Node.val <= 104\nThe input tree guaranteed binary search tree.\n\n' b"Given root node reference BST key, delete node given key BST. Return root node reference (possibly updated) BST.\nBasically, deletion divided two stages:\n\nSearch node remove.\nIf node found, delete node.\n\n\xc2\xa0\nExample 1:\n\nInput: root = [5,3,6,2,4,null,7], key = 3\nOutput: [5,4,6,2,null,null,7]\nExplanation: Given key delete 3. So find node value 3 delete it.\nOne valid answer [5,4,6,2,null,null,7], shown BST.\nPlease notice another valid answer [5,2,6,null,4,null,7] also accepted.\n\n\nExample 2:\nInput: root = [5,3,6,2,4,null,7], key = 0\nOutput: [5,3,6,2,4,null,7]\nExplanation: The tree contain node value = 0.\n\nExample 3:\nInput: root = [], key = 0\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 104].\n-105 <= Node.val <= 105\nEach node unique value.\nroot valid binary search tree.\n-105 <= key <= 105\n\n\xc2\xa0\nFollow up: Could solve time complexity O(height tree)?\n" b'Given string s, sort decreasing order based frequency characters. The frequency character number times appears string.\nReturn sorted string. If multiple answers, return them.\n\xc2\xa0\nExample 1:\nInput: = "tree"\nOutput: "eert"\nExplanation: \'e\' appears twice \'r\' \'t\' appear once.\nSo \'e\' must appear \'r\' \'t\'. Therefore "eetr" also valid answer.\n\nExample 2:\nInput: = "cccaaa"\nOutput: "aaaccc"\nExplanation: Both \'c\' \'a\' appear three times, "cccaaa" "aaaccc" valid answers.\nNote "cacaca" incorrect, characters must together.\n\nExample 3:\nInput: = "Aabb"\nOutput: "bbAa"\nExplanation: "bbaA" also valid answer, "Aabb" incorrect.\nNote \'A\' \'a\' treated two different characters.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 5 * 105\ns consists uppercase lowercase English letters digits.\n\n' b'There spherical balloons taped onto flat wall represents XY-plane. The balloons represented 2D integer array points points[i] = [xstart, xend] denotes balloon whose horizontal diameter stretches xstart xend. You know exact y-coordinates balloons.\nArrows shot directly vertically (in positive y-direction) different points along x-axis. A balloon xstart xend burst arrow shot x xstart <= x <= xend. There limit number arrows shot. A shot arrow keeps traveling infinitely, bursting balloons path.\nGiven array points, return minimum number arrows must shot burst balloons.\n\xc2\xa0\nExample 1:\nInput: points = [[10,16],[2,8],[1,6],[7,12]]\nOutput: 2\nExplanation: The balloons burst 2 arrows:\n- Shoot arrow x = 6, bursting balloons [2,8] [1,6].\n- Shoot arrow x = 11, bursting balloons [10,16] [7,12].\n\nExample 2:\nInput: points = [[1,2],[3,4],[5,6],[7,8]]\nOutput: 4\nExplanation: One arrow needs shot balloon total 4 arrows.\n\nExample 3:\nInput: points = [[1,2],[2,3],[3,4],[4,5]]\nOutput: 2\nExplanation: The balloons burst 2 arrows:\n- Shoot arrow x = 2, bursting balloons [1,2] [2,3].\n- Shoot arrow x = 4, bursting balloons [3,4] [4,5].\n\n\xc2\xa0\nConstraints:\n\n1 <= points.length <= 105\npoints[i].length == 2\n-231 <= xstart < xend <= 231 - 1\n\n' b'Given integer array nums size n, return minimum number moves required make array elements equal.\nIn one move, increment n - 1 elements array 1.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3]\nOutput: 3\nExplanation: Only three moves needed (remember move increments two elements):\n[1,2,3] => [2,3,3] => [3,4,3] => [4,4,4]\n\nExample 2:\nInput: nums = [1,1,1]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109\nThe answer guaranteed fit 32-bit integer.\n\n' b'Given four integer arrays nums1, nums2, nums3, nums4 length n, return number tuples (i, j, k, l) that:\n\n0 <= i, j, k, l < n\nnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\n\n\xc2\xa0\nExample 1:\nInput: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\nOutput: 2\nExplanation:\nThe two tuples are:\n1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\n\nExample 2:\nInput: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\nn == nums1.length\nn == nums2.length\nn == nums3.length\nn == nums4.length\n1 <= n <= 200\n-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228\n\n' b'Assume awesome parent want give children cookies. But, give child one cookie.\nEach child greed factor g[i], minimum size cookie child content with; cookie j size s[j]. If s[j] >= g[i], assign cookie j child i, child content. Your goal maximize number content children output maximum number.\n\xc2\xa0\nExample 1:\nInput: g = [1,2,3], = [1,1]\nOutput: 1\nExplanation: You 3 children 2 cookies. The greed factors 3 children 1, 2, 3. \nAnd even though 2 cookies, since size 1, could make child whose greed factor 1 content.\nYou need output 1.\n\nExample 2:\nInput: g = [1,2], = [1,2,3]\nOutput: 2\nExplanation: You 2 children 3 cookies. The greed factors 2 children 1, 2. \nYou 3 cookies sizes big enough gratify children, \nYou need output 2.\n\n\xc2\xa0\nConstraints:\n\n1 <= g.length <= 3 * 104\n0 <= s.length <= 3 * 104\n1 <= g[i], s[j] <= 231 - 1\n\n' b'Given array n integers nums, 132 pattern subsequence three integers nums[i], nums[j] nums[k] < j < k nums[i] < nums[k] < nums[j].\nReturn true 132 pattern nums, otherwise, return false.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3,4]\nOutput: false\nExplanation: There 132 pattern sequence.\n\nExample 2:\nInput: nums = [3,1,4,2]\nOutput: true\nExplanation: There 132 pattern sequence: [1, 4, 2].\n\nExample 3:\nInput: nums = [-1,3,2,0]\nOutput: true\nExplanation: There three 132 patterns sequence: [-1, 3, 2], [-1, 3, 0] [-1, 2, 0].\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= n <= 2 * 105\n-109 <= nums[i] <= 109\n\n' b"You playing game involving circular array non-zero integers nums. Each nums[i] denotes number indices forward/backward must move located index i:\n\nIf nums[i] positive, move nums[i] steps forward, and\nIf nums[i] negative, move nums[i] steps backward.\n\nSince array circular, may assume moving forward last element puts first element, moving backwards first element puts last element.\nA cycle array consists sequence indices seq length k where:\n\nFollowing movement rules results repeating index sequence seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...\nEvery nums[seq[j]] either positive negative.\nk > 1\n\nReturn true cycle nums, false otherwise.\n\xc2\xa0\nExample 1:\nInput: nums = [2,-1,1,2,2]\nOutput: true\nExplanation:\nThere cycle index 0 -> 2 -> 3 -> 0 -> ...\nThe cycle's length 3.\n\nExample 2:\nInput: nums = [-1,2]\nOutput: false\nExplanation:\nThe sequence index 1 -> 1 -> 1 -> ... cycle sequence's length 1.\nBy definition sequence's length must strictly greater 1 cycle.\n\nExample 3:\nInput: nums = [-2,1,-1,-2,-2]\nOutput: false\nExplanation:\nThe sequence index 1 -> 2 -> 1 -> ... cycle nums[1] positive, nums[2] negative.\nEvery nums[seq[j]] must either positive negative.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 5000\n-1000 <= nums[i] <= 1000\nnums[i] != 0\n\n\xc2\xa0\nFollow up: Could solve O(n) time complexity O(1) extra space complexity?\n" b'There buckets buckets liquid, exactly one buckets poisonous. To figure one poisonous, feed number (poor) pigs liquid see whether die not. Unfortunately, minutesToTest minutes determine bucket poisonous.\nYou feed pigs according steps:\n\nChoose live pigs feed.\nFor pig, choose buckets feed it. The pig consume chosen buckets simultaneously take time.\nWait minutesToDie minutes. You may feed pigs time.\nAfter minutesToDie minutes passed, pigs fed poisonous bucket die, others survive.\nRepeat process run time.\n\nGiven buckets, minutesToDie, minutesToTest, return minimum number pigs needed figure bucket poisonous within allotted time.\n\xc2\xa0\nExample 1:\nInput: buckets = 1000, minutesToDie = 15, minutesToTest = 60\nOutput: 5\nExample 2:\nInput: buckets = 4, minutesToDie = 15, minutesToTest = 15\nOutput: 2\nExample 3:\nInput: buckets = 4, minutesToDie = 15, minutesToTest = 30\nOutput: 2\n\n\xc2\xa0\nConstraints:\n\n1 <= buckets <= 1000\n1 <=\xc2\xa0minutesToDie <=\xc2\xa0minutesToTest <= 100\n\n' b'Given string s, check constructed taking substring appending multiple copies substring together.\n\xc2\xa0\nExample 1:\nInput: = "abab"\nOutput: true\nExplanation: It substring "ab" twice.\n\nExample 2:\nInput: = "aba"\nOutput: false\n\nExample 3:\nInput: = "abcabcabcabc"\nOutput: true\nExplanation: It substring "abc" four times substring "abcabc" twice.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 104\ns consists lowercase English letters.\n\n' b'Design implement data structure Least Frequently Used (LFU) cache.\nImplement LFUCache class:\n\nLFUCache(int capacity) Initializes object capacity data structure.\nint get(int key) Gets value key key exists cache. Otherwise, returns -1.\nvoid put(int key, int value) Update value key present, inserts key already present. When cache reaches capacity, invalidate remove least frequently used key inserting new item. For problem, tie (i.e., two keys frequency), least recently used key would invalidated.\n\nTo determine least frequently used key, use counter maintained key cache. The key smallest use counter least frequently used key.\nWhen key first inserted cache, use counter set 1 (due put operation). The use counter key cache incremented either get put operation called it.\nThe functions\xc2\xa0get\xc2\xa0and\xc2\xa0put\xc2\xa0must run O(1) average time complexity.\n\xc2\xa0\nExample 1:\nInput\n["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, 3, null, -1, 3, 4]\n\nExplanation\n// cnt(x) = use counter key x\n// cache=[] show last used order tiebreakers (leftmost element recent)\nLFUCache lfu = new LFUCache(2);\nlfu.put(1, 1); // cache=[1,_], cnt(1)=1\nlfu.put(2, 2); // cache=[2,1], cnt(2)=1, cnt(1)=1\nlfu.get(1); // return 1\n // cache=[1,2], cnt(2)=1, cnt(1)=2\nlfu.put(3, 3); // 2 LFU key cnt(2)=1 smallest, invalidate 2.\n\xc2\xa0 // cache=[3,1], cnt(3)=1, cnt(1)=2\nlfu.get(2); // return -1 (not found)\nlfu.get(3); // return 3\n // cache=[3,1], cnt(3)=2, cnt(1)=2\nlfu.put(4, 4); // Both 1 3 cnt, 1 LRU, invalidate 1.\n // cache=[4,3], cnt(4)=1, cnt(3)=2\nlfu.get(1); // return -1 (not found)\nlfu.get(3); // return 3\n // cache=[3,4], cnt(4)=1, cnt(3)=3\nlfu.get(4); // return 4\n // cache=[4,3], cnt(4)=2, cnt(3)=3\n\n\xc2\xa0\nConstraints:\n\n0 <= capacity\xc2\xa0<= 104\n0 <= key <= 105\n0 <= value <= 109\nAt 2 * 105\xc2\xa0calls made get put.\n\n\xc2\xa0\n\xc2\xa0' b'The Hamming distance two integers number positions corresponding bits different.\nGiven two integers x y, return Hamming distance them.\n\xc2\xa0\nExample 1:\nInput: x = 1, = 4\nOutput: 2\nExplanation:\n1 (0 0 0 1)\n4 (0 1 0 0)\n \xe2\x86\x91 \xe2\x86\x91\nThe arrows point positions corresponding bits different.\n\nExample 2:\nInput: x = 3, = 1\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n0 <=\xc2\xa0x, <= 231 - 1\n\n' b'Given integer array nums size n, return minimum number moves required make array elements equal.\nIn one move, increment decrement element array 1.\nTest cases designed answer fit 32-bit integer.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3]\nOutput: 2\nExplanation:\nOnly two moves needed (remember move increments decrements one element):\n[1,2,3] => [2,2,3] => [2,2,2]\n\nExample 2:\nInput: nums = [1,10,2,9]\nOutput: 16\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109\n\n' b'You given row x col grid representing map grid[i][j] = 1 represents\xc2\xa0land grid[i][j] = 0 represents water.\nGrid cells connected horizontally/vertically (not diagonally). The grid completely surrounded water, exactly one island (i.e., one connected land cells).\nThe island doesn\'t "lakes", meaning water inside isn\'t connected water around island. One cell square side length 1. The grid rectangular, width height don\'t exceed 100. Determine perimeter island.\n\xc2\xa0\nExample 1:\n\nInput: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\nOutput: 16\nExplanation: The perimeter 16 yellow stripes image above.\n\nExample 2:\nInput: grid = [[1]]\nOutput: 4\n\nExample 3:\nInput: grid = [[1,0]]\nOutput: 4\n\n\xc2\xa0\nConstraints:\n\nrow == grid.length\ncol == grid[i].length\n1 <= row, col <= 100\ngrid[i][j] 0 1.\nThere exactly one island grid.\n\n' b'In "100 game" two players take turns adding, running total, integer 1 10. The player first causes running total reach exceed 100 wins.\nWhat change game players cannot re-use integers?\nFor example, two players might take turns drawing common pool numbers 1 15 without replacement reach total >= 100.\nGiven two integers maxChoosableInteger desiredTotal, return true first player move force win, otherwise, return false. Assume players play optimally.\n\xc2\xa0\nExample 1:\nInput: maxChoosableInteger = 10, desiredTotal = 11\nOutput: false\nExplanation:\nNo matter integer first player choose, first player lose.\nThe first player choose integer 1 10.\nIf first player choose 1, second player choose integers 2 10.\nThe second player win choosing 10 get total = 11, >= desiredTotal.\nSame integers chosen first player, second player always win.\n\nExample 2:\nInput: maxChoosableInteger = 10, desiredTotal = 0\nOutput: true\n\nExample 3:\nInput: maxChoosableInteger = 10, desiredTotal = 1\nOutput: true\n\n\xc2\xa0\nConstraints:\n\n1 <= maxChoosableInteger <= 20\n0 <= desiredTotal <= 300\n\n' b'We define str = [s, n] string str consists string concatenated n times.\n\nFor example, str == ["abc", 3] =="abcabcabc".\n\nWe define string s1 obtained string s2 remove characters s2 becomes s1.\n\nFor example, s1 = "abc" obtained s2 = "abdbec" based definition removing bolded underlined characters.\n\nYou given two strings s1 s2 two integers n1 n2. You two strings str1 = [s1, n1] str2 = [s2, n2].\nReturn maximum integer str = [str2, m] obtained str1.\n\xc2\xa0\nExample 1:\nInput: s1 = "acb", n1 = 4, s2 = "ab", n2 = 2\nOutput: 2\nExample 2:\nInput: s1 = "acb", n1 = 1, s2 = "acb", n2 = 1\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= s1.length, s2.length <= 100\ns1 s2 consist lowercase English letters.\n1 <= n1, n2 <= 106\n\n' b'We define string infinite wraparound string "abcdefghijklmnopqrstuvwxyz", look like this:\n\n"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".\n\nGiven string p, return number unique non-empty substrings p present s.\n\xc2\xa0\nExample 1:\nInput: p = "a"\nOutput: 1\nExplanation: Only substring "a" p s.\n\nExample 2:\nInput: p = "cac"\nOutput: 2\nExplanation: There two substrings ("a", "c") p s.\n\nExample 3:\nInput: p = "zab"\nOutput: 6\nExplanation: There six substrings ("z", "a", "b", "za", "ab", "zab") p s.\n\n\xc2\xa0\nConstraints:\n\n1 <= p.length <= 105\np consists lowercase English letters.\n\n' b'Given string queryIP, return "IPv4" IP valid IPv4 address, "IPv6" IP valid IPv6 address "Neither" IP correct IP type.\nA valid IPv4 address IP form "x1.x2.x3.x4" 0 <= xi <= 255 xi cannot contain leading zeros. For example, "192.168.1.1" "192.168.1.0" valid IPv4 addresses "192.168.01.1", "192.168.1.00", "192.168@1.1" invalid IPv4 addresses.\nA valid IPv6 address IP form "x1:x2:x3:x4:x5:x6:x7:x8" where:\n\n1 <= xi.length <= 4\nxi hexadecimal string may contain digits, lowercase English letter (\'a\' \'f\') upper-case English letters (\'A\' \'F\').\nLeading zeros allowed xi.\n\nFor example, "2001:0db8:85a3:0000:0000:8a2e:0370:7334" "2001:db8:85a3:0:0:8A2E:0370:7334" valid IPv6 addresses, "2001:0db8:85a3::8A2E:037j:7334" "02001:0db8:85a3:0000:0000:8a2e:0370:7334" invalid IPv6 addresses.\n\xc2\xa0\nExample 1:\nInput: queryIP = "172.16.254.1"\nOutput: "IPv4"\nExplanation: This valid IPv4 address, return "IPv4".\n\nExample 2:\nInput: queryIP = "2001:0db8:85a3:0:0:8A2E:0370:7334"\nOutput: "IPv6"\nExplanation: This valid IPv6 address, return "IPv6".\n\nExample 3:\nInput: queryIP = "256.256.256.256"\nOutput: "Neither"\nExplanation: This neither IPv4 address IPv6 address.\n\n\xc2\xa0\nConstraints:\n\nqueryIP consists English letters, digits characters \'.\' \':\'.\n\n' b"Given API rand7() generates uniform random integer range [1, 7], write function rand10() generates uniform random integer range [1, 10]. You call API rand7(), call API. Please use language's built-in random API.\nEach test case one internal argument n, number times implemented function rand10() called testing. Note argument passed rand10().\n\xc2\xa0\nExample 1:\nInput: n = 1\nOutput: [2]\nExample 2:\nInput: n = 2\nOutput: [2,8]\nExample 3:\nInput: n = 3\nOutput: [3,8,10]\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 105\n\n\xc2\xa0\nFollow up:\n\nWhat expected value number calls rand7() function?\nCould minimize number calls rand7()?\n\n" b'Given array strings words (without duplicates), return concatenated words given list words.\nA concatenated word defined string comprised entirely least two shorter words given array.\n\xc2\xa0\nExample 1:\nInput: words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]\nOutput: ["catsdogcats","dogcatsdog","ratcatdogcat"]\nExplanation: "catsdogcats" concatenated "cats", "dog" "cats"; \n"dogcatsdog" concatenated "dog", "cats" "dog"; \n"ratcatdogcat" concatenated "rat", "cat", "dog" "cat".\nExample 2:\nInput: words = ["cat","dog","catdog"]\nOutput: ["catdog"]\n\n\xc2\xa0\nConstraints:\n\n1 <= words.length <= 104\n0 <= words[i].length <= 30\nwords[i] consists lowercase English letters.\n0 <= sum(words[i].length) <= 105\n\n' b'You given integer array matchsticks matchsticks[i] length ith matchstick. You want use matchsticks make one square. You break stick, link up, matchstick must used exactly one time.\nReturn true make square false otherwise.\n\xc2\xa0\nExample 1:\n\nInput: matchsticks = [1,1,2,2,2]\nOutput: true\nExplanation: You form square length 2, one side square came two sticks length 1.\n\nExample 2:\nInput: matchsticks = [3,3,3,3,4]\nOutput: false\nExplanation: You cannot find way form square matchsticks.\n\n\xc2\xa0\nConstraints:\n\n1 <= matchsticks.length <= 15\n1 <= matchsticks[i] <= 108\n\n' b'You given array binary strings strs two integers n.\nReturn size largest subset strs 0\'s n 1\'s subset.\nA set x subset set elements x also elements y.\n\xc2\xa0\nExample 1:\nInput: strs = ["10","0001","111001","1","0"], = 5, n = 3\nOutput: 4\nExplanation: The largest subset 5 0\'s 3 1\'s {"10", "0001", "1", "0"}, answer 4.\nOther valid smaller subsets include {"0001", "1"} {"10", "1", "0"}.\n{"111001"} invalid subset contains 4 1\'s, greater maximum 3.\n\nExample 2:\nInput: strs = ["10","0","1"], = 1, n = 1\nOutput: 2\nExplanation: The largest subset {"0", "1"}, answer 2.\n\n\xc2\xa0\nConstraints:\n\n1 <= strs.length <= 600\n1 <= strs[i].length <= 100\nstrs[i] consists digits \'0\' \'1\'.\n1 <= m, n <= 100\n\n' b"Winter coming! During contest, first job design standard heater fixed warm radius warm houses.\nEvery house warmed, long house within heater's warm radius range.\xc2\xa0\nGiven positions houses heaters horizontal line, return minimum radius standard heaters\xc2\xa0so heaters could cover houses.\nNotice that\xc2\xa0all heaters follow radius standard, warm radius same.\n\xc2\xa0\nExample 1:\nInput: houses = [1,2,3], heaters = [2]\nOutput: 1\nExplanation: The heater placed position 2, use radius 1 standard, houses warmed.\n\nExample 2:\nInput: houses = [1,2,3,4], heaters = [1,4]\nOutput: 1\nExplanation: The two heater placed position 1 4. We need use radius 1 standard, houses warmed.\n\nExample 3:\nInput: houses = [1,5], heaters = [2]\nOutput: 3\n\n\xc2\xa0\nConstraints:\n\n1 <= houses.length, heaters.length <= 3 * 104\n1 <= houses[i], heaters[i] <= 109\n\n" b'The complement integer integer get flip 0\'s 1\'s 1\'s 0\'s binary representation.\n\nFor example, The integer 5 "101" binary complement "010" integer 2.\n\nGiven integer num, return complement.\n\xc2\xa0\nExample 1:\nInput: num = 5\nOutput: 2\nExplanation: The binary representation 5 101 (no leading zero bits), complement 010. So need output 2.\n\nExample 2:\nInput: num = 1\nOutput: 0\nExplanation: The binary representation 1 1 (no leading zero bits), complement 0. So need output 0.\n\n\xc2\xa0\nConstraints:\n\n1 <= num < 231\n\n\xc2\xa0\nNote: This question 1009: https://leetcode.com/problems/complement-of-base-10-integer/\n' b'The Hamming distance two integers number positions corresponding bits different.\nGiven integer array nums, return sum Hamming distances pairs integers nums.\n\xc2\xa0\nExample 1:\nInput: nums = [4,14,2]\nOutput: 6\nExplanation: In binary representation, 4 0100, 14 1110, 2 0010 (just\nshowing four bits relevant case).\nThe answer be:\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n\nExample 2:\nInput: nums = [4,14,4]\nOutput: 4\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n0 <= nums[i] <= 109\nThe answer given input fit 32-bit integer.\n\n' b'Given radius position center circle, implement function randPoint generates uniform random point inside circle.\nImplement Solution class:\n\nSolution(double radius, double x_center, double y_center) initializes object radius circle radius position center (x_center, y_center).\nrandPoint() returns random point inside circle. A point circumference circle considered circle. The answer returned array [x, y].\n\n\xc2\xa0\nExample 1:\nInput\n["Solution", "randPoint", "randPoint", "randPoint"]\n[[1.0, 0.0, 0.0], [], [], []]\nOutput\n[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n\nExplanation\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint(); // return [-0.02493, -0.38077]\nsolution.randPoint(); // return [0.82314, 0.38945]\nsolution.randPoint(); // return [0.36572, 0.17248]\n\n\xc2\xa0\nConstraints:\n\n0 <\xc2\xa0radius <= 108\n-107 <= x_center, y_center <= 107\nAt 3 * 104 calls made randPoint.\n\n' b'Given integer n, return largest palindromic integer represented product two n-digits integers. Since answer large, return modulo 1337.\n\xc2\xa0\nExample 1:\nInput: n = 2\nOutput: 987\nExplanation: 99 x 91 = 9009, 9009 % 1337 = 987\n\nExample 2:\nInput: n = 1\nOutput: 9\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 8\n\n' b'The median middle value ordered integer list. If size list even, middle value. So median mean two middle values.\n\nFor examples, arr = [2,3,4], median 3.\nFor examples, arr = [1,2,3,4], median (2 + 3) / 2 = 2.5.\n\nYou given integer array nums integer k. There sliding window size k moving left array right. You see k numbers window. Each time sliding window moves right one position.\nReturn median array window original array. Answers within 10-5 actual value accepted.\n\xc2\xa0\nExample 1:\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position Median\n--------------- -----\n[1 3 -1] -3 5 3 6 7 1\n 1 [3 -1 -3] 5 3 6 7 -1\n 1 3 [-1 -3 5] 3 6 7 -1\n 1 3 -1 [-3 5 3] 6 7 3\n 1 3 -1 -3 [5 3 6] 7 5\n 1 3 -1 -3 5 [3 6 7] 6\n\nExample 2:\nInput: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]\n\n\xc2\xa0\nConstraints:\n\n1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n\n' b'A magical string consists \'1\' \'2\' obeys following rules:\n\nThe string magical concatenating number contiguous occurrences characters \'1\' \'2\' generates string itself.\n\nThe first elements = "1221121221221121122\xe2\x80\xa6\xe2\x80\xa6". If group consecutive 1\'s 2\'s s, "1 22 11 2 1 22 1 22 11 2 11 22 ......" occurrences 1\'s 2\'s group "1 2 2 1 1 2 1 2 2 1 2 2 ......". You see occurrence sequence itself.\nGiven integer n, return number 1\'s first n number magical string s.\n\xc2\xa0\nExample 1:\nInput: n = 6\nOutput: 3\nExplanation: The first 6 elements magical string "122112" contains three 1\'s, return 3.\n\nExample 2:\nInput: n = 1\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 105\n\n' b'You given license key represented string consists alphanumeric characters dashes. The string separated n + 1 groups n dashes. You also given integer k.\nWe want reformat string group contains exactly k characters, except first group, could shorter k still must contain least one character. Furthermore, must dash inserted two groups, convert lowercase letters uppercase.\nReturn reformatted license key.\n\xc2\xa0\nExample 1:\nInput: = "5F3Z-2e-9-w", k = 4\nOutput: "5F3Z-2E9W"\nExplanation: The string split two parts, part 4 characters.\nNote two extra dashes needed removed.\n\nExample 2:\nInput: = "2-5g-3-J", k = 2\nOutput: "2-5G-3J"\nExplanation: The string split three parts, part 2 characters except first part could shorter mentioned above.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 105\ns consists English letters, digits, dashes \'-\'.\n1 <= k <= 104\n\n' b'Given integer n represented string, return smallest good base n.\nWe call k >= 2 good base n, digits n base k 1\'s.\n\xc2\xa0\nExample 1:\nInput: n = "13"\nOutput: "3"\nExplanation: 13 base 3 111.\n\nExample 2:\nInput: n = "4681"\nOutput: "8"\nExplanation: 4681 base 8 11111.\n\nExample 3:\nInput: n = "1000000000000000000"\nOutput: "999999999999999999"\nExplanation: 1000000000000000000 base 999999999999999999 11.\n\n\xc2\xa0\nConstraints:\n\nn integer range [3, 1018].\nn contain leading zeros.\n\n' b"Given binary array nums, return maximum number consecutive 1's array.\n\xc2\xa0\nExample 1:\nInput: nums = [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits last three digits consecutive 1s. The maximum number consecutive 1s 3.\n\nExample 2:\nInput: nums = [1,0,1,1,0,1]\nOutput: 2\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\nnums[i] either 0 1.\n\n" b'You given integer array nums. Two players playing game array: player 1 player 2.\nPlayer 1 player 2 take turns, player 1 starting first. Both players start game score 0. At turn, player takes one numbers either end array (i.e., nums[0] nums[nums.length - 1]) reduces size array 1. The player adds chosen number score. The game ends elements array.\nReturn true Player 1 win game. If scores players equal, player 1 still winner, also return true. You may assume players playing optimally.\n\xc2\xa0\nExample 1:\nInput: nums = [1,5,2]\nOutput: false\nExplanation: Initially, player 1 choose 1 2. \nIf chooses 2 (or 1), player 2 choose 1 (or 2) 5. If player 2 chooses 5, player 1 left 1 (or 2). \nSo, final score player 1 1 + 2 = 3, player 2 5. \nHence, player 1 never winner need return false.\n\nExample 2:\nInput: nums = [1,5,233,7]\nOutput: true\nExplanation: Player 1 first chooses 1. Then player 2 choose 5 7. No matter number player 2 choose, player 1 choose 233.\nFinally, player 1 score (234) player 2 (12), need return True representing player1 win.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 20\n0 <= nums[i] <= 107\n\n' b'You playing variation game Zuma.\nIn variation Zuma, single row colored balls board, ball colored red \'R\', yellow \'Y\', blue \'B\', green \'G\', white \'W\'. You also several colored balls hand.\nYour goal clear balls board. On turn:\n\nPick ball hand insert two balls row either end row.\nIf group three consecutive balls color, remove group balls board.\n\t\nIf removal causes groups three color form, continue removing group none left.\n\n\nIf balls board, win game.\nRepeat process either win balls hand.\n\nGiven string board, representing row balls board, string hand, representing balls hand, return minimum number balls insert clear balls board. If cannot clear balls board using balls hand, return -1.\n\xc2\xa0\nExample 1:\nInput: board = "WRRBBW", hand = "RB"\nOutput: -1\nExplanation: It impossible clear balls. The best is:\n- Insert \'R\' board becomes WRRRBBW. WRRRBBW -> WBBW.\n- Insert \'B\' board becomes WBBBW. WBBBW -> WW.\nThere still balls remaining board, balls insert.\nExample 2:\nInput: board = "WWRRBBWW", hand = "WRBRW"\nOutput: 2\nExplanation: To make board empty:\n- Insert \'R\' board becomes WWRRRBBWW. WWRRRBBWW -> WWBBWW.\n- Insert \'B\' board becomes WWBBBWW. WWBBBWW -> WWWW -> empty.\n2 balls hand needed clear board.\n\nExample 3:\nInput: board = "G", hand = "GGGGG"\nOutput: 2\nExplanation: To make board empty:\n- Insert \'G\' board becomes GG.\n- Insert \'G\' board becomes GGG. GGG -> empty.\n2 balls hand needed clear board.\n\n\xc2\xa0\nConstraints:\n\n1 <= board.length <= 16\n1 <= hand.length <= 5\nboard hand consist characters \'R\', \'Y\', \'B\', \'G\', \'W\'.\nThe initial row balls board groups three consecutive balls color.\n\n' b'Given integer array nums, return different possible increasing subsequences given array least two elements. You may return answer order.\nThe given array may contain duplicates, two equal integers also considered special case increasing sequence.\n\xc2\xa0\nExample 1:\nInput: nums = [4,6,7,7]\nOutput: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\n\nExample 2:\nInput: nums = [4,4,3,2,1]\nOutput: [[4,4]]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 15\n-100 <= nums[i] <= 100\n\n' b"A web developer needs know design web page's size. So, given specific rectangular web page\xe2\x80\x99s area, job design rectangular web page, whose length L width W satisfy following requirements:\n\nThe area rectangular web page designed must equal given target area.\nThe width W larger length L, means L >= W.\nThe difference length L width W small possible.\n\nReturn array [L, W] L W length width the\xc2\xa0web page designed sequence.\n\xc2\xa0\nExample 1:\nInput: area = 4\nOutput: [2,2]\nExplanation: The target area 4, possible ways construct [1,4], [2,2], [4,1]. \nBut according requirement 2, [1,4] illegal; according requirement 3, [4,1] optimal compared [2,2]. So length L 2, width W 2.\n\nExample 2:\nInput: area = 37\nOutput: [37,1]\n\nExample 3:\nInput: area = 122122\nOutput: [427,286]\n\n\xc2\xa0\nConstraints:\n\n1 <= area <= 107\n\n" b'Given x n integer matrix heightMap representing height unit cell 2D elevation map, return volume water trap raining.\n\xc2\xa0\nExample 1:\n\nInput: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\nOutput: 4\nExplanation: After rain, water trapped blocks.\nWe two small ponds 1 3 units trapped.\nThe total volume water trapped 4.\n\nExample 2:\n\nInput: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\nOutput: 10\n\n\xc2\xa0\nConstraints:\n\nm == heightMap.length\nn == heightMap[i].length\n1 <= m, n <= 200\n0 <= heightMap[i][j] <= 2 * 104\n\n' b'You given integer array nums integer target.\nYou want build expression nums adding one symbols \'+\' \'-\' integer nums concatenate integers.\n\nFor example, nums = [2, 1], add \'+\' 2 \'-\' 1 concatenate build expression "+2-1".\n\nReturn number different expressions build, evaluates target.\n\xc2\xa0\nExample 1:\nInput: nums = [1,1,1,1,1], target = 3\nOutput: 5\nExplanation: There 5 ways assign symbols make sum nums target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n\nExample 2:\nInput: nums = [1], target = 1\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 20\n0 <= nums[i] <= 1000\n0 <= sum(nums[i]) <= 1000\n-1000 <= target <= 1000\n\n' b"Our hero Teemo attacking enemy Ashe poison attacks! When Teemo attacks Ashe, Ashe gets poisoned exactly duration seconds. More formally, attack second mean Ashe poisoned inclusive time interval [t, + duration - 1]. If Teemo attacks poison effect ends, timer reset, poison effect end duration seconds new attack.\nYou given non-decreasing integer array timeSeries, timeSeries[i] denotes Teemo attacks Ashe second timeSeries[i], integer duration.\nReturn total number seconds Ashe poisoned.\n\xc2\xa0\nExample 1:\nInput: timeSeries = [1,4], duration = 2\nOutput: 4\nExplanation: Teemo's attacks Ashe go follows:\n- At second 1, Teemo attacks, Ashe poisoned seconds 1 2.\n- At second 4, Teemo attacks, Ashe poisoned seconds 4 5.\nAshe poisoned seconds 1, 2, 4, 5, 4 seconds total.\n\nExample 2:\nInput: timeSeries = [1,2], duration = 2\nOutput: 3\nExplanation: Teemo's attacks Ashe go follows:\n- At second 1, Teemo attacks, Ashe poisoned seconds 1 2.\n- At second 2 however, Teemo attacks resets poison timer. Ashe poisoned seconds 2 3.\nAshe poisoned seconds 1, 2, 3, 3 seconds total.\n\xc2\xa0\nConstraints:\n\n1 <= timeSeries.length <= 104\n0 <= timeSeries[i], duration <= 107\ntimeSeries sorted non-decreasing order.\n\n" b'The next greater element element x array first greater element right x array.\nYou given two distinct 0-indexed integer arrays nums1 nums2, nums1 subset nums2.\nFor 0 <= < nums1.length, find index j nums1[i] == nums2[j] determine next greater element nums2[j] nums2. If next greater element, answer query -1.\nReturn array ans length nums1.length ans[i] next greater element described above.\n\xc2\xa0\nExample 1:\nInput: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element value nums1 follows:\n- 4 underlined nums2 = [1,3,4,2]. There next greater element, answer -1.\n- 1 underlined nums2 = [1,3,4,2]. The next greater element 3.\n- 2 underlined nums2 = [1,3,4,2]. There next greater element, answer -1.\n\nExample 2:\nInput: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element value nums1 follows:\n- 2 underlined nums2 = [1,2,3,4]. The next greater element 3.\n- 4 underlined nums2 = [1,2,3,4]. There next greater element, answer -1.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers nums1 nums2 unique.\nAll integers nums1 also appear nums2.\n\n\xc2\xa0\nFollow up: Could find O(nums1.length + nums2.length) solution?' b'You given array non-overlapping axis-aligned rectangles rects rects[i] = [ai, bi, xi, yi] indicates (ai, bi) bottom-left corner point ith rectangle (xi, yi) top-right corner point ith rectangle. Design algorithm pick random integer point inside space covered one given rectangles. A point perimeter rectangle included space covered rectangle.\nAny integer point inside space covered one given rectangles equally likely returned.\nNote integer point point integer coordinates.\nImplement Solution class:\n\nSolution(int[][] rects) Initializes object given rectangles rects.\nint[] pick() Returns random integer point [u, v] inside space covered one given rectangles.\n\n\xc2\xa0\nExample 1:\n\nInput\n["Solution", "pick", "pick", "pick", "pick", "pick"]\n[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]\nOutput\n[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]\n\nExplanation\nSolution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);\nsolution.pick(); // return [1, -2]\nsolution.pick(); // return [1, -1]\nsolution.pick(); // return [-1, -2]\nsolution.pick(); // return [-2, -2]\nsolution.pick(); // return [0, 0]\n\n\xc2\xa0\nConstraints:\n\n1 <= rects.length <= 100\nrects[i].length == 4\n-109 <= ai < xi <= 109\n-109 <= bi < yi <= 109\nxi - ai <= 2000\nyi - bi <= 2000\nAll rectangles overlap.\nAt 104 calls made pick.\n\n' b'Given x n matrix mat, return array elements array diagonal order.\n\xc2\xa0\nExample 1:\n\nInput: mat = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,4,7,5,3,6,8,9]\n\nExample 2:\nInput: mat = [[1,2],[3,4]]\nOutput: [1,2,3,4]\n\n\xc2\xa0\nConstraints:\n\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 104\n1 <= * n <= 104\n-105 <= mat[i][j] <= 105\n\n' b'Given array strings words, return words typed using letters alphabet one row American keyboard like image below.\nIn American keyboard:\n\nthe first row consists characters "qwertyuiop",\nthe second row consists characters "asdfghjkl", and\nthe third row consists characters "zxcvbnm".\n\n\n\xc2\xa0\nExample 1:\nInput: words = ["Hello","Alaska","Dad","Peace"]\nOutput: ["Alaska","Dad"]\n\nExample 2:\nInput: words = ["omk"]\nOutput: []\n\nExample 3:\nInput: words = ["adsdf","sfd"]\nOutput: ["adsdf","sfd"]\n\n\xc2\xa0\nConstraints:\n\n1 <= words.length <= 20\n1 <= words[i].length <= 100\nwords[i] consists English letters (both lowercase uppercase).\xc2\xa0\n\n' b"Given root binary search tree (BST) duplicates, return mode(s) (i.e., frequently occurred element) it.\nIf tree one mode, return order.\nAssume BST defined follows:\n\nThe left subtree node contains nodes keys less equal node's key.\nThe right subtree node contains nodes keys greater equal node's key.\nBoth left right subtrees must also binary search trees.\n\n\xc2\xa0\nExample 1:\n\nInput: root = [1,null,2,2]\nOutput: [2]\n\nExample 2:\nInput: root = [0]\nOutput: [0]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 104].\n-105 <= Node.val <= 105\n\n\xc2\xa0\nFollow up: Could without using extra space? (Assume implicit stack space incurred due recursion count)." b'Suppose LeetCode start IPO soon. In order sell good price shares Venture Capital, LeetCode would like work projects increase capital IPO. Since limited resources, finish k distinct projects IPO. Help LeetCode design best way maximize total capital finishing k distinct projects.\nYou given n projects ith project pure profit profits[i] minimum capital capital[i] needed start it.\nInitially, w capital. When finish project, obtain pure profit profit added total capital.\nPick list k distinct projects given projects maximize final capital, return final maximized capital.\nThe answer guaranteed fit 32-bit signed integer.\n\xc2\xa0\nExample 1:\nInput: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\nOutput: 4\nExplanation: Since initial capital 0, start project indexed 0.\nAfter finishing obtain profit 1 capital becomes 1.\nWith capital 1, either start project indexed 1 project indexed 2.\nSince choose 2 projects, need finish project indexed 2 get maximum capital.\nTherefore, output final maximized capital, 0 + 1 + 3 = 4.\n\nExample 2:\nInput: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\nOutput: 6\n\n\xc2\xa0\nConstraints:\n\n1 <= k <= 105\n0 <= w <= 109\nn == profits.length\nn == capital.length\n1 <= n <= 105\n0 <= profits[i] <= 104\n0 <= capital[i] <= 109\n\n' b"Given circular integer array nums (i.e., next element nums[nums.length - 1] nums[0]), return next greater number every element nums.\nThe next greater number number x first greater number traversing-order next array, means could search circularly find next greater number. If exist, return -1 number.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,1]\nOutput: [2,-1,2]\nExplanation: The first 1's next greater number 2; \nThe number 2 can't find next greater number. \nThe second 1's next greater number needs search circularly, also 2.\n\nExample 2:\nInput: nums = [1,2,3,4,3]\nOutput: [2,3,4,-1,4]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n-109 <= nums[i] <= 109\n\n" b'Given integer num, return string base 7 representation.\n\xc2\xa0\nExample 1:\nInput: num = 100\nOutput: "202"\nExample 2:\nInput: num = -7\nOutput: "-10"\n\n\xc2\xa0\nConstraints:\n\n-107 <= num <= 107\n\n' b'You given integer array score size n, score[i] score ith athlete competition. All scores guaranteed unique.\nThe athletes placed based scores, 1st place athlete highest score, 2nd place athlete 2nd highest score, on. The placement athlete determines rank:\n\nThe 1st place athlete\'s rank "Gold Medal".\nThe 2nd place athlete\'s rank "Silver Medal".\nThe 3rd place athlete\'s rank "Bronze Medal".\nFor 4th place nth place athlete, rank placement number (i.e., xth place athlete\'s rank "x").\n\nReturn array answer size n answer[i] rank ith athlete.\n\xc2\xa0\nExample 1:\nInput: score = [5,4,3,2,1]\nOutput: ["Gold Medal","Silver Medal","Bronze Medal","4","5"]\nExplanation: The placements [1st, 2nd, 3rd, 4th, 5th].\nExample 2:\nInput: score = [10,3,8,9,4]\nOutput: ["Gold Medal","5","Bronze Medal","Silver Medal","4"]\nExplanation: The placements [1st, 5th, 3rd, 2nd, 4th].\n\n\n\xc2\xa0\nConstraints:\n\nn == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll values score unique.\n\n' b'A perfect number positive integer equal sum positive divisors, excluding number itself. A divisor integer x integer divide x evenly.\nGiven integer n, return true n perfect number, otherwise return false.\n\xc2\xa0\nExample 1:\nInput: num = 28\nOutput: true\nExplanation: 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, 14 divisors 28.\n\nExample 2:\nInput: num = 7\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= num <= 108\n\n' b'Given root binary tree, return frequent subtree sum. If tie, return values highest frequency order.\nThe subtree sum node defined sum node values formed subtree rooted node (including node itself).\n\xc2\xa0\nExample 1:\n\nInput: root = [5,2,-3]\nOutput: [2,-3,4]\n\nExample 2:\n\nInput: root = [5,2,-5]\nOutput: [2]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 104].\n-105 <= Node.val <= 105\n\n' b'The Fibonacci numbers, commonly denoted F(n) form sequence, called Fibonacci sequence, number sum two preceding ones, starting 0 1. That is,\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), n > 1.\n\nGiven n, calculate F(n).\n\xc2\xa0\nExample 1:\nInput: n = 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.\n\nExample 2:\nInput: n = 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.\n\nExample 3:\nInput: n = 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3.\n\n\xc2\xa0\nConstraints:\n\n0 <= n <= 30\n\n' b'SQL Schema' b'Given root binary tree, return leftmost value last row tree.\n\xc2\xa0\nExample 1:\n\nInput: root = [2,1,3]\nOutput: 1\n\nExample 2:\n\nInput: root = [1,2,3,4,null,5,6,null,null,7]\nOutput: 7\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 104].\n-231 <= Node.val <= 231 - 1\n\n' b'In video game Fallout 4, quest "Road Freedom" requires players reach metal dial called "Freedom Trail Ring" use dial spell specific keyword open door.\nGiven string ring represents code engraved outer ring another string key represents keyword needs spelled, return minimum number steps spell characters keyword.\nInitially, first character ring aligned "12:00" direction. You spell characters key one one rotating ring clockwise anticlockwise make character string key aligned "12:00" direction pressing center button.\nAt stage rotating ring spell key character key[i]:\n\nYou rotate ring clockwise anticlockwise one place, counts one step. The final purpose rotation align one ring\'s characters "12:00" direction, character must equal key[i].\nIf character key[i] aligned "12:00" direction, press center button spell, also counts one step. After pressing, could begin spell next character key (next stage). Otherwise, finished spelling.\n\n\xc2\xa0\nExample 1:\n\nInput: ring = "godding", key = "gd"\nOutput: 4\nExplanation:\nFor first key character \'g\', since already place, need 1 step spell character. \nFor second key character \'d\', need rotate ring "godding" anticlockwise two steps make become "ddinggo".\nAlso, need 1 step spelling.\nSo final output 4.\n\nExample 2:\nInput: ring = "godding", key = "godding"\nOutput: 13\n\n\xc2\xa0\nConstraints:\n\n1 <= ring.length, key.length <= 100\nring key consist lower case English letters.\nIt guaranteed key could always spelled rotating ring.\n\n' b'Given root binary tree, return array largest value row tree (0-indexed).\n\xc2\xa0\nExample 1:\n\nInput: root = [1,3,2,5,3,null,9]\nOutput: [1,3,9]\n\nExample 2:\nInput: root = [1,2,3]\nOutput: [1,3]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 104].\n-231 <= Node.val <= 231 - 1\n\n' b'Given string s, find longest palindromic subsequence\'s length s.\nA subsequence sequence derived another sequence deleting elements without changing order remaining elements.\n\xc2\xa0\nExample 1:\nInput: = "bbbab"\nOutput: 4\nExplanation: One possible longest palindromic subsequence "bbbb".\n\nExample 2:\nInput: = "cbbd"\nOutput: 2\nExplanation: One possible longest palindromic subsequence "bb".\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 1000\ns consists lowercase English letters.\n\n' b"You n super washing machines line. Initially, washing machine dresses empty.\nFor move, could choose (1 <= <= n) washing machines, pass one dress washing machine one adjacent washing machines time.\nGiven integer array machines representing number dresses washing machine left right line, return minimum number moves make washing machines number dresses. If possible it, return -1.\n\xc2\xa0\nExample 1:\nInput: machines = [1,0,5]\nOutput: 3\nExplanation:\n1st move: 1 0 <-- 5 => 1 1 4\n2nd move: 1 <-- 1 <-- 4 => 2 1 3\n3rd move: 2 1 <-- 3 => 2 2 2\n\nExample 2:\nInput: machines = [0,3,0]\nOutput: 2\nExplanation:\n1st move: 0 <-- 3 0 => 1 2 0\n2nd move: 1 2 --> 0 => 1 1 1\n\nExample 3:\nInput: machines = [0,2,0]\nOutput: -1\nExplanation:\nIt's impossible make three washing machines number dresses.\n\n\xc2\xa0\nConstraints:\n\nn == machines.length\n1 <= n <= 104\n0 <= machines[i] <= 105\n\n" b'You given integer array coins representing coins different denominations integer amount representing total amount money.\nReturn number combinations make amount. If amount money cannot made combination coins, return 0.\nYou may assume infinite number kind coin.\nThe answer guaranteed fit signed 32-bit integer.\n\xc2\xa0\nExample 1:\nInput: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: four ways make amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n\nExample 2:\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: amount 3 cannot made coins 2.\n\nExample 3:\nInput: amount = 10, coins = [10]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= coins.length <= 300\n1 <= coins[i] <= 5000\nAll values coins unique.\n0 <= amount <= 5000\n\n' b'There x n binary grid matrix values set 0 initially. Design algorithm randomly pick index (i, j) matrix[i][j] == 0 flips 1. All indices (i, j) matrix[i][j] == 0 equally likely returned.\nOptimize algorithm minimize number calls made built-in random function language optimize time space complexity.\nImplement Solution class:\n\nSolution(int m, int n) Initializes object size binary matrix n.\nint[] flip() Returns random index [i, j] matrix matrix[i][j] == 0 flips 1.\nvoid reset() Resets values matrix 0.\n\n\xc2\xa0\nExample 1:\nInput\n["Solution", "flip", "flip", "flip", "reset", "flip"]\n[[3, 1], [], [], [], [], []]\nOutput\n[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]\n\nExplanation\nSolution solution = new Solution(3, 1);\nsolution.flip(); // return [1, 0], [0,0], [1,0], [2,0] equally likely returned.\nsolution.flip(); // return [2, 0], Since [1,0] returned, [2,0] [0,0]\nsolution.flip(); // return [0, 0], Based previously returned indices, [0,0] returned.\nsolution.reset(); // All values reset 0 returned.\nsolution.flip(); // return [2, 0], [0,0], [1,0], [2,0] equally likely returned.\n\n\xc2\xa0\nConstraints:\n\n1 <= m, n <= 104\nThere least one free cell call flip.\nAt 1000 calls made flip reset.\n\n' b'We define usage capitals word right one following cases holds:\n\nAll letters word capitals, like "USA".\nAll letters word capitals, like "leetcode".\nOnly first letter word capital, like "Google".\n\nGiven string word, return true usage capitals right.\n\xc2\xa0\nExample 1:\nInput: word = "USA"\nOutput: true\nExample 2:\nInput: word = "FlaG"\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= word.length <= 100\nword consists lowercase uppercase English letters.\n\n' b'Given two strings b, return length longest uncommon subsequence b. If longest uncommon subsequence exist, return -1.\nAn uncommon subsequence two strings string subsequence one other.\nA subsequence string string obtained deleting number characters s.\n\nFor example, "abc" subsequence "aebdc" delete underlined characters "aebdc" get "abc". Other subsequences "aebdc" include "aebdc", "aeb", "" (empty string).\n\n\xc2\xa0\nExample 1:\nInput: = "aba", b = "cdc"\nOutput: 3\nExplanation: One longest uncommon subsequence "aba" "aba" subsequence "aba" "cdc".\nNote "cdc" also longest uncommon subsequence.\n\nExample 2:\nInput: = "aaa", b = "bbb"\nOutput: 3\nExplanation:\xc2\xa0The longest uncommon subsequences "aaa" "bbb".\n\nExample 3:\nInput: = "aaa", b = "aaa"\nOutput: -1\nExplanation:\xc2\xa0Every subsequence string also subsequence string b. Similarly, every subsequence string b also subsequence string a.\n\n\xc2\xa0\nConstraints:\n\n1 <= a.length, b.length <= 100\na b consist lower-case English letters.\n\n' b'Given array strings strs, return length longest uncommon subsequence them. If longest uncommon subsequence exist, return -1.\nAn uncommon subsequence array strings string subsequence one string others.\nA subsequence string string obtained deleting number characters s.\n\nFor example, "abc" subsequence "aebdc" delete underlined characters "aebdc" get "abc". Other subsequences "aebdc" include "aebdc", "aeb", "" (empty string).\n\n\xc2\xa0\nExample 1:\nInput: strs = ["aba","cdc","eae"]\nOutput: 3\nExample 2:\nInput: strs = ["aaa","aaa","aa"]\nOutput: -1\n\n\xc2\xa0\nConstraints:\n\n2 <= strs.length <= 50\n1 <= strs[i].length <= 10\nstrs[i] consists lowercase English letters.\n\n' b'Given integer array nums integer k, return true nums continuous subarray size least two whose elements sum multiple k, false otherwise.\nAn integer x multiple k exists integer n x = n * k. 0 always multiple k.\n\xc2\xa0\nExample 1:\nInput: nums = [23,2,4,6,7], k = 6\nOutput: true\nExplanation: [2, 4] continuous subarray size 2 whose elements sum 6.\n\nExample 2:\nInput: nums = [23,2,6,4,7], k = 6\nOutput: true\nExplanation: [23, 2, 6, 4, 7] continuous subarray size 5 whose elements sum 42.\n42 multiple 6 42 = 7 * 6 7 integer.\n\nExample 3:\nInput: nums = [23,2,6,4,7], k = 13\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 109\n0 <= sum(nums[i]) <= 231 - 1\n1 <= k <= 231 - 1\n\n' b'Given string string array dictionary, return longest string dictionary formed deleting given string characters. If one possible result, return longest word smallest lexicographical order. If possible result, return empty string.\n\xc2\xa0\nExample 1:\nInput: = "abpcplea", dictionary = ["ale","apple","monkey","plea"]\nOutput: "apple"\n\nExample 2:\nInput: = "abpcplea", dictionary = ["a","b","c"]\nOutput: "a"\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 1000\n1 <= dictionary.length <= 1000\n1 <= dictionary[i].length <= 1000\ns dictionary[i] consist lowercase English letters.\n\n' b'Given binary array nums, return maximum length contiguous subarray equal number 0 1.\n\xc2\xa0\nExample 1:\nInput: nums = [0,1]\nOutput: 2\nExplanation: [0, 1] longest contiguous subarray equal number 0 1.\n\nExample 2:\nInput: nums = [0,1,0]\nOutput: 2\nExplanation: [0, 1] (or [1, 0]) longest contiguous subarray equal number 0 1.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\nnums[i] either 0 1.\n\n' b'Suppose n integers labeled 1 n. A permutation n integers perm (1-indexed) considered beautiful arrangement every (1 <= <= n), either following true:\n\nperm[i] divisible i.\ni divisible perm[i].\n\nGiven integer n, return number beautiful arrangements construct.\n\xc2\xa0\nExample 1:\nInput: n = 2\nOutput: 2\nExplanation: \nThe first beautiful arrangement [1,2]:\n - perm[1] = 1 divisible = 1\n - perm[2] = 2 divisible = 2\nThe second beautiful arrangement [2,1]:\n - perm[1] = 2 divisible = 1\n - = 2 divisible perm[2] = 1\n\nExample 2:\nInput: n = 1\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 15\n\n' b'You given 0-indexed array positive integers w w[i] describes weight ith index.\nYou need implement function pickIndex(), randomly picks index range [0, w.length - 1] (inclusive) returns it. The probability picking index w[i] / sum(w).\n\nFor example, w = [1, 3], probability picking index 0 1 / (1 + 3) = 0.25 (i.e., 25%), probability picking index 1 3 / (1 + 3) = 0.75 (i.e., 75%).\n\n\xc2\xa0\nExample 1:\nInput\n["Solution","pickIndex"]\n[[[1]],[]]\nOutput\n[null,0]\n\nExplanation\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // return 0. The option return 0 since one element w.\n\nExample 2:\nInput\n["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]\n[[[1,3]],[],[],[],[],[]]\nOutput\n[null,1,1,1,1,0]\n\nExplanation\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // return 1. It returning second element (index = 1) probability 3/4.\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 0. It returning first element (index = 0) probability 1/4.\n\nSince randomization problem, multiple answers allowed.\nAll following outputs considered correct:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\nand on.\n\n\xc2\xa0\nConstraints:\n\n1 <= w.length <= 104\n1 <= w[i] <= 105\npickIndex called 104 times.\n\n' b'Let\'s play minesweeper game (Wikipedia, online game)!\nYou given x n char matrix board representing game board where:\n\n\'M\' represents unrevealed mine,\n\'E\' represents unrevealed empty square,\n\'B\' represents revealed blank square adjacent mines (i.e., above, below, left, right, 4 diagonals),\ndigit (\'1\' \'8\') represents many mines adjacent revealed square, and\n\'X\' represents revealed mine.\n\nYou also given integer array click click = [clickr, clickc] represents next click position among unrevealed squares (\'M\' \'E\').\nReturn board revealing position according following rules:\n\nIf mine \'M\' revealed, game over. You change \'X\'.\nIf empty square \'E\' adjacent mines revealed, change revealed blank \'B\' adjacent unrevealed squares revealed recursively.\nIf empty square \'E\' least one adjacent mine revealed, change digit (\'1\' \'8\') representing number adjacent mines.\nReturn board squares revealed.\n\n\xc2\xa0\nExample 1:\n\nInput: board = [["E","E","E","E","E"],["E","E","M","E","E"],["E","E","E","E","E"],["E","E","E","E","E"]], click = [3,0]\nOutput: [["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]\n\nExample 2:\n\nInput: board = [["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]], click = [1,2]\nOutput: [["B","1","E","1","B"],["B","1","X","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]\n\n\xc2\xa0\nConstraints:\n\nm == board.length\nn == board[i].length\n1 <= m, n <= 50\nboard[i][j] either \'M\', \'E\', \'B\', digit \'1\' \'8\'.\nclick.length == 2\n0 <= clickr < m\n0 <= clickc < n\nboard[clickr][clickc] either \'M\' \'E\'.\n\n' b'Given root Binary Search Tree (BST), return minimum absolute difference values two different nodes tree.\n\xc2\xa0\nExample 1:\n\nInput: root = [4,2,6,1,3]\nOutput: 1\n\nExample 2:\n\nInput: root = [1,0,48,null,null,12,49]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [2, 104].\n0 <= Node.val <= 105\n\n\xc2\xa0\nNote: This question 783: https://leetcode.com/problems/minimum-distance-between-bst-nodes/\n' b'Given array integers nums integer k, return number unique k-diff pairs array.\nA k-diff pair integer pair (nums[i], nums[j]), following true:\n\n0 <= i, j < nums.length\ni != j\nnums[i] - nums[j] == k\n\nNotice |val| denotes absolute value val.\n\xc2\xa0\nExample 1:\nInput: nums = [3,1,4,1,5], k = 2\nOutput: 2\nExplanation: There two 2-diff pairs array, (1, 3) (3, 5).\nAlthough two 1s input, return number unique pairs.\n\nExample 2:\nInput: nums = [1,2,3,4,5], k = 1\nOutput: 4\nExplanation: There four 1-diff pairs array, (1, 2), (2, 3), (3, 4) (4, 5).\n\nExample 3:\nInput: nums = [1,3,1,5,4], k = 0\nOutput: 1\nExplanation: There one 0-diff pair array, (1, 1).\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n-107 <= nums[i] <= 107\n0 <= k <= 107\n\n' b'Note: This companion problem System Design problem: Design TinyURL.\nTinyURL URL shortening service enter URL https://leetcode.com/problems/design-tinyurl returns short URL http://tinyurl.com/4e9iAk. Design class encode URL decode tiny URL.\nThere restriction encode/decode algorithm work. You need ensure URL encoded tiny URL tiny URL decoded original URL.\nImplement Solution class:\n\nSolution() Initializes object system.\nString encode(String longUrl) Returns tiny URL given longUrl.\nString decode(String shortUrl) Returns original long URL given shortUrl. It guaranteed given shortUrl encoded object.\n\n\xc2\xa0\nExample 1:\nInput: url = "https://leetcode.com/problems/design-tinyurl"\nOutput: "https://leetcode.com/problems/design-tinyurl"\n\nExplanation:\nSolution obj = new Solution();\nstring tiny = obj.encode(url); // returns encoded tiny url.\nstring ans = obj.decode(tiny); // returns original url deconding it.\n\n\xc2\xa0\nConstraints:\n\n1 <= url.length <= 104\nurl guranteed valid URL.\n\n' b'A complex number represented string form "real+imaginaryi" where:\n\nreal real part integer range [-100, 100].\nimaginary imaginary part integer range [-100, 100].\ni2 == -1.\n\nGiven two complex numbers num1 num2 strings, return string complex number represents multiplications.\n\xc2\xa0\nExample 1:\nInput: num1 = "1+1i", num2 = "1+1i"\nOutput: "0+2i"\nExplanation: (1 + i) * (1 + i) = 1 + i2 + 2 * = 2i, need convert form 0+2i.\n\nExample 2:\nInput: num1 = "1+-1i", num2 = "1+-1i"\nOutput: "0+-2i"\nExplanation: (1 - i) * (1 - i) = 1 + i2 - 2 * = -2i, need convert form 0+-2i.\n\n\xc2\xa0\nConstraints:\n\nnum1 num2 valid complex numbers.\n\n' b"Given root Binary Search Tree (BST), convert Greater Tree every key original BST changed original key plus sum keys greater original key BST.\nAs reminder, binary search tree tree satisfies constraints:\n\nThe left subtree node contains nodes keys less node's key.\nThe right subtree node contains nodes keys greater node's key.\nBoth left right subtrees must also binary search trees.\n\n\xc2\xa0\nExample 1:\n\nInput: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\nOutput: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\nExample 2:\nInput: root = [0,null,1]\nOutput: [1,null,1]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 104].\n-104 <= Node.val <= 104\nAll values tree unique.\nroot guaranteed valid binary search tree.\n\n\xc2\xa0\nNote: This question 1038: https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/\n" b'Given list 24-hour clock time points "HH:MM" format, return minimum minutes difference two time-points list.\n\xc2\xa0\nExample 1:\nInput: timePoints = ["23:59","00:00"]\nOutput: 1\nExample 2:\nInput: timePoints = ["00:00","23:59","00:00"]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n2 <= timePoints.length <= 2 * 104\ntimePoints[i] format "HH:MM".\n\n' b'You given sorted array consisting integers every element appears exactly twice, except one element appears exactly once.\nReturn single element appears once.\nYour solution must run O(log n) time O(1) space.\n\xc2\xa0\nExample 1:\nInput: nums = [1,1,2,3,3,4,4,8,8]\nOutput: 2\nExample 2:\nInput: nums = [3,3,7,7,10,11,11]\nOutput: 10\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 105\n\n' b'Given string integer k, reverse first k characters every 2k characters counting start string.\nIf fewer k characters left, reverse them. If less 2k greater equal k characters, reverse first k characters leave original.\n\xc2\xa0\nExample 1:\nInput: = "abcdefg", k = 2\nOutput: "bacdfeg"\nExample 2:\nInput: = "abcd", k = 2\nOutput: "bacd"\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 104\ns consists lowercase English letters.\n1 <= k <= 104\n\n' b'Given x n binary matrix mat, return distance nearest 0 cell.\nThe distance two adjacent cells 1.\n\xc2\xa0\nExample 1:\n\nInput: mat = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: [[0,0,0],[0,1,0],[0,0,0]]\n\nExample 2:\n\nInput: mat = [[0,0,0],[0,1,0],[1,1,1]]\nOutput: [[0,0,0],[0,1,0],[1,2,1]]\n\n\xc2\xa0\nConstraints:\n\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 104\n1 <= * n <= 104\nmat[i][j] either 0 1.\nThere least one 0 mat.\n\n' b'Given root binary tree, return length diameter tree.\nThe diameter binary tree length longest path two nodes tree. This path may may pass root.\nThe length path two nodes represented number edges them.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3,4,5]\nOutput: 3\nExplanation: 3 length path [4,2,1,3] [5,2,1,3].\n\nExample 2:\nInput: root = [1,2]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 104].\n-100 <= Node.val <= 100\n\n' b'You given several boxes different colors represented different positive numbers.\nYou may experience several rounds remove boxes box left. Each time choose continuous boxes color (i.e., composed k boxes, k >= 1), remove get k * k points.\nReturn maximum points get.\n\xc2\xa0\nExample 1:\nInput: boxes = [1,3,2,2,2,3,4,3,1]\nOutput: 23\nExplanation:\n[1, 3, 2, 2, 2, 3, 4, 3, 1] \n----> [1, 3, 3, 4, 3, 1] (3*3=9 points) \n----> [1, 3, 3, 3, 1] (1*1=1 points) \n----> [1, 1] (3*3=9 points) \n----> [] (2*2=4 points)\n\nExample 2:\nInput: boxes = [1,1,1]\nOutput: 9\n\nExample 3:\nInput: boxes = [1]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= boxes.length <= 100\n1 <= boxes[i]\xc2\xa0<= 100\n\n' b'There n cities. Some connected, not. If city connected directly city b, city b connected directly city c, city connected indirectly city c.\nA province group directly indirectly connected cities cities outside group.\nYou given n x n matrix isConnected isConnected[i][j] = 1 ith city jth city directly connected, isConnected[i][j] = 0 otherwise.\nReturn total number provinces.\n\xc2\xa0\nExample 1:\n\nInput: isConnected = [[1,1,0],[1,1,0],[0,0,1]]\nOutput: 2\n\nExample 2:\n\nInput: isConnected = [[1,0,0],[0,1,0],[0,0,1]]\nOutput: 3\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 200\nn == isConnected.length\nn == isConnected[i].length\nisConnected[i][j] 1 0.\nisConnected[i][i] == 1\nisConnected[i][j] == isConnected[j][i]\n\n' b'You given string representing attendance record student character signifies whether student absent, late, present day. The record contains following three characters:\n\n\'A\': Absent.\n\'L\': Late.\n\'P\': Present.\n\nThe student eligible attendance award meet following criteria:\n\nThe student absent (\'A\') strictly fewer 2 days total.\nThe student never late (\'L\') 3 consecutive days.\n\nReturn true student eligible attendance award, false otherwise.\n\xc2\xa0\nExample 1:\nInput: = "PPALLP"\nOutput: true\nExplanation: The student fewer 2 absences never late 3 consecutive days.\n\nExample 2:\nInput: = "PPALLL"\nOutput: false\nExplanation: The student late 3 consecutive days last 3 days, eligible award.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 1000\ns[i] either \'A\', \'L\', \'P\'.\n\n' b'An attendance record student represented string character signifies whether student absent, late, present day. The record contains following three characters:\n\n\'A\': Absent.\n\'L\': Late.\n\'P\': Present.\n\nAny student eligible attendance award meet following criteria:\n\nThe student absent (\'A\') strictly fewer 2 days total.\nThe student never late (\'L\') 3 consecutive days.\n\nGiven integer n, return number possible attendance records length n make student eligible attendance award. The answer may large, return modulo 109 + 7.\n\xc2\xa0\nExample 1:\nInput: n = 2\nOutput: 8\nExplanation: There 8 records length 2 eligible award:\n"PP", "AP", "PA", "LP", "PL", "AL", "LA", "LL"\nOnly "AA" eligible 2 absences (there need fewer 2).\n\nExample 2:\nInput: n = 1\nOutput: 3\n\nExample 3:\nInput: n = 10101\nOutput: 183236316\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 105\n\n' b'You given integer array nums. The adjacent integers nums perform float division.\n\nFor example, nums = [2,3,4], evaluate expression "2/3/4".\n\nHowever, add number parenthesis position change priority operations. You want add parentheses value expression evaluation maximum.\nReturn corresponding expression maximum value string format.\nNote: expression contain redundant parenthesis.\n\xc2\xa0\nExample 1:\nInput: nums = [1000,100,10,2]\nOutput: "1000/(100/10/2)"\nExplanation:\n1000/(100/10/2) = 1000/((100/10)/2) = 200\nHowever, bold parenthesis "1000/((100/10)/2)" redundant, since don\'t influence operation priority. So return "1000/(100/10/2)".\nOther cases:\n1000/(100/10)/2 = 50\n1000/(100/(10/2)) = 50\n1000/100/10/2 = 0.5\n1000/100/(10/2) = 2\n\nExample 2:\nInput: nums = [2,3,4]\nOutput: "2/(3/4)"\n\nExample 3:\nInput: nums = [2]\nOutput: "2"\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 10\n2 <= nums[i] <= 1000\nThere one optimal division given iput.\n\n' b'There rectangular brick wall front n rows bricks. The ith row number bricks height (i.e., one unit) different widths. The total width row same.\nDraw vertical line top bottom cross least bricks. If line goes edge brick, brick considered crossed. You cannot draw line along one two vertical edges wall, case line obviously cross bricks.\nGiven 2D array wall contains information wall, return minimum number crossed bricks drawing vertical line.\n\xc2\xa0\nExample 1:\n\nInput: wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\nOutput: 2\n\nExample 2:\nInput: wall = [[1],[1],[1]]\nOutput: 3\n\n\xc2\xa0\nConstraints:\n\nn == wall.length\n1 <= n <= 104\n1 <= wall[i].length <= 104\n1 <= sum(wall[i].length) <= 2 * 104\nsum(wall[i]) row i.\n1 <= wall[i][j] <= 231 - 1\n\n' b'Given positive integer n, find smallest integer exactly digits existing integer n greater value n. If positive integer exists, return -1.\nNote returned integer fit 32-bit integer, valid answer fit 32-bit integer, return -1.\n\xc2\xa0\nExample 1:\nInput: n = 12\nOutput: 21\nExample 2:\nInput: n = 21\nOutput: -1\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 231 - 1\n\n' b'Given string s, reverse order characters word within sentence still preserving whitespace initial word order.\n\xc2\xa0\nExample 1:\nInput: = "Let\'s take LeetCode contest"\nOutput: "s\'teL ekat edoCteeL tsetnoc"\nExample 2:\nInput: = "God Ding"\nOutput: "doG gniD"\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 5 * 104\ns contains printable ASCII characters.\ns contain leading trailing spaces.\nThere least one word s.\nAll words separated single space.\n\n' b"A Binary Matrix matrix elements either 0 1.\nGiven quadTree1 quadTree2. quadTree1 represents n * n binary matrix quadTree2 represents another n * n binary matrix.\nReturn Quad-Tree representing n * n binary matrix result logical bitwise OR two binary matrixes represented quadTree1 quadTree2.\nNotice assign value node True False isLeaf False, accepted answer.\nA Quad-Tree tree data structure internal node exactly four children. Besides, node two attributes:\n\nval: True node represents grid 1's False node represents grid 0's.\nisLeaf: True node leaf node tree False node four children.\n\nclass Node {\n public boolean val;\n public boolean isLeaf;\n public Node topLeft;\n public Node topRight;\n public Node bottomLeft;\n public Node bottomRight;\n}\nWe construct Quad-Tree two-dimensional area using following steps:\n\nIf current grid value (i.e 1's 0's) set isLeaf True set val value grid set four children Null stop.\nIf current grid different values, set isLeaf False set val value divide current grid four sub-grids shown photo.\nRecurse children proper sub-grid.\n\n\nIf want know Quad-Tree, refer wiki.\nQuad-Tree format:\nThe input/output represents serialized format Quad-Tree using level order traversal, null signifies path terminator node exists below.\nIt similar serialization binary tree. The difference node represented list [isLeaf, val].\nIf value isLeaf val True represent 1 list [isLeaf, val] value isLeaf val False represent 0.\n\xc2\xa0\nExample 1:\n \nInput: quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]]\n, quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nOutput: [[0,0],[1,1],[1,1],[1,1],[1,0]]\nExplanation: quadTree1 quadTree2 shown above. You see binary matrix represented Quad-Tree.\nIf apply logical bitwise OR two binary matrices get binary matrix represented result Quad-Tree.\nNotice binary matrices shown illustration, construct binary matrix get result tree.\n\n\nExample 2:\nInput: quadTree1 = [[1,0]], quadTree2 = [[1,0]]\nOutput: [[1,0]]\nExplanation: Each tree represents binary matrix size 1*1. Each matrix contains zero.\nThe resulting matrix size 1*1 also zero.\n\n\xc2\xa0\nConstraints:\n\nquadTree1 quadTree2 valid Quad-Trees representing n * n grid.\nn == 2x 0 <= x <= 9.\n\n" b'Given n-ary tree, find maximum depth.\nThe maximum depth number nodes along longest path root node farthest leaf node.\nNary-Tree input serialization represented level order traversal, group children separated null value (See examples).\n\xc2\xa0\nExample 1:\n\nInput: root = [1,null,3,2,4,null,5,6]\nOutput: 3\n\nExample 2:\n\nInput: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: 5\n\n\xc2\xa0\nConstraints:\n\nThe total number nodes range [0, 104].\nThe depth n-ary tree less equal 1000.\n\n' b'Given array integers nums integer k, return total number subarrays whose sum equals k.\nA subarray contiguous non-empty sequence elements within array.\n\xc2\xa0\nExample 1:\nInput: nums = [1,1,1], k = 2\nOutput: 2\nExample 2:\nInput: nums = [1,2,3], k = 3\nOutput: 2\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 2 * 104\n-1000 <= nums[i] <= 1000\n-107 <= k <= 107\n\n' b'Given integer array nums 2n integers, group integers n pairs (a1, b1), (a2, b2), ..., (an, bn) sum min(ai, bi) maximized. Return maximized sum.\n\xc2\xa0\nExample 1:\nInput: nums = [1,4,3,2]\nOutput: 4\nExplanation: All possible pairings (ignoring ordering elements) are:\n1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo maximum possible sum 4.\nExample 2:\nInput: nums = [6,2,6,5,1,2]\nOutput: 9\nExplanation: The optimal pairing (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 104\nnums.length == 2 * n\n-104 <= nums[i] <= 104\n\n' b"Given root binary tree, return sum every tree node's tilt.\nThe tilt tree node absolute difference sum left subtree node values right subtree node values. If node left child, sum left subtree node values treated 0. The rule similar node right child.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3]\nOutput: 1\nExplanation: \nTilt node 2 : |0-0| = 0 (no children)\nTilt node 3 : |0-0| = 0 (no children)\nTilt node 1 : |2-3| = 1 (left subtree left child, sum 2; right subtree right child, sum 3)\nSum every tilt : 0 + 0 + 1 = 1\n\nExample 2:\n\nInput: root = [4,2,9,3,5,null,7]\nOutput: 15\nExplanation: \nTilt node 3 : |0-0| = 0 (no children)\nTilt node 5 : |0-0| = 0 (no children)\nTilt node 7 : |0-0| = 0 (no children)\nTilt node 2 : |3-5| = 2 (left subtree left child, sum 3; right subtree right child, sum 5)\nTilt node 9 : |0-7| = 7 (no left child, sum 0; right subtree right child, sum 7)\nTilt node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values 3, 5, 2, sums 10; right subtree values 9 7, sums 16)\nSum every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\n\nExample 3:\n\nInput: root = [21,7,14,1,1,2,2,3,3]\nOutput: 9\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 104].\n-1000 <= Node.val <= 1000\n\n" b'Given string n representing integer, return closest integer (not including itself), palindrome. If tie, return smaller one.\nThe closest defined absolute difference minimized two integers.\n\xc2\xa0\nExample 1:\nInput: n = "123"\nOutput: "121"\n\nExample 2:\nInput: n = "1"\nOutput: "0"\nExplanation: 0 2 closest palindromes return smallest 0.\n\n\xc2\xa0\nConstraints:\n\n1 <= n.length <= 18\nn consists digits.\nn leading zeros.\nn representing integer range [1, 1018 - 1].\n\n' b'You given integer array nums length n nums permutation numbers range [0, n - 1].\nYou build set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected following rule:\n\nThe first element s[k] starts selection element nums[k] index = k.\nThe next element s[k] nums[nums[k]], nums[nums[nums[k]]], on.\nWe stop adding right duplicate element occurs s[k].\n\nReturn longest length set s[k].\n\xc2\xa0\nExample 1:\nInput: nums = [5,4,0,3,1,6,2]\nOutput: 4\nExplanation: \nnums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.\nOne longest sets s[k]:\ns[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}\n\nExample 2:\nInput: nums = [0,1,2]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] < nums.length\nAll values nums unique.\n\n' b'In MATLAB, handy function called reshape reshape x n matrix new one different size r x c keeping original data.\nYou given x n matrix mat two integers r c representing number rows number columns wanted reshaped matrix.\nThe reshaped matrix filled elements original matrix row-traversing order were.\nIf reshape operation given parameters possible legal, output new reshaped matrix; Otherwise, output original matrix.\n\xc2\xa0\nExample 1:\n\nInput: mat = [[1,2],[3,4]], r = 1, c = 4\nOutput: [[1,2,3,4]]\n\nExample 2:\n\nInput: mat = [[1,2],[3,4]], r = 2, c = 4\nOutput: [[1,2],[3,4]]\n\n\xc2\xa0\nConstraints:\n\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 100\n-1000 <= mat[i][j] <= 1000\n1 <= r, c <= 300\n\n' b'Given two strings s1 s2, return true s2 contains permutation s1, false otherwise.\nIn words, return true one s1\'s permutations substring s2.\n\xc2\xa0\nExample 1:\nInput: s1 = "ab", s2 = "eidbaooo"\nOutput: true\nExplanation: s2 contains one permutation s1 ("ba").\n\nExample 2:\nInput: s1 = "ab", s2 = "eidboaoo"\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= s1.length, s2.length <= 104\ns1 s2 consist lowercase English letters.\n\n' b"Given roots two binary trees root subRoot, return true subtree root structure node values subRoot false otherwise.\nA subtree binary tree tree tree consists node tree node's descendants. The tree tree could also considered subtree itself.\n\xc2\xa0\nExample 1:\n\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\nOutput: true\n\nExample 2:\n\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\nOutput: false\n\n\xc2\xa0\nConstraints:\n\nThe number nodes root tree range [1, 2000].\nThe number nodes subRoot tree range [1, 1000].\n-104 <= root.val <= 104\n-104 <= subRoot.val <= 104\n\n" b"Alice n candies, ith candy type candyType[i]. Alice noticed started gain weight, visited doctor.\nThe doctor advised Alice eat n / 2 candies (n always even). Alice likes candies much, wants eat maximum number different types candies still following doctor's advice.\nGiven integer array candyType length n, return maximum number different types candies eat eats n / 2 them.\n\xc2\xa0\nExample 1:\nInput: candyType = [1,1,2,2,3,3]\nOutput: 3\nExplanation: Alice eat 6 / 2 = 3 candies. Since 3 types, eat one type.\n\nExample 2:\nInput: candyType = [1,1,2,3]\nOutput: 2\nExplanation: Alice eat 4 / 2 = 2 candies. Whether eats types [1,2], [1,3], [2,3], still eat 2 different types.\n\nExample 3:\nInput: candyType = [6,6,6,6]\nOutput: 1\nExplanation: Alice eat 4 / 2 = 2 candies. Even though eat 2 candies, 1 type.\n\n\xc2\xa0\nConstraints:\n\nn == candyType.length\n2 <= n <= 104\nn\xc2\xa0is even.\n-105 <= candyType[i] <= 105\n\n" b'There x n grid ball. The ball initially position [startRow, startColumn]. You allowed move ball one four adjacent cells grid (possibly grid crossing grid boundary). You apply maxMove moves ball.\nGiven five integers m, n, maxMove, startRow, startColumn, return number paths move ball grid boundary. Since answer large, return modulo 109 + 7.\n\xc2\xa0\nExample 1:\n\nInput: = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\nOutput: 6\n\nExample 2:\n\nInput: = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1\nOutput: 12\n\n\xc2\xa0\nConstraints:\n\n1 <= m, n <= 50\n0 <= maxMove <= 50\n0 <= startRow < m\n0 <= startColumn < n\n\n' b'Given integer array nums, need find one continuous subarray sort subarray ascending order, whole array sorted ascending order.\nReturn shortest subarray output length.\n\xc2\xa0\nExample 1:\nInput: nums = [2,6,4,8,10,9,15]\nOutput: 5\nExplanation: You need sort [6, 4, 8, 10, 9] ascending order make whole array sorted ascending order.\n\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: 0\n\nExample 3:\nInput: nums = [1]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n-105 <= nums[i] <= 105\n\n\xc2\xa0\nFollow up: Can solve O(n) time complexity?' b'Given two strings word1 word2, return minimum number steps required make word1 word2 same.\nIn one step, delete exactly one character either string.\n\xc2\xa0\nExample 1:\nInput: word1 = "sea", word2 = "eat"\nOutput: 2\nExplanation: You need one step make "sea" "ea" another step make "eat" "ea".\n\nExample 2:\nInput: word1 = "leetcode", word2 = "etco"\nOutput: 4\n\n\xc2\xa0\nConstraints:\n\n1 <= word1.length, word2.length <= 500\nword1 word2 consist lowercase English letters.\n\n' b'SQL Schema' b'SQL Schema' b'You given array trees trees[i] = [xi, yi] represents location tree garden.\nYou asked fence entire garden using minimum length rope expensive. The garden well fenced trees enclosed.\nReturn coordinates trees exactly located fence perimeter.\n\xc2\xa0\nExample 1:\n\nInput: points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\nOutput: [[1,1],[2,0],[3,3],[2,4],[4,2]]\n\nExample 2:\n\nInput: points = [[1,2],[2,2],[4,2]]\nOutput: [[4,2],[2,2],[1,2]]\n\n\xc2\xa0\nConstraints:\n\n1 <= points.length <= 3000\npoints[i].length == 2\n0 <= xi, yi <= 100\nAll given points unique.\n\n' b"Given root n-ary tree, return preorder traversal nodes' values.\nNary-Tree input serialization represented level order traversal. Each group children separated null value (See examples)\n\xc2\xa0\nExample 1:\n\nInput: root = [1,null,3,2,4,null,5,6]\nOutput: [1,3,5,6,2,4]\n\nExample 2:\n\nInput: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 104].\n0 <= Node.val <= 104\nThe height n-ary tree less equal 1000.\n\n\xc2\xa0\nFollow up: Recursive solution trivial, could iteratively?\n" b"Given root n-ary tree, return postorder traversal nodes' values.\nNary-Tree input serialization represented level order traversal. Each group children separated null value (See examples)\n\xc2\xa0\nExample 1:\n\nInput: root = [1,null,3,2,4,null,5,6]\nOutput: [5,6,3,2,4,1]\n\nExample 2:\n\nInput: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 104].\n0 <= Node.val <= 104\nThe height n-ary tree less equal 1000.\n\n\xc2\xa0\nFollow up: Recursive solution trivial, could iteratively?\n" b'Given string representing code snippet, implement tag validator parse code return whether valid.\nA code snippet valid following rules hold:\n\nThe code must wrapped valid closed tag. Otherwise, code invalid.\nA closed tag (not necessarily valid) exactly following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> start tag, </TAG_NAME> end tag. The TAG_NAME start end tags same. A closed tag valid TAG_NAME TAG_CONTENT valid.\nA valid TAG_NAME contain upper-case letters, length range [1,9]. Otherwise, TAG_NAME invalid.\nA valid TAG_CONTENT may contain valid closed tags, cdata characters (see note1) EXCEPT unmatched <, unmatched start end tag, unmatched closed tags invalid TAG_NAME. Otherwise, TAG_CONTENT invalid.\nA start tag unmatched end tag exists TAG_NAME, vice versa. However, also need consider issue unbalanced tags nested.\nA < unmatched cannot find subsequent >. And find < </, subsequent characters next > parsed TAG_NAME (not necessarily valid).\nThe cdata following format : <![CDATA[CDATA_CONTENT]]>. The range CDATA_CONTENT defined characters <![CDATA[ first subsequent ]]>.\nCDATA_CONTENT may contain characters. The function cdata forbid validator parse CDATA_CONTENT, even characters parsed tag (no matter valid invalid), treat regular characters.\n\n\xc2\xa0\nExample 1:\nInput: code = "<DIV>This first line <![CDATA[<div>]]></DIV>"\nOutput: true\nExplanation: \nThe code wrapped closed tag : <DIV> </DIV>. \nThe TAG_NAME valid, TAG_CONTENT consists characters cdata. \nAlthough CDATA_CONTENT unmatched start tag invalid TAG_NAME, considered plain text, parsed tag.\nSo TAG_CONTENT valid, code valid. Thus return true.\n\nExample 2:\nInput: code = "<DIV>>> ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>"\nOutput: true\nExplanation:\nWe first separate code : start_tag|tag_content|end_tag.\nstart_tag -> "<DIV>"\nend_tag -> "</DIV>"\ntag_content could also separated : text1|cdata|text2.\ntext1 -> ">> ![cdata[]] "\ncdata -> "<![CDATA[<div>]>]]>", CDATA_CONTENT "<div>]>"\ntext2 -> "]]>>]"\nThe reason start_tag NOT "<DIV>>>" rule 6.\nThe reason cdata NOT "<![CDATA[<div>]>]]>]]>" rule 7.\n\nExample 3:\nInput: code = "<A> <B> </A> </B>"\nOutput: false\nExplanation: Unbalanced. If "<A>" closed, "<B>" must unmatched, vice versa.\n\n\xc2\xa0\nConstraints:\n\n1 <= code.length <= 500\ncode consists English letters, digits, \'<\', \'>\', \'/\', \'!\', \'[\', \']\', \'.\', \' \'.\n\n' b'Given string expression representing expression fraction addition subtraction, return calculation result string format.\nThe final result irreducible fraction. If final result integer, change format fraction denominator 1. So case, 2 converted 2/1.\n\xc2\xa0\nExample 1:\nInput: expression = "-1/2+1/2"\nOutput: "0/1"\n\nExample 2:\nInput: expression = "-1/2+1/2+1/3"\nOutput: "1/3"\n\nExample 3:\nInput: expression = "1/3-1/2"\nOutput: "-1/6"\n\n\xc2\xa0\nConstraints:\n\nThe input string contains \'0\' \'9\', \'/\', \'+\' \'-\'. So output.\nEach fraction (input output) format \xc2\xb1numerator/denominator. If first input fraction output positive, \'+\' omitted.\nThe input contains valid irreducible fractions, numerator denominator fraction always range [1, 10]. If denominator 1, means fraction actually integer fraction format defined above.\nThe number given fractions range [1, 10].\nThe numerator denominator final result guaranteed valid range 32-bit int.\n\n' b'Given coordinates four points 2D space p1, p2, p3 p4, return true four points construct square.\nThe coordinate point pi represented [xi, yi]. The input given order.\nA valid square four equal sides positive length four equal angles (90-degree angles).\n\xc2\xa0\nExample 1:\nInput: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\nOutput: true\n\nExample 2:\nInput: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]\nOutput: false\n\nExample 3:\nInput: p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]\nOutput: true\n\n\xc2\xa0\nConstraints:\n\np1.length == p2.length == p3.length == p4.length == 2\n-104 <= xi, yi <= 104\n\n' b'We define harmonious array array difference maximum value minimum value exactly 1.\nGiven integer array nums, return length longest harmonious subsequence among possible subsequences.\nA subsequence array sequence derived array deleting elements without changing order remaining elements.\n\xc2\xa0\nExample 1:\nInput: nums = [1,3,2,2,5,2,3,7]\nOutput: 5\nExplanation: The longest harmonious subsequence [3,2,2,2,3].\n\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: 2\n\nExample 3:\nInput: nums = [1,1,1,1]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 2 * 104\n-109 <= nums[i] <= 109\n' b'SQL Schema' b'SQL Schema' b"You given x n matrix M initialized 0's array operations ops, ops[i] = [ai, bi] means M[x][y] incremented one 0 <= x < ai 0 <= < bi.\nCount return number maximum integers matrix performing operations.\n\xc2\xa0\nExample 1:\n\nInput: = 3, n = 3, ops = [[2,2],[3,3]]\nOutput: 4\nExplanation: The maximum integer M 2, four M. So return 4.\n\nExample 2:\nInput: = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]\nOutput: 4\n\nExample 3:\nInput: = 3, n = 3, ops = []\nOutput: 9\n\n\xc2\xa0\nConstraints:\n\n1 <= m, n <= 4 * 104\n0 <= ops.length <= 104\nops[i].length == 2\n1 <= ai <= m\n1 <= bi <= n\n\n" b'Suppose Andy Doris want choose restaurant dinner, list favorite restaurants represented strings.\nYou need help find common interest least list index sum. If choice tie answers, output order requirement. You could assume always exists answer.\n\xc2\xa0\nExample 1:\nInput: list1 = ["Shogun","Tapioca Express","Burger King","KFC"], list2 = ["Piatti","The Grill Torrey Pines","Hungry Hunter Steakhouse","Shogun"]\nOutput: ["Shogun"]\nExplanation: The restaurant like "Shogun".\n\nExample 2:\nInput: list1 = ["Shogun","Tapioca Express","Burger King","KFC"], list2 = ["KFC","Shogun","Burger King"]\nOutput: ["Shogun"]\nExplanation: The restaurant like least index sum "Shogun" index sum 1 (0+1).\n\n\xc2\xa0\nConstraints:\n\n1 <= list1.length, list2.length <= 1000\n1 <= list1[i].length, list2[i].length <= 30\nlist1[i] list2[i] consist spaces \' \' English letters.\nAll stings list1 unique.\nAll stings list2\xc2\xa0are unique.\n\n' b'Given positive integer n, return number integers range [0, n] whose binary representations contain consecutive ones.\n\xc2\xa0\nExample 1:\nInput: n = 5\nOutput: 5\nExplanation:\nHere non-negative integers <= 5 corresponding binary representations:\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\nAmong them, integer 3 disobeys rule (two consecutive ones) 5 satisfy rule. \n\nExample 2:\nInput: n = 1\nOutput: 2\n\nExample 3:\nInput: n = 2\nOutput: 3\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 109\n\n' b'SQL Schema' b"You long flowerbed plots planted, not. However, flowers cannot planted adjacent plots.\nGiven integer array flowerbed containing 0's 1's, 0 means empty 1 means empty, integer n, return n new flowers planted flowerbed without violating no-adjacent-flowers rule.\n\xc2\xa0\nExample 1:\nInput: flowerbed = [1,0,0,0,1], n = 1\nOutput: true\nExample 2:\nInput: flowerbed = [1,0,0,0,1], n = 2\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= flowerbed.length <= 2 * 104\nflowerbed[i] 0 1.\nThere two adjacent flowers flowerbed.\n0 <= n <= flowerbed.length\n\n" b'Given root binary tree, construct string consisting parenthesis integers binary tree preorder traversal way, return it.\nOmit empty parenthesis pairs affect one-to-one mapping relationship string original binary tree.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3,4]\nOutput: "1(2(4))(3)"\nExplanation: Originally, needs "1(2(4)())(3()())", need omit unnecessary empty parenthesis pairs. And "1(2(4))(3)"\n\nExample 2:\n\nInput: root = [1,2,3,null,4]\nOutput: "1(2()(4))(3)"\nExplanation: Almost first example, except cannot omit first parenthesis pair break one-to-one mapping relationship input output.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 104].\n-1000 <= Node.val <= 1000\n\n' b'SQL Schema' b'SQL Schema' b'Given list paths directory info, including directory path, files contents directory, return duplicate files file system terms paths. You may return answer order.\nA group duplicate files consists least two files content.\nA single directory info string input list following format:\n\n"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)"\n\nIt means n files (f1.txt, f2.txt ... fn.txt) content (f1_content, f2_content ... fn_content) respectively directory "root/d1/d2/.../dm". Note n >= 1 >= 0. If = 0, means directory root directory.\nThe output list groups duplicate file paths. For group, contains file paths files content. A file path string following format:\n\n"directory_path/file_name.txt"\n\n\xc2\xa0\nExample 1:\nInput: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)","root 4.txt(efgh)"]\nOutput: [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]\nExample 2:\nInput: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)"]\nOutput: [["root/a/2.txt","root/c/d/4.txt"],["root/a/1.txt","root/c/3.txt"]]\n\n\xc2\xa0\nConstraints:\n\n1 <= paths.length <= 2 * 104\n1 <= paths[i].length <= 3000\n1 <= sum(paths[i].length) <= 5 * 105\npaths[i] consist English letters, digits, \'/\', \'.\', \'(\', \')\', \' \'.\nYou may assume files directories share name directory.\nYou may assume given directory info represents unique directory. A single blank space separates directory path file info.\n\n\xc2\xa0\nFollow up:\n\nImagine given real file system, search files? DFS BFS?\nIf file content large (GB level), modify solution?\nIf read file 1kb time, modify solution?\nWhat time complexity modified solution? What time-consuming part memory-consuming part it? How optimize?\nHow make sure duplicated files find false positive?\n\n' b'Given integer array nums, return number triplets chosen array make triangles take side lengths triangle.\n\xc2\xa0\nExample 1:\nInput: nums = [2,2,3,4]\nOutput: 3\nExplanation: Valid combinations are: \n2,3,4 (using first 2)\n2,3,4 (using second 2)\n2,2,3\n\nExample 2:\nInput: nums = [4,2,3,4]\nOutput: 4\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 1000\n0 <= nums[i] <= 1000\n\n' b'You given two binary trees root1 root2.\nImagine put one cover other, nodes two trees overlapped others not. You need merge two trees new binary tree. The merge rule two nodes overlap, sum node values new value merged node. Otherwise, NOT null node used node new tree.\nReturn merged tree.\nNote: The merging process must start root nodes trees.\n\xc2\xa0\nExample 1:\n\nInput: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\nOutput: [3,4,5,5,4,null,7]\n\nExample 2:\nInput: root1 = [1], root2 = [1,2]\nOutput: [2,2]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes trees range [0, 2000].\n-104 <= Node.val <= 104\n\n' b'SQL Schema' b'Given characters array tasks, representing tasks CPU needs do, letter represents different task. Tasks could done order. Each task done one unit time. For unit time, CPU could complete either one task idle.\nHowever, non-negative integer\xc2\xa0n represents cooldown period between\xc2\xa0two tasks\xc2\xa0(the letter array), must least n units time two tasks.\nReturn least number units times CPU take finish given tasks.\n\xc2\xa0\nExample 1:\nInput: tasks = ["A","A","A","B","B","B"], n = 2\nOutput: 8\nExplanation: \nA -> B -> idle -> A -> B -> idle -> A -> B\nThere least 2 units time two tasks.\n\nExample 2:\nInput: tasks = ["A","A","A","B","B","B"], n = 0\nOutput: 6\nExplanation: On case permutation size 6 would work since n = 0.\n["A","A","A","B","B","B"]\n["A","B","A","B","A","B"]\n["B","B","B","A","A","A"]\n...\nAnd on.\n\nExample 3:\nInput: tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2\nOutput: 16\nExplanation: \nOne possible solution is\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\n\n\xc2\xa0\nConstraints:\n\n1 <= task.length <= 104\ntasks[i] upper-case English letter.\nThe integer n range [0, 100].\n\n' b'Design implementation circular queue. The circular queue linear data structure operations performed based FIFO (First In First Out) principle last position connected back first position make circle. It also called "Ring Buffer".\nOne benefits circular queue make use spaces front queue. In normal queue, queue becomes full, cannot insert next element even space front queue. But using circular queue, use space store new values.\nImplementation MyCircularQueue class:\n\nMyCircularQueue(k) Initializes object size queue k.\nint Front() Gets front item queue. If queue empty, return -1.\nint Rear() Gets last item queue. If queue empty, return -1.\nboolean enQueue(int value) Inserts element circular queue. Return true operation successful.\nboolean deQueue() Deletes element circular queue. Return true operation successful.\nboolean isEmpty() Checks whether circular queue empty not.\nboolean isFull() Checks whether circular queue full not.\n\nYou must solve problem without using built-in queue data structure programming language.\xc2\xa0\n\xc2\xa0\nExample 1:\nInput\n["MyCircularQueue", "enQueue", "enQueue", "enQueue", "enQueue", "Rear", "isFull", "deQueue", "enQueue", "Rear"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\nOutput\n[null, true, true, true, false, 3, true, true, true, 4]\n\nExplanation\nMyCircularQueue myCircularQueue = new MyCircularQueue(3);\nmyCircularQueue.enQueue(1); // return True\nmyCircularQueue.enQueue(2); // return True\nmyCircularQueue.enQueue(3); // return True\nmyCircularQueue.enQueue(4); // return False\nmyCircularQueue.Rear(); // return 3\nmyCircularQueue.isFull(); // return True\nmyCircularQueue.deQueue(); // return True\nmyCircularQueue.enQueue(4); // return True\nmyCircularQueue.Rear(); // return 4\n\n\xc2\xa0\nConstraints:\n\n1 <= k <= 1000\n0 <= value <= 1000\nAt 3000 calls made to\xc2\xa0enQueue, deQueue,\xc2\xa0Front,\xc2\xa0Rear,\xc2\xa0isEmpty, and\xc2\xa0isFull.\n\n' b"Given root binary tree two integers val depth, add row nodes value val given depth depth.\nNote root node depth 1.\nThe adding rule is:\n\nGiven integer depth, null tree node cur depth depth - 1, create two tree nodes value val cur's left subtree root right subtree root.\ncur's original left subtree left subtree new left subtree root.\ncur's original right subtree right subtree new right subtree root.\nIf depth == 1 means depth depth - 1 all, create tree node value val new root whole original tree, original tree new root's left subtree.\n\n\xc2\xa0\nExample 1:\n\nInput: root = [4,2,6,3,1,5], val = 1, depth = 2\nOutput: [4,1,1,2,null,null,6,3,1,5]\n\nExample 2:\n\nInput: root = [4,2,null,3,1], val = 1, depth = 3\nOutput: [4,2,null,1,1,3,null,null,1]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 104].\nThe depth tree range [1, 104].\n-100 <= Node.val <= 100\n-105 <= val <= 105\n1 <= depth <= depth tree + 1\n\n" b'SQL Schema' b'SQL Schema' b'Given integer array nums, find three numbers whose product maximum return maximum product.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3]\nOutput: 6\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: 24\nExample 3:\nInput: nums = [-1,-2,-3]\nOutput: -6\n\n\xc2\xa0\nConstraints:\n\n3 <= nums.length <=\xc2\xa0104\n-1000 <= nums[i] <= 1000\n\n' b'For integer array nums, inverse pair pair integers [i, j] 0 <= < j < nums.length nums[i] > nums[j].\nGiven two integers n k, return number different arrays consist numbers 1 n exactly k inverse pairs. Since answer huge, return modulo 109 + 7.\n\xc2\xa0\nExample 1:\nInput: n = 3, k = 0\nOutput: 1\nExplanation: Only array [1,2,3] consists numbers 1 3 exactly 0 inverse pairs.\n\nExample 2:\nInput: n = 3, k = 1\nOutput: 2\nExplanation: The array [1,3,2] [2,1,3] exactly 1 inverse pair.\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 1000\n0 <= k <= 1000\n\n' b'There n different online courses numbered 1 n. You given array courses courses[i] = [durationi, lastDayi] indicate ith course taken continuously durationi days must finished lastDayi.\nYou start 1st day cannot take two courses simultaneously.\nReturn maximum number courses take.\n\xc2\xa0\nExample 1:\nInput: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]\nOutput: 3\nExplanation: \nThere totally 4 courses, take 3 courses most:\nFirst, take 1st course, costs 100 days finish 100th day, ready take next course 101st day.\nSecond, take 3rd course, costs 1000 days finish 1100th day, ready take next course 1101st day. \nThird, take 2nd course, costs 200 days finish 1300th day. \nThe 4th course cannot taken now, since finish 3300th day, exceeds closed date.\n\nExample 2:\nInput: courses = [[1,2]]\nOutput: 1\n\nExample 3:\nInput: courses = [[3,2],[4,3]]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <= courses.length <= 104\n1 <= durationi, lastDayi <= 104\n\n' b'You k lists sorted integers non-decreasing\xc2\xa0order. Find smallest range includes least one number k lists.\nWe define range [a, b] smaller range [c, d] b - < - c < c b - == - c.\n\xc2\xa0\nExample 1:\nInput: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\nOutput: [20,24]\nExplanation: \nList 1: [4, 10, 15, 24,26], 24 range [20,24].\nList 2: [0, 9, 12, 20], 20 range [20,24].\nList 3: [5, 18, 22, 30], 22 range [20,24].\n\nExample 2:\nInput: nums = [[1,2,3],[1,2,3],[1,2,3]]\nOutput: [1,1]\n\n\xc2\xa0\nConstraints:\n\nnums.length == k\n1 <= k <= 3500\n1 <= nums[i].length <= 50\n-105 <= nums[i][j] <= 105\nnums[i]\xc2\xa0is sorted non-decreasing order.\n\n' b"Given non-negative integer c, decide whether there're two integers b a2 + b2 = c.\n\xc2\xa0\nExample 1:\nInput: c = 5\nOutput: true\nExplanation: 1 * 1 + 2 * 2 = 5\n\nExample 2:\nInput: c = 3\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n0 <= c <= 231 - 1\n\n" b'On single-threaded CPU, execute program containing n functions. Each function unique ID 0 n-1.\nFunction calls stored call stack: function call starts, ID pushed onto stack, function call ends, ID popped stack. The function whose ID top stack current function executed. Each time function starts ends, write log ID, whether started ended, timestamp.\nYou given list logs, logs[i] represents ith log message formatted string "{function_id}:{"start" | "end"}:{timestamp}". For example, "0:start:3" means function call function ID 0 started beginning timestamp 3, "1:end:2" means function call function ID 1 ended end timestamp 2. Note function called multiple times, possibly recursively.\nA function\'s exclusive time sum execution times function calls program. For example, function called twice, one call executing 2 time units another call executing 1 time unit, exclusive time 2 + 1 = 3.\nReturn exclusive time function array, value ith index represents exclusive time function ID i.\n\xc2\xa0\nExample 1:\n\nInput: n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]\nOutput: [3,4]\nExplanation:\nFunction 0 starts beginning time 0, executes 2 units time reaches end time 1.\nFunction 1 starts beginning time 2, executes 4 units time, ends end time 5.\nFunction 0 resumes execution beginning time 6 executes 1 unit time.\nSo function 0 spends 2 + 1 = 3 units total time executing, function 1 spends 4 units total time executing.\n\nExample 2:\nInput: n = 1, logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"]\nOutput: [8]\nExplanation:\nFunction 0 starts beginning time 0, executes 2 units time, recursively calls itself.\nFunction 0 (recursive call) starts beginning time 2 executes 4 units time.\nFunction 0 (initial call) resumes execution immediately calls again.\nFunction 0 (2nd recursive call) starts beginning time 6 executes 1 unit time.\nFunction 0 (initial call) resumes execution beginning time 7 executes 1 unit time.\nSo function 0 spends 2 + 4 + 1 + 1 = 8 units total time executing.\n\nExample 3:\nInput: n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:6","1:end:6","0:end:7"]\nOutput: [7,1]\nExplanation:\nFunction 0 starts beginning time 0, executes 2 units time, recursively calls itself.\nFunction 0 (recursive call) starts beginning time 2 executes 4 units time.\nFunction 0 (initial call) resumes execution immediately calls function 1.\nFunction 1 starts beginning time 6, executes 1 unit time, ends end time 6.\nFunction 0 resumes execution beginning time 6 executes 2 units time.\nSo function 0 spends 2 + 4 + 1 = 7 units total time executing, function 1 spends 1 unit total time executing.\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 100\n1 <= logs.length <= 500\n0 <= function_id < n\n0 <= timestamp <= 109\nNo two start events happen timestamp.\nNo two end events happen timestamp.\nEach function "end" log "start" log.\n\n' b'Given root binary tree, return average value nodes level form array. Answers within 10-5 actual answer accepted.\n\xc2\xa0\nExample 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value nodes level 0 3, level 1 14.5, level 2 11.\nHence return [3, 14.5, 11].\n\nExample 2:\n\nInput: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 104].\n-231 <= Node.val <= 231 - 1\n\n' b'In LeetCode Store, n items sell. Each item price. However, special offers, special offer consists one different kinds items sale price.\nYou given integer array price price[i] price ith item, integer array needs needs[i] number pieces ith item want buy.\nYou also given array special special[i] size n + 1 special[i][j] number pieces jth item ith offer special[i][n] (i.e., last integer array) price ith offer.\nReturn lowest price pay exactly certain items given, could make optimal use special offers. You allowed buy items want, even would lower overall price. You could use special offers many times want.\n\xc2\xa0\nExample 1:\nInput: price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\nOutput: 14\nExplanation: There two kinds items, A B. Their prices $2 $5 respectively. \nIn special offer 1, pay $5 3A 0B\nIn special offer 2, pay $10 1A 2B. \nYou need buy 3A 2B, may pay $10 1A 2B (special offer #2), $4 2A.\n\nExample 2:\nInput: price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]\nOutput: 11\nExplanation: The price A $2, $3 B, $4 C. \nYou may pay $4 1A 1B, $9 2A ,2B 1C. \nYou need buy 1A ,2B 1C, may pay $4 1A 1B (special offer #1), $3 1B, $4 1C. \nYou cannot add items, though $9 2A ,2B 1C.\n\n\xc2\xa0\nConstraints:\n\nn == price.length\nn == needs.length\n1 <= n <= 6\n0 <= price[i] <= 10\n0 <= needs[i] <= 10\n1 <= special.length <= 100\nspecial[i].length == n + 1\n0 <= special[i][j] <= 50\n\n' b'A message containing letters A-Z encoded numbers using following mapping:\n\'A\' -> "1"\n\'B\' -> "2"\n...\n\'Z\' -> "26"\n\nTo decode encoded message, digits must grouped mapped back letters using reverse mapping (there may multiple ways). For example, "11106" mapped into:\n\n"AAJF" grouping (1 1 10 6)\n"KJF" grouping (11 10 6)\n\nNote grouping (1 11 06) invalid "06" cannot mapped \'F\' since "6" different "06".\nIn addition mapping above, encoded message may contain \'*\' character, represent digit \'1\' \'9\' (\'0\' excluded). For example, encoded message "1*" may represent encoded messages "11", "12", "13", "14", "15", "16", "17", "18", "19". Decoding "1*" equivalent decoding encoded messages represent.\nGiven string consisting digits \'*\' characters, return number ways decode it.\nSince answer may large, return modulo 109 + 7.\n\xc2\xa0\nExample 1:\nInput: = "*"\nOutput: 9\nExplanation: The encoded message represent encoded messages "1", "2", "3", "4", "5", "6", "7", "8", "9".\nEach decoded strings "A", "B", "C", "D", "E", "F", "G", "H", "I" respectively.\nHence, total 9 ways decode "*".\n\nExample 2:\nInput: = "1*"\nOutput: 18\nExplanation: The encoded message represent encoded messages "11", "12", "13", "14", "15", "16", "17", "18", "19".\nEach encoded messages 2 ways decoded (e.g. "11" decoded "AA" "K").\nHence, total 9 * 2 = 18 ways decode "1*".\n\nExample 3:\nInput: = "2*"\nOutput: 15\nExplanation: The encoded message represent encoded messages "21", "22", "23", "24", "25", "26", "27", "28", "29".\n"21", "22", "23", "24", "25", "26" 2 ways decoded, "27", "28", "29" 1 way.\nHence, total (6 * 2) + (3 * 1) = 12 + 3 = 15 ways decode "2*".\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 105\ns[i] digit \'*\'.\n\n' b'Solve given equation return value \'x\' form string "x=#value". The equation contains \'+\', \'-\' operation, variable \'x\' coefficient. You return "No solution" solution equation, "Infinite solutions" infinite solutions equation.\nIf exactly one solution equation, ensure value \'x\' integer.\n\xc2\xa0\nExample 1:\nInput: equation = "x+5-3+x=6+x-2"\nOutput: "x=2"\n\nExample 2:\nInput: equation = "x=x"\nOutput: "Infinite solutions"\n\nExample 3:\nInput: equation = "2x=x"\nOutput: "x=0"\n\n\xc2\xa0\nConstraints:\n\n3 <= equation.length <= 1000\nequation exactly one \'=\'.\nequation consists integers absolute value range [0, 100] without leading zeros, variable \'x\'.\n\n' b'Design implementation circular double-ended queue (deque).\nImplement MyCircularDeque class:\n\nMyCircularDeque(int k) Initializes deque maximum size k.\nboolean insertFront() Adds item front Deque. Returns true operation successful, false otherwise.\nboolean insertLast() Adds item rear Deque. Returns true operation successful, false otherwise.\nboolean deleteFront() Deletes item front Deque. Returns true operation successful, false otherwise.\nboolean deleteLast() Deletes item rear Deque. Returns true operation successful, false otherwise.\nint getFront() Returns front item Deque. Returns -1 deque empty.\nint getRear() Returns last item Deque. Returns -1 deque empty.\nboolean isEmpty() Returns true deque empty, false otherwise.\nboolean isFull() Returns true deque full, false otherwise.\n\n\xc2\xa0\nExample 1:\nInput\n["MyCircularDeque", "insertLast", "insertLast", "insertFront", "insertFront", "getRear", "isFull", "deleteLast", "insertFront", "getFront"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\nOutput\n[null, true, true, true, false, 2, true, true, true, 4]\n\nExplanation\nMyCircularDeque myCircularDeque = new MyCircularDeque(3);\nmyCircularDeque.insertLast(1); // return True\nmyCircularDeque.insertLast(2); // return True\nmyCircularDeque.insertFront(3); // return True\nmyCircularDeque.insertFront(4); // return False, queue full.\nmyCircularDeque.getRear(); // return 2\nmyCircularDeque.isFull(); // return True\nmyCircularDeque.deleteLast(); // return True\nmyCircularDeque.insertFront(4); // return True\nmyCircularDeque.getFront(); // return 4\n\n\xc2\xa0\nConstraints:\n\n1 <= k <= 1000\n0 <= value <= 1000\nAt 2000 calls made insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.\n\n' b'You given integer array nums consisting n elements, integer k.\nFind contiguous subarray whose length equal k maximum average value return value. Any answer calculation error less 10-5 accepted.\n\xc2\xa0\nExample 1:\nInput: nums = [1,12,-5,-6,50,3], k = 4\nOutput: 12.75000\nExplanation: Maximum average (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75\n\nExample 2:\nInput: nums = [5], k = 1\nOutput: 5.00000\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= k <= n <= 105\n-104 <= nums[i] <= 104\n\n' b'You set integers s, originally contains numbers 1 n. Unfortunately, due error, one numbers got duplicated another number set, results repetition one number loss another number.\nYou given integer array nums representing data status set error.\nFind number occurs twice number missing return form array.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,2,4]\nOutput: [2,3]\nExample 2:\nInput: nums = [1,1]\nOutput: [1,2]\n\n\xc2\xa0\nConstraints:\n\n2 <= nums.length <= 104\n1 <= nums[i] <= 104\n\n' b'You given array n pairs pairs pairs[i] = [lefti, righti] lefti < righti.\nA pair p2 = [c, d] follows pair p1 = [a, b] b < c. A chain pairs formed fashion.\nReturn length longest chain formed.\nYou need use given intervals. You select pairs order.\n\xc2\xa0\nExample 1:\nInput: pairs = [[1,2],[2,3],[3,4]]\nOutput: 2\nExplanation: The longest chain [1,2] -> [3,4].\n\nExample 2:\nInput: pairs = [[1,2],[7,8],[4,5]]\nOutput: 3\nExplanation: The longest chain [1,2] -> [4,5] -> [7,8].\n\n\xc2\xa0\nConstraints:\n\nn == pairs.length\n1 <= n <= 1000\n-1000 <= lefti < righti <= 1000\n\n' b'Given string s, return number palindromic substrings it.\nA string palindrome reads backward forward.\nA substring contiguous sequence characters within string.\n\xc2\xa0\nExample 1:\nInput: = "abc"\nOutput: 3\nExplanation: Three palindromic strings: "a", "b", "c".\n\nExample 2:\nInput: = "aaa"\nOutput: 6\nExplanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 1000\ns consists lowercase English letters.\n\n' b'In English, concept called root, followed word form another longer word - let\'s call word successor. For example, root "an" followed successor word "other", form new word "another".\nGiven dictionary consisting many roots sentence consisting words separated spaces, replace successors sentence root forming it. If successor replaced one root, replace root shortest length.\nReturn sentence replacement.\n\xc2\xa0\nExample 1:\nInput: dictionary = ["cat","bat","rat"], sentence = "the cattle rattled battery"\nOutput: "the cat rat bat"\n\nExample 2:\nInput: dictionary = ["a","b","c"], sentence = "aadsfasf absbs bbab cadsfafs"\nOutput: "a b c"\n\n\xc2\xa0\nConstraints:\n\n1 <= dictionary.length <= 1000\n1 <= dictionary[i].length <= 100\ndictionary[i] consists lower-case letters.\n1 <= sentence.length <= 106\nsentence consists lower-case letters spaces.\nThe number words sentence range [1, 1000]\nThe length word sentence range [1, 1000]\nEvery two consecutive words sentence separated exactly one space.\nsentence leading trailing spaces.\n\n' b'In world Dota2, two parties: Radiant Dire.\nThe Dota2 senate consists senators coming two parties. Now Senate wants decide change Dota2 game. The voting change round-based procedure. In round, senator exercise one two rights:\n\nBan one senator\'s right: A senator make another senator lose rights following rounds.\nAnnounce victory: If senator found senators still rights vote party, announce victory decide change game.\n\nGiven string senate representing senator\'s party belonging. The character \'R\' \'D\' represent Radiant party Dire party. Then n senators, size given string n.\nThe round-based procedure starts first senator last senator given order. This procedure last end voting. All senators lost rights skipped procedure.\nSuppose every senator smart enough play best strategy party. Predict party finally announce victory change Dota2 game. The output "Radiant" "Dire".\n\xc2\xa0\nExample 1:\nInput: senate = "RD"\nOutput: "Radiant"\nExplanation: \nThe first senator comes Radiant ban next senator\'s right round 1. \nAnd second senator can\'t exercise rights anymore since right banned. \nAnd round 2, first senator announce victory since guy senate vote.\n\nExample 2:\nInput: senate = "RDD"\nOutput: "Dire"\nExplanation: \nThe first senator comes Radiant ban next senator\'s right round 1. \nAnd second senator can\'t exercise rights anymore since right banned. \nAnd third senator comes Dire ban first senator\'s right round 1. \nAnd round 2, third senator announce victory since guy senate vote.\n\n\xc2\xa0\nConstraints:\n\nn == senate.length\n1 <= n <= 104\nsenate[i] either \'R\' \'D\'.\n\n' b"There one character 'A' screen notepad. You perform one two operations notepad step:\n\nCopy All: You copy characters present screen (a partial copy allowed).\nPaste: You paste characters copied last time.\n\nGiven integer n, return minimum number operations get character 'A' exactly n times screen.\n\xc2\xa0\nExample 1:\nInput: n = 3\nOutput: 3\nExplanation: Initially, one character 'A'.\nIn step 1, use Copy All operation.\nIn step 2, use Paste operation get 'AA'.\nIn step 3, use Paste operation get 'AAA'.\n\nExample 2:\nInput: n = 1\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 1000\n\n" b'Given root\xc2\xa0of binary tree, return duplicate subtrees.\nFor kind duplicate subtrees, need return root node one them.\nTwo trees duplicate structure node values.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3,4,null,2,4,null,null,4]\nOutput: [[2,4],[4]]\n\nExample 2:\n\nInput: root = [2,1,1]\nOutput: [[1]]\n\nExample 3:\n\nInput: root = [2,2,2,3,null,3,null]\nOutput: [[2,3],[3]]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 10^4]\n-200 <= Node.val <= 200\n\n' b'Given root Binary Search Tree target number k, return true exist two elements BST sum equal given target.\n\xc2\xa0\nExample 1:\n\nInput: root = [5,3,6,2,4,null,7], k = 9\nOutput: true\n\nExample 2:\n\nInput: root = [5,3,6,2,4,null,7], k = 28\nOutput: false\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 104].\n-104\xc2\xa0<= Node.val <= 104\nroot guaranteed valid binary search tree.\n-105\xc2\xa0<= k <= 105\n\n' b'You given integer array nums duplicates. A maximum binary tree built recursively nums using following algorithm:\n\nCreate root node whose value maximum value nums.\nRecursively build left subtree subarray prefix left maximum value.\nRecursively build right subtree subarray suffix right maximum value.\n\nReturn maximum binary tree built nums.\n\xc2\xa0\nExample 1:\n\nInput: nums = [3,2,1,6,0,5]\nOutput: [6,3,5,null,2,0,null,null,1]\nExplanation: The recursive calls follow:\n- The largest value [3,2,1,6,0,5] 6. Left prefix [3,2,1] right suffix [0,5].\n - The largest value [3,2,1] 3. Left prefix [] right suffix [2,1].\n - Empty array, child.\n - The largest value [2,1] 2. Left prefix [] right suffix [1].\n - Empty array, child.\n - Only one element, child node value 1.\n - The largest value [0,5] 5. Left prefix [0] right suffix [].\n - Only one element, child node value 0.\n - Empty array, child.\n\nExample 2:\n\nInput: nums = [3,2,1]\nOutput: [3,null,2,null,1]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 1000\n0 <= nums[i] <= 1000\nAll integers nums unique.\n\n' b'Given root binary tree, construct 0-indexed x n string matrix res represents formatted layout tree. The formatted layout matrix constructed using following rules:\n\nThe height tree height\xc2\xa0and number rows equal height + 1.\nThe number columns n equal 2height+1 - 1.\nPlace root node middle top row (more formally, location res[0][(n-1)/2]).\nFor node placed matrix position res[r][c], place left child res[r+1][c-2height-r-1] right child res[r+1][c+2height-r-1].\nContinue process nodes tree placed.\nAny empty cells contain empty string "".\n\nReturn constructed matrix res.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2]\nOutput: \n[["","1",""],\n\xc2\xa0["2","",""]]\n\nExample 2:\n\nInput: root = [1,2,3,null,4]\nOutput: \n[["","","","1","","",""],\n\xc2\xa0["","2","","","","3",""],\n\xc2\xa0["","","4","","","",""]]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 210].\n-99 <= Node.val <= 99\nThe depth tree range [1, 10].\n\n' b'There robot starting position (0, 0), origin, 2D plane. Given sequence moves, judge robot ends (0, 0) completes moves.\nYou given string moves represents move sequence robot moves[i] represents ith move. Valid moves \'R\' (right), \'L\' (left), \'U\' (up), \'D\' (down).\nReturn true robot returns origin finishes moves, false otherwise.\nNote: The way robot "facing" irrelevant. \'R\' always make robot move right once, \'L\' always make move left, etc. Also, assume magnitude robot\'s movement move.\n\xc2\xa0\nExample 1:\nInput: moves = "UD"\nOutput: true\nExplanation: The robot moves once, once. All moves magnitude, ended origin started. Therefore, return true.\n\nExample 2:\nInput: moves = "LL"\nOutput: false\nExplanation: The robot moves left twice. It ends two "moves" left origin. We return false origin end moves.\n\n\xc2\xa0\nConstraints:\n\n1 <= moves.length <= 2 * 104\nmoves contains characters \'U\', \'D\', \'L\' \'R\'.\n\n' b'Given sorted integer array arr, two integers k x, return k closest integers x array. The result also sorted ascending order.\nAn integer closer x integer b if:\n\n|a - x| < |b - x|, or\n|a - x| == |b - x| < b\n\n\xc2\xa0\nExample 1:\nInput: arr = [1,2,3,4,5], k = 4, x = 3\nOutput: [1,2,3,4]\nExample 2:\nInput: arr = [1,2,3,4,5], k = 4, x = -1\nOutput: [1,2,3,4]\n\n\xc2\xa0\nConstraints:\n\n1 <= k <= arr.length\n1 <= arr.length <= 104\narr sorted ascending order.\n-104 <= arr[i], x <= 104\n\n' b'You given integer array nums sorted non-decreasing order.\nDetermine possible split nums one subsequences following conditions true:\n\nEach subsequence consecutive increasing sequence (i.e. integer exactly one previous integer).\nAll subsequences length 3 more.\n\nReturn true split nums according conditions, false otherwise.\nA subsequence array new array formed original array deleting (can none) elements without disturbing relative positions remaining elements. (i.e., [1,3,5] subsequence [1,2,3,4,5] [1,3,2] not).\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3,3,4,5]\nOutput: true\nExplanation: nums split following subsequences:\n[1,2,3,3,4,5] --> 1, 2, 3\n[1,2,3,3,4,5] --> 3, 4, 5\n\nExample 2:\nInput: nums = [1,2,3,3,4,4,5,5]\nOutput: true\nExplanation: nums split following subsequences:\n[1,2,3,3,4,4,5,5] --> 1, 2, 3, 4, 5\n[1,2,3,3,4,4,5,5] --> 3, 4, 5\n\nExample 3:\nInput: nums = [1,2,3,4,4,5]\nOutput: false\nExplanation: It impossible split nums consecutive increasing subsequences length 3 more.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n-1000 <= nums[i] <= 1000\nnums sorted non-decreasing order.\n\n' b'An image smoother filter size 3 x 3 applied cell image rounding average cell eight surrounding cells (i.e., average nine cells blue smoother). If one surrounding cells cell present, consider average (i.e., average four cells red smoother).\n\nGiven x n integer matrix img representing grayscale image, return image applying smoother cell it.\n\xc2\xa0\nExample 1:\n\nInput: img = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[0,0,0],[0,0,0],[0,0,0]]\nExplanation:\nFor points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\nFor points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\nFor point (1,1): floor(8/9) = floor(0.88888889) = 0\n\nExample 2:\n\nInput: img = [[100,200,100],[200,50,200],[100,200,100]]\nOutput: [[137,141,137],[141,138,141],[137,141,137]]\nExplanation:\nFor points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\nFor points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\nFor point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138\n\n\xc2\xa0\nConstraints:\n\nm == img.length\nn == img[i].length\n1 <= m, n <= 200\n0 <= img[i][j] <= 255\n\n' b'Given root binary tree, return maximum width given tree.\nThe maximum width tree maximum width among levels.\nThe width one level defined length end-nodes (the leftmost rightmost non-null nodes), null nodes end-nodes would present complete binary tree extending level also counted length calculation.\nIt guaranteed answer range 32-bit signed integer.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,3,2,5,3,null,9]\nOutput: 4\nExplanation: The maximum width exists third level length 4 (5,3,null,9).\n\nExample 2:\n\nInput: root = [1,3,2,5,null,null,9,6,null,7]\nOutput: 7\nExplanation: The maximum width exists fourth level length 7 (6,null,null,null,null,null,7).\n\nExample 3:\n\nInput: root = [1,3,2,5]\nOutput: 2\nExplanation: The maximum width exists second level length 2 (3,2).\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 3000].\n-100 <= Node.val <= 100\n\n' b'There strange printer following two special properties:\n\nThe printer print sequence character time.\nAt turn, printer print new characters starting ending place cover original existing characters.\n\nGiven string s, return minimum number turns printer needed print it.\n\xc2\xa0\nExample 1:\nInput: = "aaabbb"\nOutput: 2\nExplanation: Print "aaa" first print "bbb".\n\nExample 2:\nInput: = "aba"\nOutput: 2\nExplanation: Print "aaa" first print "b" second place string, cover existing character \'a\'.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 100\ns consists lowercase English letters.\n\n' b"Given array nums n integers, task check could become non-decreasing modifying one element.\nWe define array non-decreasing nums[i] <= nums[i + 1] holds every (0-based) (0 <= <= n - 2).\n\xc2\xa0\nExample 1:\nInput: nums = [4,2,3]\nOutput: true\nExplanation: You could modify first 4 1 get non-decreasing array.\n\nExample 2:\nInput: nums = [4,2,1]\nOutput: false\nExplanation: You can't get non-decreasing array modify one element.\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= n <= 104\n-105 <= nums[i] <= 105\n\n" b'Given two integers n k, construct list answer contains n different positive integers ranging 1 n obeys following requirement:\n\nSuppose list answer =\xc2\xa0[a1, a2, a3, ... , an], list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] exactly k distinct integers.\n\nReturn list answer. If multiple valid answers, return them.\n\xc2\xa0\nExample 1:\nInput: n = 3, k = 1\nOutput: [1,2,3]\nExplanation: The [1,2,3] three different positive integers ranging 1 3, [1,1] exactly 1 distinct integer: 1\n\nExample 2:\nInput: n = 3, k = 2\nOutput: [1,3,2]\nExplanation: The [1,3,2] three different positive integers ranging 1 3, [2,1] exactly 2 distinct integers: 1 2.\n\n\xc2\xa0\nConstraints:\n\n1 <= k < n <= 104\n\n' b'Nearly everyone used Multiplication Table. The multiplication table size x n integer matrix mat mat[i][j] == * j (1-indexed).\nGiven three integers m, n, k, return kth smallest element x n multiplication table.\n\xc2\xa0\nExample 1:\n\nInput: = 3, n = 3, k = 5\nOutput: 3\nExplanation: The 5th smallest number 3.\n\nExample 2:\n\nInput: = 2, n = 3, k = 6\nOutput: 6\nExplanation: The 6th smallest number 6.\n\n\xc2\xa0\nConstraints:\n\n1 <= m, n <= 3 * 104\n1 <= k <= * n\n\n' b"Given root binary search tree lowest highest boundaries low high, trim tree elements lies [low, high]. Trimming tree change relative structure elements remain tree (i.e., node's descendant remain descendant). It proven unique answer.\nReturn root trimmed binary search tree. Note root may change depending given bounds.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,0,2], low = 1, high = 2\nOutput: [1,null,2]\n\nExample 2:\n\nInput: root = [3,0,4,null,2,null,null,1], low = 1, high = 3\nOutput: [3,2,null,1]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 104].\n0 <= Node.val <= 104\nThe value node tree unique.\nroot guaranteed valid binary search tree.\n0 <= low <= high <= 104\n\n" b'You given integer num. You swap two digits get maximum valued number.\nReturn maximum valued number get.\n\xc2\xa0\nExample 1:\nInput: num = 2736\nOutput: 7236\nExplanation: Swap number 2 number 7.\n\nExample 2:\nInput: num = 9973\nOutput: 9973\nExplanation: No swap.\n\n\xc2\xa0\nConstraints:\n\n0 <= num <= 108\n\n' b"Given non-empty special binary tree consisting nodes non-negative value, node tree exactly two zero sub-node. If node two sub-nodes, node's value smaller value among two sub-nodes. More formally, property\xc2\xa0root.val = min(root.left.val, root.right.val)\xc2\xa0always holds.\nGiven binary tree, need output second minimum value set made nodes' value whole tree.\nIf second minimum value exists, output -1 instead.\n\xc2\xa0\n\xc2\xa0\nExample 1:\n\nInput: root = [2,2,5,null,null,5,7]\nOutput: 5\nExplanation: The smallest value 2, second smallest value 5.\n\nExample 2:\n\nInput: root = [2,2,2]\nOutput: -1\nExplanation: The smallest value 2, second smallest value.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 25].\n1 <= Node.val <= 231 - 1\nroot.val == min(root.left.val, root.right.val)\xc2\xa0for internal node tree.\n\n" b'There room n bulbs labeled 1 n turned initially, four buttons wall. Each four buttons different functionality where:\n\nButton 1: Flips status bulbs.\nButton 2: Flips status bulbs even labels (i.e., 2, 4, ...).\nButton 3: Flips status bulbs odd labels (i.e., 1, 3, ...).\nButton 4: Flips status bulbs label j = 3k + 1 k = 0, 1, 2, ... (i.e., 1, 4, 7, 10, ...).\n\nYou must make exactly presses button presses total. For press, may pick four buttons press.\nGiven two integers n presses, return number different possible statuses performing presses button presses.\n\xc2\xa0\nExample 1:\nInput: n = 1, presses = 1\nOutput: 2\nExplanation: Status be:\n- [off] pressing button 1\n- [on] pressing button 2\n\nExample 2:\nInput: n = 2, presses = 1\nOutput: 3\nExplanation: Status be:\n- [off, off] pressing button 1\n- [on, off] pressing button 2\n- [off, on] pressing button 3\n\nExample 3:\nInput: n = 3, presses = 1\nOutput: 4\nExplanation: Status be:\n- [off, off, off] pressing button 1\n- [off, on, off] pressing button 2\n- [on, off, on] pressing button 3\n- [off, on, on] pressing button 4\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 1000\n0 <= presses <= 1000\n\n' b"Given integer array\xc2\xa0nums, return number longest increasing subsequences.\nNotice sequence strictly increasing.\n\xc2\xa0\nExample 1:\nInput: nums = [1,3,5,4,7]\nOutput: 2\nExplanation: The two longest increasing subsequences [1, 3, 4, 7] [1, 3, 5, 7].\n\nExample 2:\nInput: nums = [2,2,2,2,2]\nOutput: 5\nExplanation: The length longest continuous increasing subsequence 1, 5 subsequences' length 1, output 5.\n\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 2000\n-106 <= nums[i] <= 106\n\n" b'Given unsorted array integers nums, return length longest continuous increasing subsequence (i.e. subarray). The subsequence must strictly increasing.\nA continuous increasing subsequence defined two indices l r (l < r) [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] l <= < r, nums[i] < nums[i + 1].\n\xc2\xa0\nExample 1:\nInput: nums = [1,3,5,4,7]\nOutput: 3\nExplanation: The longest continuous increasing subsequence [1,3,5] length 3.\nEven though [1,3,5,7] increasing subsequence, continuous elements 5 7 separated element\n4.\n\nExample 2:\nInput: nums = [2,2,2,2,2]\nOutput: 1\nExplanation: The longest continuous increasing subsequence [2] length 1. Note must strictly\nincreasing.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n-109 <= nums[i] <= 109\n\n' b"You asked cut trees forest golf event. The forest represented x n matrix. In matrix:\n\n0 means cell cannot walked through.\n1 represents empty cell walked through.\nA number greater 1 represents tree cell walked through, number tree's height.\n\nIn one step, walk four directions: north, east, south, west. If standing cell tree, choose whether cut off.\nYou must cut trees order shortest tallest. When cut tree, value cell becomes 1 (an empty cell).\nStarting point (0, 0), return minimum steps need walk cut trees. If cannot cut trees, return -1.\nYou guaranteed two trees height, least one tree needs cut off.\n\xc2\xa0\nExample 1:\n\nInput: forest = [[1,2,3],[0,0,4],[7,6,5]]\nOutput: 6\nExplanation: Following path allows cut trees shortest tallest 6 steps.\n\nExample 2:\n\nInput: forest = [[1,2,3],[0,0,0],[7,6,5]]\nOutput: -1\nExplanation: The trees bottom row cannot accessed middle row blocked.\n\nExample 3:\nInput: forest = [[2,3,4],[0,0,5],[8,7,6]]\nOutput: 6\nExplanation: You follow path Example 1 cut trees.\nNote cut first tree (0, 0) making steps.\n\n\xc2\xa0\nConstraints:\n\nm == forest.length\nn == forest[i].length\n1 <= m, n <= 50\n0 <= forest[i][j] <= 109\n\n" b'Design data structure initialized list different words. Provided string, determine change exactly one character string match word data structure.\nImplement the\xc2\xa0MagicDictionary\xc2\xa0class:\n\nMagicDictionary()\xc2\xa0Initializes object.\nvoid buildDict(String[]\xc2\xa0dictionary)\xc2\xa0Sets data structure\xc2\xa0with array distinct strings dictionary.\nbool search(String searchWord) Returns true change exactly one character searchWord match string data structure, otherwise returns false.\n\n\xc2\xa0\nExample 1:\nInput\n["MagicDictionary", "buildDict", "search", "search", "search", "search"]\n[[], [["hello", "leetcode"]], ["hello"], ["hhllo"], ["hell"], ["leetcoded"]]\nOutput\n[null, null, false, true, false, false]\n\nExplanation\nMagicDictionary magicDictionary = new MagicDictionary();\nmagicDictionary.buildDict(["hello", "leetcode"]);\nmagicDictionary.search("hello"); // return False\nmagicDictionary.search("hhllo"); // We change second \'h\' \'e\' match "hello" return True\nmagicDictionary.search("hell"); // return False\nmagicDictionary.search("leetcoded"); // return False\n\n\xc2\xa0\nConstraints:\n\n1 <=\xc2\xa0dictionary.length <= 100\n1 <=\xc2\xa0dictionary[i].length <= 100\ndictionary[i] consists lower-case English letters.\nAll strings in\xc2\xa0dictionary\xc2\xa0are distinct.\n1 <=\xc2\xa0searchWord.length <= 100\nsearchWord\xc2\xa0consists lower-case English letters.\nbuildDict\xc2\xa0will called search.\nAt 100 calls made search.\n\n' b'Design map allows following:\n\nMaps string key given value.\nReturns sum values key prefix equal given string.\n\nImplement MapSum class:\n\nMapSum() Initializes MapSum object.\nvoid insert(String key, int val) Inserts key-val pair map. If key already existed, original key-value pair overridden new one.\nint sum(string prefix) Returns sum pairs\' value whose key starts prefix.\n\n\xc2\xa0\nExample 1:\nInput\n["MapSum", "insert", "sum", "insert", "sum"]\n[[], ["apple", 3], ["ap"], ["app", 2], ["ap"]]\nOutput\n[null, null, 3, null, 5]\n\nExplanation\nMapSum mapSum = new MapSum();\nmapSum.insert("apple", 3); \nmapSum.sum("ap"); // return 3 (apple = 3)\nmapSum.insert("app", 2); \nmapSum.sum("ap"); // return 5 (apple + app = 3 + 2 = 5)\n\n\xc2\xa0\nConstraints:\n\n1 <= key.length, prefix.length <= 50\nkey prefix consist lowercase English letters.\n1 <= val <= 1000\nAt 50 calls made insert sum.\n\n' b'Given string containing three types characters: \'(\', \')\' \'*\', return true valid.\nThe following rules define valid string:\n\nAny left parenthesis \'(\' must corresponding right parenthesis \')\'.\nAny right parenthesis \')\' must corresponding left parenthesis \'(\'.\nLeft parenthesis \'(\' must go corresponding right parenthesis \')\'.\n\'*\' could treated single right parenthesis \')\' single left parenthesis \'(\' empty string "".\n\n\xc2\xa0\nExample 1:\nInput: = "()"\nOutput: true\nExample 2:\nInput: = "(*)"\nOutput: true\nExample 3:\nInput: = "(*))"\nOutput: true\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 100\ns[i] \'(\', \')\' \'*\'.\n\n' b'You given integer array cards length 4. You four cards, containing number range [1, 9]. You arrange numbers cards mathematical expression using operators [\'+\', \'-\', \'*\', \'/\'] parentheses \'(\' \')\' get value 24.\nYou restricted following rules:\n\nThe division operator \'/\' represents real division, integer division.\n\n\t\nFor example, 4 / (1 - 2 / 3) = 4 / (1 / 3) = 12.\n\n\nEvery operation done two numbers. In particular, cannot use \'-\' unary operator.\n\t\nFor example, cards = [1, 1, 1, 1], expression "-1 - 1 - 1 - 1" allowed.\n\n\nYou cannot concatenate numbers together\n\t\nFor example, cards = [1, 2, 1, 2], expression "12 + 12" valid.\n\n\n\nReturn true get expression evaluates 24, false otherwise.\n\xc2\xa0\nExample 1:\nInput: cards = [4,1,8,7]\nOutput: true\nExplanation: (8-4) * (7-1) = 24\n\nExample 2:\nInput: cards = [1,2,1,2]\nOutput: false\n\n\xc2\xa0\nConstraints:\n\ncards.length == 4\n1 <= cards[i] <= 9\n\n' b'Given string s, return true palindrome deleting one character it.\n\xc2\xa0\nExample 1:\nInput: = "aba"\nOutput: true\n\nExample 2:\nInput: = "abca"\nOutput: true\nExplanation: You could delete character \'c\'.\n\nExample 3:\nInput: = "abc"\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 105\ns consists lowercase English letters.\n\n' b'You keeping score baseball game strange rules. The game consists several rounds, scores past rounds may affect future rounds\' scores.\nAt beginning game, start empty record. You given list strings ops, ops[i] ith operation must apply record one following:\n\nAn integer x - Record new score x.\n"+" - Record new score sum previous two scores. It guaranteed always two previous scores.\n"D" - Record new score double previous score. It guaranteed always previous score.\n"C" - Invalidate previous score, removing record. It guaranteed always previous score.\n\nReturn sum scores record. The test cases generated answer fits 32-bit integer.\n\xc2\xa0\nExample 1:\nInput: ops = ["5","2","C","D","+"]\nOutput: 30\nExplanation:\n"5" - Add 5 record, record [5].\n"2" - Add 2 record, record [5, 2].\n"C" - Invalidate remove previous score, record [5].\n"D" - Add 2 * 5 = 10 record, record [5, 10].\n"+" - Add 5 + 10 = 15 record, record [5, 10, 15].\nThe total sum 5 + 10 + 15 = 30.\n\nExample 2:\nInput: ops = ["5","-2","4","C","D","9","+","+"]\nOutput: 27\nExplanation:\n"5" - Add 5 record, record [5].\n"-2" - Add -2 record, record [5, -2].\n"4" - Add 4 record, record [5, -2, 4].\n"C" - Invalidate remove previous score, record [5, -2].\n"D" - Add 2 * -2 = -4 record, record [5, -2, -4].\n"9" - Add 9 record, record [5, -2, -4, 9].\n"+" - Add -4 + 9 = 5 record, record [5, -2, -4, 9, 5].\n"+" - Add 9 + 5 = 14 record, record [5, -2, -4, 9, 5, 14].\nThe total sum 5 + -2 + -4 + 9 + 5 + 14 = 27.\n\nExample 3:\nInput: ops = ["1","C"]\nOutput: 0\nExplanation:\n"1" - Add 1 record, record [1].\n"C" - Invalidate remove previous score, record [].\nSince record empty, total sum 0.\n\n\xc2\xa0\nConstraints:\n\n1 <= ops.length <= 1000\nops[i] "C", "D", "+", string representing integer range [-3 * 104, 3 * 104].\nFor operation "+", always least two previous scores record.\nFor operations "C" "D", always least one previous score record.\n\n' b'In problem, tree undirected graph connected cycles.\nYou given graph started tree n nodes labeled 1 n, one additional edge added. The added edge two different vertices chosen 1 n, edge already existed. The graph represented array edges length n edges[i] = [ai, bi] indicates edge nodes ai bi graph.\nReturn edge removed resulting graph tree n nodes. If multiple answers, return answer occurs last input.\n\xc2\xa0\nExample 1:\n\nInput: edges = [[1,2],[1,3],[2,3]]\nOutput: [2,3]\n\nExample 2:\n\nInput: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\nOutput: [1,4]\n\n\xc2\xa0\nConstraints:\n\nn == edges.length\n3 <= n <= 1000\nedges[i].length == 2\n1 <= ai < bi <= edges.length\nai != bi\nThere repeated edges.\nThe given graph connected.\n\n' b'In problem, rooted tree directed graph that, exactly one node (the root) nodes descendants node, plus every node exactly one parent, except root node parents.\nThe given input directed graph started rooted tree n nodes (with distinct values 1 n), one additional directed edge added. The added edge two different vertices chosen 1 n, edge already existed.\nThe resulting graph given 2D-array edges. Each element edges pair [ui, vi] represents directed edge connecting nodes ui vi, ui parent child vi.\nReturn edge removed resulting graph rooted tree n nodes. If multiple answers, return answer occurs last given 2D-array.\n\xc2\xa0\nExample 1:\n\nInput: edges = [[1,2],[1,3],[2,3]]\nOutput: [2,3]\n\nExample 2:\n\nInput: edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\nOutput: [4,1]\n\n\xc2\xa0\nConstraints:\n\nn == edges.length\n3 <= n <= 1000\nedges[i].length == 2\n1 <= ui, vi <= n\nui != vi\n\n' b'Given two strings b, return minimum number times repeat string string b substring it. If impossible b\xe2\x80\x8b\xe2\x80\x8b\xe2\x80\x8b\xe2\x80\x8b\xe2\x80\x8b\xe2\x80\x8b substring repeating it, return -1.\nNotice: string "abc" repeated 0 times "", repeated 1 time "abc" repeated 2 times "abcabc".\n\xc2\xa0\nExample 1:\nInput: = "abcd", b = "cdabcdab"\nOutput: 3\nExplanation: We return 3 repeating three times "abcdabcdabcd", b substring it.\n\nExample 2:\nInput: = "a", b = "aa"\nOutput: 2\n\n\xc2\xa0\nConstraints:\n\n1 <= a.length, b.length <= 104\na b consist lowercase English letters.\n\n' b'Given root binary tree, return length longest path, node path value. This path may may pass root.\nThe length path two nodes represented number edges them.\n\xc2\xa0\nExample 1:\n\nInput: root = [5,4,5,1,1,5]\nOutput: 2\n\nExample 2:\n\nInput: root = [1,4,5,4,4,5]\nOutput: 2\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [0, 104].\n-1000 <= Node.val <= 1000\nThe depth tree exceed 1000.\n\n' b'On n x n chessboard, knight starts cell (row, column) attempts make exactly k moves. The rows columns 0-indexed, top-left cell (0, 0), bottom-right cell (n - 1, n - 1).\nA chess knight eight possible moves make, illustrated below. Each move two cells cardinal direction, one cell orthogonal direction.\n\nEach time knight move, chooses one eight possible moves uniformly random (even piece would go chessboard) moves there.\nThe knight continues moving made exactly k moves moved chessboard.\nReturn probability knight remains board stopped moving.\n\xc2\xa0\nExample 1:\nInput: n = 3, k = 2, row = 0, column = 0\nOutput: 0.06250\nExplanation: There two moves (to (1,2), (2,1)) keep knight board.\nFrom positions, also two moves keep knight board.\nThe total probability knight stays board 0.0625.\n\nExample 2:\nInput: n = 1, k = 0, row = 0, column = 0\nOutput: 1.00000\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 25\n0 <= k <= 100\n0 <= row, column <= n\n\n' b'Given integer array nums integer k, find three non-overlapping subarrays length k maximum sum return them.\nReturn result list indices representing starting position interval (0-indexed). If multiple answers, return lexicographically smallest one.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,1,2,6,7,5,1], k = 2\nOutput: [0,3,5]\nExplanation: Subarrays [1, 2], [2, 6], [7, 5] correspond starting indices [0, 3, 5].\nWe could also taken [2, 1], answer [1, 3, 5] would lexicographically larger.\n\nExample 2:\nInput: nums = [1,2,1,2,1,2,1,2,1], k = 2\nOutput: [0,2,4]\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 2 * 104\n1 <= nums[i] <\xc2\xa0216\n1 <= k <= floor(nums.length / 3)\n\n' b"You data structure employee information, including employee's unique ID, importance value, direct subordinates' IDs.\nYou given array employees employees where:\n\nemployees[i].id ID ith employee.\nemployees[i].importance importance value ith employee.\nemployees[i].subordinates list IDs direct subordinates ith employee.\n\nGiven integer id represents employee's ID, return total importance value employee direct indirect subordinates.\n\xc2\xa0\nExample 1:\n\nInput: employees = [[1,5,[2,3]],[2,3,[]],[3,3,[]]], id = 1\nOutput: 11\nExplanation: Employee 1 importance value 5 two direct subordinates: employee 2 employee 3.\nThey importance value 3.\nThus, total importance value employee 1 5 + 3 + 3 = 11.\n\nExample 2:\n\nInput: employees = [[1,2,[5]],[5,-3,[]]], id = 5\nOutput: -3\nExplanation: Employee 5 importance value -3 direct subordinates.\nThus, total importance value employee 5 -3.\n\n\xc2\xa0\nConstraints:\n\n1 <= employees.length <= 2000\n1 <= employees[i].id <= 2000\nAll employees[i].id unique.\n-100 <= employees[i].importance <= 100\nOne employee one direct leader may several subordinates.\nThe IDs employees[i].subordinates valid IDs.\n\n" b'We given n different types stickers. Each sticker lowercase English word it.\nYou would like spell given string target cutting individual letters collection stickers rearranging them. You use sticker want, infinite quantities sticker.\nReturn minimum number stickers need spell target. If task impossible, return -1.\nNote: In test cases, words chosen randomly 1000 common US English words, target chosen concatenation two random words.\n\xc2\xa0\nExample 1:\nInput: stickers = ["with","example","science"], target = "thehat"\nOutput: 3\nExplanation:\nWe use 2 "with" stickers, 1 "example" sticker.\nAfter cutting rearrange letters stickers, form target "thehat".\nAlso, minimum number stickers necessary form target string.\n\nExample 2:\nInput: stickers = ["notice","possible"], target = "basicbasic"\nOutput: -1\nExplanation:\nWe cannot form target "basicbasic" cutting letters given stickers.\n\n\xc2\xa0\nConstraints:\n\nn == stickers.length\n1 <= n <= 50\n1 <= stickers[i].length <= 10\n1 <= target.length <= 15\nstickers[i] target consist lowercase English letters.\n\n' b'Given array strings words integer k, return k frequent strings.\nReturn answer sorted frequency highest lowest. Sort words frequency lexicographical order.\n\xc2\xa0\nExample 1:\nInput: words = ["i","love","leetcode","i","love","coding"], k = 2\nOutput: ["i","love"]\nExplanation: "i" "love" two frequent words.\nNote "i" comes "love" due lower alphabetical order.\n\nExample 2:\nInput: words = ["the","day","is","sunny","the","the","the","sunny","is","is"], k = 4\nOutput: ["the","is","sunny","day"]\nExplanation: "the", "is", "sunny" "day" four frequent words, number occurrence 4, 3, 2 1 respectively.\n\n\xc2\xa0\nConstraints:\n\n1 <= words.length <= 500\n1 <= words[i] <= 10\nwords[i] consists lowercase English letters.\nk range [1, The number unique words[i]]\n\n\xc2\xa0\nFollow-up: Could solve O(n log(k)) time O(n) extra space?\n' b'Given positive integer, check whether alternating bits: namely, two adjacent bits always different values.\n\xc2\xa0\nExample 1:\nInput: n = 5\nOutput: true\nExplanation: The binary representation 5 is: 101\n\nExample 2:\nInput: n = 7\nOutput: false\nExplanation: The binary representation 7 is: 111.\nExample 3:\nInput: n = 11\nOutput: false\nExplanation: The binary representation 11 is: 1011.\n\xc2\xa0\nConstraints:\n\n1 <= n <= 231 - 1\n\n' b"You given x n binary matrix grid. An island group 1's (representing land) connected 4-directionally (horizontal vertical.) You may assume four edges grid surrounded water.\nThe area island number cells value 1 island.\nReturn maximum area island grid. If island, return 0.\n\xc2\xa0\nExample 1:\n\nInput: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\nOutput: 6\nExplanation: The answer 11, island must connected 4-directionally.\n\nExample 2:\nInput: grid = [[0,0,0,0,0,0,0,0]]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 50\ngrid[i][j] either 0 1.\n\n" b'Given binary string s, return number non-empty substrings number 0\'s 1\'s, 0\'s 1\'s substrings grouped consecutively.\nSubstrings occur multiple times counted number times occur.\n\xc2\xa0\nExample 1:\nInput: = "00110011"\nOutput: 6\nExplanation: There 6 substrings equal number consecutive 1\'s 0\'s: "0011", "01", "1100", "10", "0011", "01".\nNotice substrings repeat counted number times occur.\nAlso, "00110011" valid substring 0\'s (and 1\'s) grouped together.\n\nExample 2:\nInput: = "10101"\nOutput: 4\nExplanation: There 4 substrings: "10", "01", "10", "01" equal number consecutive 1\'s 0\'s.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 105\ns[i] either \'0\' \'1\'.\n\n' b'Given non-empty array non-negative integers nums, degree array defined maximum frequency one elements.\nYour task find smallest possible length (contiguous) subarray nums, degree nums.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,2,3,1]\nOutput: 2\nExplanation: \nThe input array degree 2 elements 1 2 appear twice.\nOf subarrays degree:\n[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\nThe shortest length 2. So return 2.\n\nExample 2:\nInput: nums = [1,2,2,3,1,4,2]\nOutput: 6\nExplanation: \nThe degree 3 element 2 repeated 3 times.\nSo [2,2,3,1,4,2] shortest subarray, therefore returning 6.\n\n\xc2\xa0\nConstraints:\n\nnums.length 1 50,000.\nnums[i] integer 0 49,999.\n\n' b'Given integer array nums integer k, return true possible divide array k non-empty subsets whose sums equal.\n\xc2\xa0\nExample 1:\nInput: nums = [4,3,2,3,5,2,1], k = 4\nOutput: true\nExplanation: It possible divide 4 subsets (5), (1, 4), (2,3), (2,3) equal sums.\n\nExample 2:\nInput: nums = [1,2,3,4], k = 3\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= k <= nums.length <= 16\n1 <= nums[i] <= 104\nThe frequency element range [1, 4].\n\n' b'There several squares dropped onto X-axis 2D plane.\nYou given 2D integer array positions positions[i] = [lefti, sideLengthi] represents ith square side length sideLengthi dropped left edge aligned X-coordinate lefti.\nEach square dropped one time height landed squares. It falls downward (negative Y direction) either lands top side another square X-axis. A square brushing left/right side another square count landing it. Once lands, freezes place cannot moved.\nAfter square dropped, must record height current tallest stack squares.\nReturn integer array ans ans[i] represents height described dropping ith square.\n\xc2\xa0\nExample 1:\n\nInput: positions = [[1,2],[2,3],[6,1]]\nOutput: [2,5,5]\nExplanation:\nAfter first drop, tallest stack square 1 height 2.\nAfter second drop, tallest stack squares 1 2 height 5.\nAfter third drop, tallest stack still squares 1 2 height 5.\nThus, return answer [2, 5, 5].\n\nExample 2:\nInput: positions = [[100,100],[200,100]]\nOutput: [100,100]\nExplanation:\nAfter first drop, tallest stack square 1 height 100.\nAfter second drop, tallest stack either square 1 square 2, heights 100.\nThus, return answer [100, 100].\nNote square 2 brushes right side square 1, count landing it.\n\n\xc2\xa0\nConstraints:\n\n1 <= positions.length <= 1000\n1 <= lefti <= 108\n1 <= sideLengthi <= 106\n\n' b"You given root binary search tree (BST) integer val.\nFind node BST node's value equals val return subtree rooted node. If node exist, return null.\n\xc2\xa0\nExample 1:\n\nInput: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]\n\nExample 2:\n\nInput: root = [4,2,7,1,3], val = 5\nOutput: []\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 5000].\n1 <= Node.val <= 107\nroot binary search tree.\n1 <= val <= 107\n\n" b"You given root node binary search tree (BST) value insert tree. Return root node BST insertion. It guaranteed new value exist original BST.\nNotice\xc2\xa0that may exist\xc2\xa0multiple valid ways the\xc2\xa0insertion, long tree remains BST insertion. You return them.\n\xc2\xa0\nExample 1:\n\nInput: root = [4,2,7,1,3], val = 5\nOutput: [4,2,7,1,3,5]\nExplanation: Another accepted tree is:\n\n\nExample 2:\nInput: root = [40,20,60,10,30,50,70], val = 25\nOutput: [40,20,60,10,30,50,70,null,null,25]\n\nExample 3:\nInput: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\nOutput: [4,2,7,1,3,5]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes in\xc2\xa0the tree range [0,\xc2\xa0104].\n-108 <= Node.val <= 108\nAll values Node.val unique.\n-108 <= val <= 108\nIt's guaranteed val exist original BST.\n\n" b'Design class find kth largest element stream. Note kth largest element sorted order, kth distinct element.\nImplement KthLargest class:\n\nKthLargest(int k, int[] nums) Initializes object integer k stream integers nums.\nint add(int val) Appends integer val stream returns element representing kth largest element stream.\n\n\xc2\xa0\nExample 1:\nInput\n["KthLargest", "add", "add", "add", "add", "add"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\nOutput\n[null, 4, 5, 5, 8, 8]\n\nExplanation\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3); // return 4\nkthLargest.add(5); // return 5\nkthLargest.add(10); // return 5\nkthLargest.add(9); // return 8\nkthLargest.add(4); // return 8\n\n\xc2\xa0\nConstraints:\n\n1 <= k <= 104\n0 <= nums.length <= 104\n-104 <= nums[i] <= 104\n-104 <= val <= 104\nAt 104 calls made add.\nIt guaranteed least k elements array search kth element.\n\n' b'Given array integers nums sorted ascending order, integer target, write function search target nums. If target exists, return index. Otherwise, return -1.\nYou must write algorithm O(log n) runtime complexity.\n\xc2\xa0\nExample 1:\nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists nums index 4\n\nExample 2:\nInput: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 exist nums return -1\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n-104 < nums[i], target < 104\nAll integers nums unique.\nnums sorted ascending order.\n\n' b'Design HashSet without using built-in hash table libraries.\nImplement MyHashSet class:\n\nvoid add(key) Inserts value key HashSet.\nbool contains(key) Returns whether value key exists HashSet not.\nvoid remove(key) Removes value key HashSet. If key exist HashSet, nothing.\n\n\xc2\xa0\nExample 1:\nInput\n["MyHashSet", "add", "add", "contains", "contains", "add", "contains", "remove", "contains"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\nOutput\n[null, null, null, true, false, null, true, null, false]\n\nExplanation\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1); // set = [1]\nmyHashSet.add(2); // set = [1, 2]\nmyHashSet.contains(1); // return True\nmyHashSet.contains(3); // return False, (not found)\nmyHashSet.add(2); // set = [1, 2]\nmyHashSet.contains(2); // return True\nmyHashSet.remove(2); // set = [1]\nmyHashSet.contains(2); // return False, (already removed)\n\xc2\xa0\nConstraints:\n\n0 <= key <= 106\nAt 104 calls made add, remove, contains.\n\n' b'Design HashMap without using built-in hash table libraries.\nImplement MyHashMap class:\n\nMyHashMap() initializes object empty map.\nvoid put(int key, int value) inserts (key, value) pair HashMap. If key already exists map, update corresponding value.\nint get(int key) returns value specified key mapped, -1 map contains mapping key.\nvoid remove(key) removes key corresponding value map contains mapping key.\n\n\xc2\xa0\nExample 1:\nInput\n["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\nOutput\n[null, null, null, 1, -1, null, 1, null, -1]\n\nExplanation\nMyHashMap myHashMap = new MyHashMap();\nmyHashMap.put(1, 1); // The map [[1,1]]\nmyHashMap.put(2, 2); // The map [[1,1], [2,2]]\nmyHashMap.get(1); // return 1, The map [[1,1], [2,2]]\nmyHashMap.get(3); // return -1 (i.e., found), The map [[1,1], [2,2]]\nmyHashMap.put(2, 1); // The map [[1,1], [2,1]] (i.e., update existing value)\nmyHashMap.get(2); // return 1, The map [[1,1], [2,1]]\nmyHashMap.remove(2); // remove mapping 2, The map [[1,1]]\nmyHashMap.get(2); // return -1 (i.e., found), The map [[1,1]]\n\n\xc2\xa0\nConstraints:\n\n0 <= key, value <= 106\nAt 104 calls made put, get, remove.\n\n' b'Design implementation linked list. You choose use singly doubly linked list.\nA node singly linked list two attributes: val next. val value current node, next pointer/reference next node.\nIf want use doubly linked list, need one attribute prev indicate previous node linked list. Assume nodes linked list 0-indexed.\nImplement MyLinkedList class:\n\nMyLinkedList() Initializes MyLinkedList object.\nint get(int index) Get value indexth node linked list. If index invalid, return -1.\nvoid addAtHead(int val) Add node value val first element linked list. After insertion, new node first node linked list.\nvoid addAtTail(int val) Append node value val last element linked list.\nvoid addAtIndex(int index, int val) Add node value val indexth node linked list. If index equals length linked list, node appended end linked list. If index greater length, node inserted.\nvoid deleteAtIndex(int index) Delete indexth node linked list, index valid.\n\n\xc2\xa0\nExample 1:\nInput\n["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]\n[[], [1], [3], [1, 2], [1], [1], [1]]\nOutput\n[null, null, null, null, 2, null, 3]\n\nExplanation\nMyLinkedList myLinkedList = new MyLinkedList();\nmyLinkedList.addAtHead(1);\nmyLinkedList.addAtTail(3);\nmyLinkedList.addAtIndex(1, 2); // linked list becomes 1->2->3\nmyLinkedList.get(1); // return 2\nmyLinkedList.deleteAtIndex(1); // linked list 1->3\nmyLinkedList.get(1); // return 3\n\n\xc2\xa0\nConstraints:\n\n0 <= index, val <= 1000\nPlease use built-in LinkedList library.\nAt 2000 calls made get, addAtHead, addAtTail, addAtIndex deleteAtIndex.\n\n' b'Given string s, return string replacing every uppercase letter lowercase letter.\n\xc2\xa0\nExample 1:\nInput: = "Hello"\nOutput: "hello"\n\nExample 2:\nInput: = "here"\nOutput: "here"\n\nExample 3:\nInput: = "LOVELY"\nOutput: "lovely"\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 100\ns consists printable ASCII characters.\n\n' b'You given integer n array unique integers blacklist. Design algorithm pick random integer range [0, n - 1] blacklist. Any integer mentioned range blacklist equally likely returned.\nOptimize algorithm minimizes number calls built-in random function language.\nImplement Solution class:\n\nSolution(int n, int[] blacklist) Initializes object integer n blacklisted integers blacklist.\nint pick() Returns random integer range [0, n - 1] blacklist.\n\n\xc2\xa0\nExample 1:\nInput\n["Solution", "pick", "pick", "pick", "pick", "pick", "pick", "pick"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]\nOutput\n[null, 0, 4, 1, 6, 1, 0, 4]\n\nExplanation\nSolution solution = new Solution(7, [2, 3, 5]);\nsolution.pick(); // return 0, integer [0,1,4,6] ok. Note every call pick,\n // 0, 1, 4, 6 must equally likely returned (i.e., probability 1/4).\nsolution.pick(); // return 4\nsolution.pick(); // return 1\nsolution.pick(); // return 6\nsolution.pick(); // return 1\nsolution.pick(); // return 0\nsolution.pick(); // return 4\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 109\n0 <= blacklist.length <- min(105, n - 1)\n0 <= blacklist[i] < n\nAll values blacklist unique.\nAt 2 * 104 calls made pick.\n\n' b'Given two strings s1 and\xc2\xa0s2, return lowest ASCII sum deleted characters make two strings equal.\n\xc2\xa0\nExample 1:\nInput: s1 = "sea", s2 = "eat"\nOutput: 231\nExplanation: Deleting "s" "sea" adds ASCII value "s" (115) sum.\nDeleting "t" "eat" adds 116 sum.\nAt end, strings equal, 115 + 116 = 231 minimum sum possible achieve this.\n\nExample 2:\nInput: s1 = "delete", s2 = "leet"\nOutput: 403\nExplanation: Deleting "dee" "delete" turn string "let",\nadds 100[d] + 101[e] + 101[e] sum.\nDeleting "e" "leet" adds 101[e] sum.\nAt end, strings equal "let", answer 100+101+101+101 = 403.\nIf instead turned strings "lee" "eet", would get answers 433 417, higher.\n\n\xc2\xa0\nConstraints:\n\n1 <= s1.length, s2.length <= 1000\ns1 s2 consist lowercase English letters.\n\n' b'Given array integers nums integer k, return number contiguous subarrays product elements subarray strictly less k.\n\xc2\xa0\nExample 1:\nInput: nums = [10,5,2,6], k = 100\nOutput: 8\nExplanation: The 8 subarrays product less 100 are:\n[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\nNote [10, 5, 2] included product 100 strictly less k.\n\nExample 2:\nInput: nums = [1,2,3], k = 0\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 3 * 104\n1 <= nums[i] <= 1000\n0 <= k <= 106\n\n' b'You given array prices prices[i] price given stock ith day, integer fee representing transaction fee.\nFind maximum profit achieve. You may complete many transactions like, need pay transaction fee transaction.\nNote: You may engage multiple transactions simultaneously (i.e., must sell stock buy again).\n\xc2\xa0\nExample 1:\nInput: prices = [1,3,2,8,4,9], fee = 2\nOutput: 8\nExplanation: The maximum profit achieved by:\n- Buying prices[0] = 1\n- Selling prices[3] = 8\n- Buying prices[4] = 4\n- Selling prices[5] = 9\nThe total profit ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n\nExample 2:\nInput: prices = [1,3,7,5,10,3], fee = 3\nOutput: 6\n\n\xc2\xa0\nConstraints:\n\n1 <= prices.length <= 5 * 104\n1 <= prices[i] < 5 * 104\n0 <= fee < 5 * 104\n\n' b'A Range Module module tracks ranges numbers. Design data structure track ranges represented half-open intervals query them.\nA half-open interval [left, right) denotes real numbers x left <= x < right.\nImplement RangeModule class:\n\nRangeModule() Initializes object data structure.\nvoid addRange(int left, int right) Adds half-open interval [left, right), tracking every real number interval. Adding interval partially overlaps currently tracked numbers add numbers interval [left, right) already tracked.\nboolean queryRange(int left, int right) Returns true every real number interval [left, right) currently tracked, false otherwise.\nvoid removeRange(int left, int right) Stops tracking every real number currently tracked half-open interval [left, right).\n\n\xc2\xa0\nExample 1:\nInput\n["RangeModule", "addRange", "removeRange", "queryRange", "queryRange", "queryRange"]\n[[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]\nOutput\n[null, null, null, true, false, true]\n\nExplanation\nRangeModule rangeModule = new RangeModule();\nrangeModule.addRange(10, 20);\nrangeModule.removeRange(14, 16);\nrangeModule.queryRange(10, 14); // return True,(Every number [10, 14) tracked)\nrangeModule.queryRange(13, 15); // return False,(Numbers like 14, 14.03, 14.17 [13, 15) tracked)\nrangeModule.queryRange(16, 17); // return True, (The number 16 [16, 17) still tracked, despite remove operation)\n\n\xc2\xa0\nConstraints:\n\n1 <= left < right <= 109\nAt 104 calls made addRange, queryRange, removeRange.\n\n' b'We two special characters:\n\nThe first character represented one bit 0.\nThe second character represented two bits (10 11).\n\nGiven binary array bits ends 0, return true last character must one-bit character.\n\xc2\xa0\nExample 1:\nInput: bits = [1,0,0]\nOutput: true\nExplanation: The way decode two-bit character one-bit character.\nSo last character one-bit character.\n\nExample 2:\nInput: bits = [1,1,1,0]\nOutput: false\nExplanation: The way decode two-bit character two-bit character.\nSo last character one-bit character.\n\n\xc2\xa0\nConstraints:\n\n1 <= bits.length <= 1000\nbits[i] either 0 1.\n\n' b'Given two integer arrays nums1 nums2, return maximum length subarray appears arrays.\n\xc2\xa0\nExample 1:\nInput: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\nOutput: 3\nExplanation: The repeated subarray maximum length [3,2,1].\n\nExample 2:\nInput: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\nOutput: 5\n\n\xc2\xa0\nConstraints:\n\n1 <= nums1.length, nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 100\n\n' b'The distance pair integers b defined absolute difference b.\nGiven integer array nums integer k, return kth smallest distance among pairs nums[i] nums[j] 0 <= < j < nums.length.\n\xc2\xa0\nExample 1:\nInput: nums = [1,3,1], k = 1\nOutput: 0\nExplanation: Here pairs:\n(1,3) -> 2\n(1,1) -> 0\n(3,1) -> 2\nThen 1st smallest distance pair (1,1), distance 0.\n\nExample 2:\nInput: nums = [1,1,1], k = 2\nOutput: 0\n\nExample 3:\nInput: nums = [1,6,1], k = 3\nOutput: 5\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n2 <= n <= 104\n0 <= nums[i] <= 106\n1 <= k <= n * (n - 1) / 2\n\n' b'Given array strings words representing English Dictionary, return longest word words built one character time words words.\nIf one possible answer, return longest word smallest lexicographical order. If answer, return empty string.\n\xc2\xa0\nExample 1:\nInput: words = ["w","wo","wor","worl","world"]\nOutput: "world"\nExplanation: The word "world" built one character time "w", "wo", "wor", "worl".\n\nExample 2:\nInput: words = ["a","banana","app","appl","ap","apply","apple"]\nOutput: "apple"\nExplanation: Both "apply" "apple" built words dictionary. However, "apple" lexicographically smaller "apply".\n\n\xc2\xa0\nConstraints:\n\n1 <= words.length <= 1000\n1 <= words[i].length <= 30\nwords[i] consists lowercase English letters.\n\n' b'Given list accounts element accounts[i] list strings, first element accounts[i][0] name, rest elements emails representing emails account.\nNow, would like merge accounts. Two accounts definitely belong person common email accounts. Note even two accounts name, may belong different people people could name. A person number accounts initially, accounts definitely name.\nAfter merging accounts, return accounts following format: first element account name, rest elements emails sorted order. The accounts returned order.\n\xc2\xa0\nExample 1:\nInput: accounts = [["John","johnsmith@mail.com","john_newyork@mail.com"],["John","johnsmith@mail.com","john00@mail.com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]\nOutput: [["John","john00@mail.com","john_newyork@mail.com","johnsmith@mail.com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]\nExplanation:\nThe first second John\'s person common email "johnsmith@mail.com".\nThe third John Mary different people none email addresses used accounts.\nWe could return lists order, example answer [[\'Mary\', \'mary@mail.com\'], [\'John\', \'johnnybravo@mail.com\'], \n[\'John\', \'john00@mail.com\', \'john_newyork@mail.com\', \'johnsmith@mail.com\']] would still accepted.\n\nExample 2:\nInput: accounts = [["Gabe","Gabe0@m.co","Gabe3@m.co","Gabe1@m.co"],["Kevin","Kevin3@m.co","Kevin5@m.co","Kevin0@m.co"],["Ethan","Ethan5@m.co","Ethan4@m.co","Ethan0@m.co"],["Hanzo","Hanzo3@m.co","Hanzo1@m.co","Hanzo0@m.co"],["Fern","Fern5@m.co","Fern1@m.co","Fern0@m.co"]]\nOutput: [["Ethan","Ethan0@m.co","Ethan4@m.co","Ethan5@m.co"],["Gabe","Gabe0@m.co","Gabe1@m.co","Gabe3@m.co"],["Hanzo","Hanzo0@m.co","Hanzo1@m.co","Hanzo3@m.co"],["Kevin","Kevin0@m.co","Kevin3@m.co","Kevin5@m.co"],["Fern","Fern0@m.co","Fern1@m.co","Fern5@m.co"]]\n\n\xc2\xa0\nConstraints:\n\n1 <= accounts.length <= 1000\n2 <= accounts[i].length <= 10\n1 <= accounts[i][j].length <= 30\naccounts[i][0] consists English letters.\naccounts[i][j] (for j > 0) valid email.\n\n' b'Given C++ program, remove comments it. The program source array strings source source[i] ith line source code. This represents result splitting original source code string newline character \'\\n\'.\nIn C++, two types comments, line comments, block comments.\n\nThe string "//" denotes line comment, represents rest characters right line ignored.\nThe string "/*" denotes block comment, represents characters next (non-overlapping) occurrence "*/" ignored. (Here, occurrences happen reading order: line line left right.) To clear, string "/*/" yet end block comment, ending would overlapping beginning.\n\nThe first effective comment takes precedence others.\n\nFor example, string "//" occurs block comment, ignored.\nSimilarly, string "/*" occurs line block comment, also ignored.\n\nIf certain line code empty removing comments, must output line: string answer list non-empty.\nThere control characters, single quote, double quote characters.\n\nFor example, source = "string = "/* Not comment. */";" test case.\n\nAlso, nothing else defines macros interfere comments.\nIt guaranteed every open block comment eventually closed, "/*" outside line block comment always starts new comment.\nFinally, implicit newline characters deleted block comments. Please see examples details.\nAfter removing comments source code, return source code format.\n\xc2\xa0\nExample 1:\nInput: source = ["/*Test program */", "int main()", "{ ", " // variable declaration ", "int a, b, c;", "/* This test", " multiline ", " comment ", " testing */", "a = b + c;", "}"]\nOutput: ["int main()","{ "," ","int a, b, c;","a = b + c;","}"]\nExplanation: The line line code visualized below:\n/*Test program */\nint main()\n{ \n // variable declaration \nint a, b, c;\n/* This test\n multiline \n comment \n testing */\na = b + c;\n}\nThe string /* denotes block comment, including line 1 lines 6-9. The string // denotes line 4 comments.\nThe line line output code visualized below:\nint main()\n{ \n \nint a, b, c;\na = b + c;\n}\n\nExample 2:\nInput: source = ["a/*comment", "line", "more_comment*/b"]\nOutput: ["ab"]\nExplanation: The original source string "a/*comment\\nline\\nmore_comment*/b", bolded newline characters. After deletion, implicit newline characters deleted, leaving string "ab", delimited newline characters becomes ["ab"].\n\n\xc2\xa0\nConstraints:\n\n1 <= source.length <= 100\n0 <= source[i].length <= 80\nsource[i] consists printable ASCII characters.\nEvery open block comment eventually closed.\nThere single-quote or\xc2\xa0double-quote input.\n\n' b"Given array integers nums, calculate pivot index array.\nThe pivot index index sum numbers strictly left index equal sum numbers strictly index's right.\nIf index left edge array, left sum 0 elements left. This also applies right edge array.\nReturn leftmost pivot index. If index exists, return -1.\n\xc2\xa0\nExample 1:\nInput: nums = [1,7,3,6,5,6]\nOutput: 3\nExplanation:\nThe pivot index 3.\nLeft sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11\nRight sum = nums[4] + nums[5] = 5 + 6 = 11\n\nExample 2:\nInput: nums = [1,2,3]\nOutput: -1\nExplanation:\nThere index satisfies conditions problem statement.\nExample 3:\nInput: nums = [2,1,-1]\nOutput: 0\nExplanation:\nThe pivot index 0.\nLeft sum = 0 (no elements left index 0)\nRight sum = nums[1] + nums[2] = 1 + -1 = 0\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 104\n-1000 <= nums[i] <= 1000\n\n\xc2\xa0\nNote: This question as\xc2\xa01991:\xc2\xa0https://leetcode.com/problems/find-the-middle-index-in-array/\n" b'Given head singly linked list integer k, split linked list k consecutive linked list parts.\nThe length part equal possible: two parts size differing one. This may lead parts null.\nThe parts order occurrence input list, parts occurring earlier always size greater equal parts occurring later.\nReturn array k parts.\n\xc2\xa0\nExample 1:\n\nInput: head = [1,2,3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe first element output[0] output[0].val = 1, output[0].next = null.\nThe last element output[4] null, string representation ListNode [].\n\nExample 2:\n\nInput: head = [1,2,3,4,5,6,7,8,9,10], k = 3\nOutput: [[1,2,3,4],[5,6,7],[8,9,10]]\nExplanation:\nThe input split consecutive parts size difference 1, earlier parts larger size later parts.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes list range [0, 1000].\n0 <= Node.val <= 1000\n1 <= k <= 50\n\n' b'Given string formula representing chemical formula, return count atom.\nThe atomic element always starts uppercase character, zero lowercase letters, representing name.\nOne digits representing element\'s count may follow count greater 1. If count 1, digits follow.\n\nFor example, "H2O" "H2O2" possible, "H1O2" impossible.\n\nTwo formulas concatenated together produce another formula.\n\nFor example, "H2O2He3Mg4" also formula.\n\nA formula placed parentheses, count (optionally added) also formula.\n\nFor example, "(H2O2)" "(H2O2)3" formulas.\n\nReturn count elements string following form: first name (in sorted order), followed count (if count 1), followed second name (in sorted order), followed count (if count 1), on.\nThe test cases generated values output fit 32-bit integer.\n\xc2\xa0\nExample 1:\nInput: formula = "H2O"\nOutput: "H2O"\nExplanation: The count elements {\'H\': 2, \'O\': 1}.\n\nExample 2:\nInput: formula = "Mg(OH)2"\nOutput: "H2MgO2"\nExplanation: The count elements {\'H\': 2, \'Mg\': 1, \'O\': 2}.\n\nExample 3:\nInput: formula = "K4(ON(SO3)2)2"\nOutput: "K4N2O14S4"\nExplanation: The count elements {\'K\': 4, \'N\': 2, \'O\': 14, \'S\': 4}.\n\n\xc2\xa0\nConstraints:\n\n1 <= formula.length <= 1000\nformula consists English letters, digits, \'(\', \')\'.\nformula always valid.\n\n' b'A self-dividing number number divisible every digit contains.\n\nFor example, 128 self-dividing number 128 % 1 == 0, 128 % 2 == 0, 128 % 8 == 0.\n\nA self-dividing number allowed contain digit zero.\nGiven two integers left right, return list self-dividing numbers range [left, right].\n\xc2\xa0\nExample 1:\nInput: left = 1, right = 22\nOutput: [1,2,3,4,5,6,7,8,9,11,12,15,22]\nExample 2:\nInput: left = 47, right = 85\nOutput: [48,55,66,77]\n\n\xc2\xa0\nConstraints:\n\n1 <= left <= right <= 104\n\n' b'You implementing program use calendar. We add new event adding event cause double booking.\nA double booking happens two events non-empty intersection (i.e., moment common events.).\nThe event represented pair integers start end represents booking half-open interval [start, end), range real numbers x start <= x < end.\nImplement MyCalendar class:\n\nMyCalendar() Initializes calendar object.\nboolean book(int start, int end) Returns true event added calendar successfully without causing double booking. Otherwise, return false add event calendar.\n\n\xc2\xa0\nExample 1:\nInput\n["MyCalendar", "book", "book", "book"]\n[[], [10, 20], [15, 25], [20, 30]]\nOutput\n[null, true, false, true]\n\nExplanation\nMyCalendar myCalendar = new MyCalendar();\nmyCalendar.book(10, 20); // return True\nmyCalendar.book(15, 25); // return False, It booked time 15 already booked another event.\nmyCalendar.book(20, 30); // return True, The event booked, first event takes every time less 20, including 20.\n\xc2\xa0\nConstraints:\n\n0 <= start < end <= 109\nAt 1000 calls made book.\n\n' b'Given string s, return number different non-empty palindromic subsequences s. Since answer may large, return modulo 109 + 7.\nA subsequence string obtained deleting zero characters string.\nA sequence palindromic equal sequence reversed.\nTwo sequences a1, a2, ... b1, b2, ... different ai != bi.\n\xc2\xa0\nExample 1:\nInput: = "bccb"\nOutput: 6\nExplanation: The 6 different non-empty palindromic subsequences \'b\', \'c\', \'bb\', \'cc\', \'bcb\', \'bccb\'.\nNote \'bcb\' counted once, even though occurs twice.\n\nExample 2:\nInput: = "abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba"\nOutput: 104860361\nExplanation: There 3104860382 different non-empty palindromic subsequences, 104860361 modulo 109 + 7.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 1000\ns[i] either \'a\', \'b\', \'c\', \'d\'.\n\n' b'You implementing program use calendar. We add new event adding event cause triple booking.\nA triple booking happens three events non-empty intersection (i.e., moment common three events.).\nThe event represented pair integers start end represents booking half-open interval [start, end), range real numbers x start <= x < end.\nImplement MyCalendarTwo class:\n\nMyCalendarTwo() Initializes calendar object.\nboolean book(int start, int end) Returns true event added calendar successfully without causing triple booking. Otherwise, return false add event calendar.\n\n\xc2\xa0\nExample 1:\nInput\n["MyCalendarTwo", "book", "book", "book", "book", "book", "book"]\n[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]\nOutput\n[null, true, true, true, false, true, true]\n\nExplanation\nMyCalendarTwo myCalendarTwo = new MyCalendarTwo();\nmyCalendarTwo.book(10, 20); // return True, The event booked. \nmyCalendarTwo.book(50, 60); // return True, The event booked. \nmyCalendarTwo.book(10, 40); // return True, The event double booked. \nmyCalendarTwo.book(5, 15); // return False, The event cannot booked, would result triple booking.\nmyCalendarTwo.book(5, 10); // return True, The event booked, use time 10 already double booked.\nmyCalendarTwo.book(25, 55); // return True, The event booked, time [25, 40) double booked third event, time [40, 50) single booked, time [50, 55) double booked second event.\n\n\xc2\xa0\nConstraints:\n\n0 <= start < end <= 109\nAt 1000 calls made book.\n\n' b'A k-booking happens k events non-empty intersection (i.e., time common k events.)\nYou given events [start, end), given event, return integer k representing maximum k-booking previous events.\nImplement MyCalendarThree class:\n\nMyCalendarThree() Initializes object.\nint book(int start, int end) Returns integer k representing largest integer exists k-booking calendar.\n\n\xc2\xa0\nExample 1:\nInput\n["MyCalendarThree", "book", "book", "book", "book", "book", "book"]\n[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]\nOutput\n[null, 1, 1, 2, 3, 3, 3]\n\nExplanation\nMyCalendarThree myCalendarThree = new MyCalendarThree();\nmyCalendarThree.book(10, 20); // return 1, The first event booked disjoint, maximum k-booking 1-booking.\nmyCalendarThree.book(50, 60); // return 1, The second event booked disjoint, maximum k-booking 1-booking.\nmyCalendarThree.book(10, 40); // return 2, The third event [10, 40) intersects first event, maximum k-booking 2-booking.\nmyCalendarThree.book(5, 15); // return 3, The remaining events cause maximum K-booking 3-booking.\nmyCalendarThree.book(5, 10); // return 3\nmyCalendarThree.book(25, 55); // return 3\n\n\xc2\xa0\nConstraints:\n\n0 <= start < end <= 109\nAt 400 calls made book.\n\n' b'An image represented x n integer grid image image[i][j] represents pixel value image.\nYou also given three integers sr, sc, newColor. You perform flood fill image starting pixel image[sr][sc].\nTo perform flood fill, consider starting pixel, plus pixels connected 4-directionally starting pixel color starting pixel, plus pixels connected 4-directionally pixels (also color), on. Replace color aforementioned pixels newColor.\nReturn modified image performing flood fill.\n\xc2\xa0\nExample 1:\n\nInput: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation: From center image position (sr, sc) = (1, 1) (i.e., red pixel), pixels connected path color starting pixel (i.e., blue pixels) colored new color.\nNote bottom corner colored 2, 4-directionally connected starting pixel.\n\nExample 2:\nInput: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2\nOutput: [[2,2,2],[2,2,2]]\n\n\xc2\xa0\nConstraints:\n\nm == image.length\nn == image[i].length\n1 <= m, n <= 50\n0 <= image[i][j], newColor < 216\n0 <= sr <\xc2\xa0m\n0 <= sc <\xc2\xa0n\n\n' b'We given array asteroids integers representing asteroids row.\nFor asteroid, absolute value represents size, sign represents direction (positive meaning right, negative meaning left). Each asteroid moves speed.\nFind state asteroids collisions. If two asteroids meet, smaller one explode. If size, explode. Two asteroids moving direction never meet.\n\xc2\xa0\nExample 1:\nInput: asteroids = [5,10,-5]\nOutput: [5,10]\nExplanation: The 10 -5 collide resulting 10. The 5 10 never collide.\n\nExample 2:\nInput: asteroids = [8,-8]\nOutput: []\nExplanation: The 8 -8 collide exploding other.\n\nExample 3:\nInput: asteroids = [10,2,-5]\nOutput: [10]\nExplanation: The 2 -5 collide resulting -5. The 10 -5 collide resulting 10.\n\n\xc2\xa0\nConstraints:\n\n2 <= asteroids.length <= 104\n-1000 <= asteroids[i] <= 1000\nasteroids[i] != 0\n\n' b'You given string expression representing Lisp-like expression return integer value of.\nThe syntax expressions given follows.\n\nAn expression either integer, let expression, add expression, mult expression, assigned variable. Expressions always evaluate single integer.\n(An integer could positive negative.)\nA let expression takes form "(let v1 e1 v2 e2 ... vn en expr)", let always string "let", one pairs alternating variables expressions, meaning first variable v1 assigned value expression e1, second variable v2 assigned value expression e2, sequentially; value let expression value expression expr.\nAn add expression takes form "(add e1 e2)" add always string "add", always two expressions e1, e2 result addition evaluation e1 evaluation e2.\nA mult expression takes form "(mult e1 e2)" mult always string "mult", always two expressions e1, e2 result multiplication evaluation e1 evaluation e2.\nFor question, use smaller subset variable names. A variable starts lowercase letter, zero lowercase letters digits. Additionally, convenience, names "add", "let", "mult" protected never used variable names.\nFinally, concept scope. When expression variable name evaluated, within context evaluation, innermost scope (in terms parentheses) checked first value variable, outer scopes checked sequentially. It guaranteed every expression legal. Please see examples details scope.\n\n\xc2\xa0\nExample 1:\nInput: expression = "(let x 2 (mult x (let x 3 4 (add x y))))"\nOutput: 14\nExplanation: In expression (add x y), checking value variable x,\nwe check innermost scope outermost context variable trying evaluate.\nSince x = 3 found first, value x 3.\n\nExample 2:\nInput: expression = "(let x 3 x 2 x)"\nOutput: 2\nExplanation: Assignment let statements processed sequentially.\n\nExample 3:\nInput: expression = "(let x 1 2 x (add x y) (add x y))"\nOutput: 5\nExplanation: The first (add x y) evaluates 3, assigned x.\nThe second (add x y) evaluates 3+2 = 5.\n\n\xc2\xa0\nConstraints:\n\n1 <= expression.length <= 2000\nThere leading trailing spaces expression.\nAll tokens separated single space expression.\nThe answer intermediate calculations answer guaranteed fit 32-bit integer.\nThe expression guaranteed legal evaluate integer.\n\n' b'An integer monotone increasing digits pair adjacent digits x satisfy x <= y.\nGiven integer n, return largest number less equal n monotone increasing digits.\n\xc2\xa0\nExample 1:\nInput: n = 10\nOutput: 9\n\nExample 2:\nInput: n = 1234\nOutput: 1234\n\nExample 3:\nInput: n = 332\nOutput: 299\n\n\xc2\xa0\nConstraints:\n\n0 <= n <= 109\n\n' b'Given array integers temperatures represents daily temperatures, return array answer answer[i] number days wait ith day get warmer temperature. If future day possible, keep answer[i] == 0 instead.\n\xc2\xa0\nExample 1:\nInput: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]\nExample 2:\nInput: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]\nExample 3:\nInput: temperatures = [30,60,90]\nOutput: [1,1,0]\n\n\xc2\xa0\nConstraints:\n\n1 <=\xc2\xa0temperatures.length <= 105\n30 <=\xc2\xa0temperatures[i] <= 100\n\n' b"You given integer array nums. You want maximize number points get performing following operation number times:\n\nPick nums[i] delete earn nums[i] points. Afterwards, must delete every element equal nums[i] - 1 every element equal nums[i] + 1.\n\nReturn maximum number points earn applying operation number times.\n\xc2\xa0\nExample 1:\nInput: nums = [3,4,2]\nOutput: 6\nExplanation: You perform following operations:\n- Delete 4 earn 4 points. Consequently, 3 also deleted. nums = [2].\n- Delete 2 earn 2 points. nums = [].\nYou earn total 6 points.\n\nExample 2:\nInput: nums = [2,2,3,3,3,4]\nOutput: 9\nExplanation: You perform following operations:\n- Delete 3 earn 3 points. All 2's 4's also deleted. nums = [3,3].\n- Delete 3 earn 3 points. nums = [3].\n- Delete 3 earn 3 points. nums = [].\nYou earn total 9 points.\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 2 * 104\n1 <= nums[i] <= 104\n\n" b'You given n x n grid representing field cherries, cell one three possible integers.\n\n0 means cell empty, pass through,\n1 means cell contains cherry pick pass through, or\n-1 means cell contains thorn blocks way.\n\nReturn maximum number cherries collect following rules below:\n\nStarting position (0, 0) reaching (n - 1, n - 1) moving right valid path cells (cells value 0 1).\nAfter reaching (n - 1, n - 1), returning (0, 0) moving left valid path cells.\nWhen passing path cell containing cherry, pick up, cell becomes empty cell 0.\nIf valid path (0, 0) (n - 1, n - 1), cherries collected.\n\n\xc2\xa0\nExample 1:\n\nInput: grid = [[0,1,-1],[1,0,-1],[1,1,1]]\nOutput: 5\nExplanation: The player started (0, 0) went down, down, right right reach (2, 2).\n4 cherries picked single trip, matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].\nThen, player went left, up, up, left return home, picking one cherry.\nThe total number cherries picked 5, maximum possible.\n\nExample 2:\nInput: grid = [[1,1,-1],[1,-1,1],[-1,1,1]]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\nn == grid.length\nn == grid[i].length\n1 <= n <= 50\ngrid[i][j] -1, 0, 1.\ngrid[0][0] != -1\ngrid[n - 1][n - 1] != -1\n\n' b'You given network n nodes, labeled 1 n. You also given times, list travel times directed edges times[i] = (ui, vi, wi), ui source node, vi target node, wi time takes signal travel source target.\nWe send signal given node k. Return minimum time takes n nodes receive signal. If impossible n nodes receive signal, return -1.\n\xc2\xa0\nExample 1:\n\nInput: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\nOutput: 2\n\nExample 2:\nInput: times = [[1,2,1]], n = 2, k = 1\nOutput: 1\n\nExample 3:\nInput: times = [[1,2,1]], n = 2, k = 2\nOutput: -1\n\n\xc2\xa0\nConstraints:\n\n1 <= k <= n <= 100\n1 <= times.length <= 6000\ntimes[i].length == 3\n1 <= ui, vi <= n\nui != vi\n0 <= wi <= 100\nAll pairs (ui, vi) unique. (i.e., multiple edges.)\n\n' b'Given characters array letters sorted non-decreasing order character target, return smallest character array larger target.\nNote letters wrap around.\n\nFor example, target == \'z\' letters == [\'a\', \'b\'], answer \'a\'.\n\n\xc2\xa0\nExample 1:\nInput: letters = ["c","f","j"], target = "a"\nOutput: "c"\n\nExample 2:\nInput: letters = ["c","f","j"], target = "c"\nOutput: "f"\n\nExample 3:\nInput: letters = ["c","f","j"], target = "d"\nOutput: "f"\n\n\xc2\xa0\nConstraints:\n\n2 <= letters.length <= 104\nletters[i] lowercase English letter.\nletters sorted non-decreasing order.\nletters contains least two different characters.\ntarget lowercase English letter.\n\n' b'Design special dictionary words searchs words prefix suffix.\nImplement WordFilter class:\n\nWordFilter(string[] words) Initializes object words dictionary.\nf(string prefix, string suffix) Returns index word dictionary, prefix prefix suffix suffix. If one valid index, return largest them. If word dictionary, return -1.\n\n\xc2\xa0\nExample 1:\nInput\n["WordFilter", "f"]\n[[["apple"]], ["a", "e"]]\nOutput\n[null, 0]\n\nExplanation\nWordFilter wordFilter = new WordFilter(["apple"]);\nwordFilter.f("a", "e"); // return 0, word index 0 prefix = "a" suffix = \'e".\n\n\xc2\xa0\nConstraints:\n\n1 <= words.length <= 15000\n1 <= words[i].length <= 10\n1 <= prefix.length, suffix.length <= 10\nwords[i], prefix suffix consist lower-case English letters only.\nAt 15000 calls made function f.\n\n' b'You given integer array cost cost[i] cost ith step staircase. Once pay cost, either climb one two steps.\nYou either start step index 0, step index 1.\nReturn minimum cost reach top floor.\n\xc2\xa0\nExample 1:\nInput: cost = [10,15,20]\nOutput: 15\nExplanation: You start index 1.\n- Pay 15 climb two steps reach top.\nThe total cost 15.\n\nExample 2:\nInput: cost = [1,100,1,1,1,100,1,1,100,1]\nOutput: 6\nExplanation: You start index 0.\n- Pay 1 climb two steps reach index 2.\n- Pay 1 climb two steps reach index 4.\n- Pay 1 climb two steps reach index 6.\n- Pay 1 climb one step reach index 7.\n- Pay 1 climb two steps reach index 9.\n- Pay 1 climb one step reach top.\nThe total cost 6.\n\n\xc2\xa0\nConstraints:\n\n2 <= cost.length <= 1000\n0 <= cost[i] <= 999\n\n' b'You given integer array nums largest integer unique.\nDetermine whether largest element array least twice much every number array. If is, return index largest element, return -1 otherwise.\n\xc2\xa0\nExample 1:\nInput: nums = [3,6,1,0]\nOutput: 1\nExplanation: 6 largest integer.\nFor every number array x, 6 least twice big x.\nThe index value 6 1, return 1.\n\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: -1\nExplanation: 4 less twice value 3, return -1.\nExample 3:\nInput: nums = [1]\nOutput: 0\nExplanation: 1 trivially least twice value number numbers.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 50\n0 <= nums[i] <= 100\nThe largest element nums unique.\n\n' b'Given string licensePlate array strings words, find shortest completing word words.\nA completing word word contains letters licensePlate. Ignore numbers spaces licensePlate, treat letters case insensitive. If letter appears licensePlate, must appear word number times more.\nFor example, licensePlate = "aBc 12c", contains letters \'a\', \'b\' (ignoring case), \'c\' twice. Possible completing words "abccdef", "caaacab", "cbca".\nReturn shortest completing word words. It guaranteed answer exists. If multiple shortest completing words, return first one occurs words.\n\xc2\xa0\nExample 1:\nInput: licensePlate = "1s3 PSt", words = ["step","steps","stripe","stepple"]\nOutput: "steps"\nExplanation: licensePlate contains letters \'s\', \'p\', \'s\' (ignoring case), \'t\'.\n"step" contains \'t\' \'p\', contains 1 \'s\'.\n"steps" contains \'t\', \'p\', \'s\' characters.\n"stripe" missing \'s\'.\n"stepple" missing \'s\'.\nSince "steps" word containing letters, answer.\n\nExample 2:\nInput: licensePlate = "1s3 456", words = ["looks","pest","stew","show"]\nOutput: "pest"\nExplanation: licensePlate contains letter \'s\'. All words contain \'s\', among "pest", "stew", "show" shortest. The answer "pest" word appears earliest 3.\n\n\xc2\xa0\nConstraints:\n\n1 <= licensePlate.length <= 7\nlicensePlate contains digits, letters (uppercase lowercase), space \' \'.\n1 <= words.length <= 1000\n1 <= words[i].length <= 15\nwords[i] consists lower case English letters.\n\n' b'A virus spreading rapidly, task quarantine infected area installing walls.\nThe world modeled x n binary grid isInfected, isInfected[i][j] == 0 represents uninfected cells, isInfected[i][j] == 1 represents cells contaminated virus. A wall (and one wall) installed two 4-directionally adjacent cells, shared boundary.\nEvery night, virus spreads neighboring cells four directions unless blocked wall. Resources limited. Each day, install walls around one region (i.e., affected area (continuous block infected cells) threatens uninfected cells following night). There never tie.\nReturn number walls used quarantine infected regions. If world become fully infected, return number walls used.\n\xc2\xa0\nExample 1:\n\nInput: isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]\nOutput: 10\nExplanation: There 2 contaminated regions.\nOn first day, add 5 walls quarantine viral region left. The board virus spreads is:\n\nOn second day, add 5 walls quarantine viral region right. The virus fully contained.\n\n\nExample 2:\n\nInput: isInfected = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: 4\nExplanation: Even though one cell saved, 4 walls built.\nNotice walls built shared boundary two different cells.\n\nExample 3:\nInput: isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]\nOutput: 13\nExplanation: The region left builds two new walls.\n\n\xc2\xa0\nConstraints:\n\nm ==\xc2\xa0isInfected.length\nn ==\xc2\xa0isInfected[i].length\n1 <= m, n <= 50\nisInfected[i][j] either 0 1.\nThere always contiguous viral region throughout described process infect strictly uncontaminated squares next round.\n\n' b'You lock front 4 circular wheels. Each wheel 10 slots: \'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\'. The wheels rotate freely wrap around: example turn \'9\' \'0\', \'0\' \'9\'. Each move consists turning one wheel one slot.\nThe lock initially starts \'0000\', string representing state 4 wheels.\nYou given list deadends dead ends, meaning lock displays codes, wheels lock stop turning unable open it.\nGiven target representing value wheels unlock lock, return minimum total number turns required open lock, -1 impossible.\n\xc2\xa0\nExample 1:\nInput: deadends = ["0201","0101","0102","1212","2002"], target = "0202"\nOutput: 6\nExplanation: \nA sequence valid moves would "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202".\nNote sequence like "0000" -> "0001" -> "0002" -> "0102" -> "0202" would invalid,\nbecause wheels lock become stuck display becomes dead end "0102".\n\nExample 2:\nInput: deadends = ["8888"], target = "0009"\nOutput: 1\nExplanation: We turn last wheel reverse move "0000" -> "0009".\n\nExample 3:\nInput: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"\nOutput: -1\nExplanation: We cannot reach target without getting stuck.\n\n\xc2\xa0\nConstraints:\n\n1 <= deadends.length <= 500\ndeadends[i].length == 4\ntarget.length == 4\ntarget list deadends.\ntarget deadends[i] consist digits only.\n\n' b'There safe protected password. The password sequence n digits digit range [0, k - 1].\nThe safe peculiar way checking password. When enter sequence, checks recent n digits entered time type digit.\n\nFor example, correct password "345" enter "012345":\n\n\t\nAfter typing 0, recent 3 digits "0", incorrect.\nAfter typing 1, recent 3 digits "01", incorrect.\nAfter typing 2, recent 3 digits "012", incorrect.\nAfter typing 3, recent 3 digits "123", incorrect.\nAfter typing 4, recent 3 digits "234", incorrect.\nAfter typing 5, recent 3 digits "345", correct safe unlocks.\n\n\n\nReturn string minimum length unlock safe point entering it.\n\xc2\xa0\nExample 1:\nInput: n = 1, k = 2\nOutput: "10"\nExplanation: The password single digit, enter digit. "01" would also unlock safe.\n\nExample 2:\nInput: n = 2, k = 2\nOutput: "01100"\nExplanation: For possible password:\n- "00" typed starting 4th digit.\n- "01" typed starting 1st digit.\n- "10" typed starting 3rd digit.\n- "11" typed starting 2nd digit.\nThus "01100" unlock safe. "01100", "10011", "11001" would also unlock safe.\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 4\n1 <= k <= 10\n1 <= kn <= 4096\n\n' b'You standing position 0 infinite number line. There destination position target.\nYou make number moves numMoves that:\n\nOn move, either go left right.\nDuring ith move (starting == 1 == numMoves), take steps chosen direction.\n\nGiven integer target, return minimum number moves required (i.e., minimum numMoves) reach destination.\n\xc2\xa0\nExample 1:\nInput: target = 2\nOutput: 3\nExplanation:\nOn 1st move, step 0 1 (1 step).\nOn 2nd move, step 1 -1 (2 steps).\nOn 3rd move, step -1 2 (3 steps).\n\nExample 2:\nInput: target = 3\nOutput: 2\nExplanation:\nOn 1st move, step 0 1 (1 step).\nOn 2nd move, step 1 3 (2 steps).\n\n\xc2\xa0\nConstraints:\n\n-109 <= target <= 109\ntarget != 0\n\n' b'You stacking blocks form pyramid. Each block color, represented single letter. Each row blocks contains one less block row beneath centered top.\nTo make pyramid aesthetically pleasing, specific triangular patterns allowed. A triangular pattern consists single block stacked top two blocks. The patterns given\xc2\xa0as list of\xc2\xa0three-letter strings allowed, first two characters pattern represent left right bottom blocks respectively, third character top block.\n\nFor example, "ABC" represents triangular pattern \'C\' block stacked top \'A\' (left) \'B\' (right) block. Note different "BAC" \'B\' left bottom \'A\' right bottom.\n\nYou start bottom row blocks bottom, given single string, must use base pyramid.\nGiven bottom allowed, return true build pyramid way top every triangular pattern pyramid allowed, false otherwise.\n\xc2\xa0\nExample 1:\n\nInput: bottom = "BCD", allowed = ["BCC","CDE","CEA","FFF"]\nOutput: true\nExplanation: The allowed triangular patterns shown right.\nStarting bottom (level 3), build "CE" level 2 build "A" level 1.\nThere three triangular patterns pyramid, "BCC", "CDE", "CEA". All allowed.\n\nExample 2:\n\nInput: bottom = "AAAA", allowed = ["AAB","AAC","BCD","BBE","DEF"]\nOutput: false\nExplanation: The allowed triangular patterns shown right.\nStarting bottom (level 4), multiple ways build level 3, trying possibilites, get always stuck building level 1.\n\n\xc2\xa0\nConstraints:\n\n2 <= bottom.length <= 6\n0 <= allowed.length <= 216\nallowed[i].length == 3\nThe letters input strings set {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'}.\nAll values allowed unique.\n\n' b"An integer interval [a, b] (for integers < b) set consecutive integers b, including b.\nFind minimum size set S every integer interval A intervals, intersection S A size least two.\n\xc2\xa0\nExample 1:\nInput: intervals = [[1,3],[1,4],[2,5],[3,5]]\nOutput: 3\nExplanation: Consider set S = {2, 3, 4}. For interval, least 2 elements S interval.\nAlso, smaller size set fulfills condition.\nThus, output size set, 3.\n\nExample 2:\nInput: intervals = [[1,2],[2,3],[2,4],[4,5]]\nOutput: 5\nExplanation: An example minimum sized set {1, 2, 3, 4, 5}.\n\n\xc2\xa0\nConstraints:\n\n1 <= intervals.length <= 3000\nintervals[i].length == 2\n0 <= ai <\xc2\xa0bi <= 108\n\n" b'Special binary strings binary strings following two properties:\n\nThe number 0\'s equal number 1\'s.\nEvery prefix binary string least many 1\'s 0\'s.\n\nYou given special binary string s.\nA move consists choosing two consecutive, non-empty, special substrings s, swapping them. Two strings consecutive last character first string exactly one index first character second string.\nReturn lexicographically largest resulting string possible applying mentioned operations string.\n\xc2\xa0\nExample 1:\nInput: = "11011000"\nOutput: "11100100"\nExplanation: The strings "10" [occuring s[1]] "1100" [at s[3]] swapped.\nThis lexicographically largest string possible number swaps.\n\nExample 2:\nInput: = "10"\nOutput: "10"\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 50\ns[i] either \'0\' \'1\'.\ns special binary string.\n\n' b"Given two integers left right, return count numbers inclusive range [left, right] prime number set bits binary representation.\nRecall number set bits integer number 1's present written binary.\n\nFor example, 21 written binary 10101, 3 set bits.\n\n\xc2\xa0\nExample 1:\nInput: left = 6, right = 10\nOutput: 4\nExplanation:\n6 -> 110 (2 set bits, 2 prime)\n7 -> 111 (3 set bits, 3 prime)\n8 -> 1000 (1 set bit, 1 prime)\n9 -> 1001 (2 set bits, 2 prime)\n10 -> 1010 (2 set bits, 2 prime)\n4 numbers prime number set bits.\n\nExample 2:\nInput: left = 10, right = 15\nOutput: 5\nExplanation:\n10 -> 1010 (2 set bits, 2 prime)\n11 -> 1011 (3 set bits, 3 prime)\n12 -> 1100 (2 set bits, 2 prime)\n13 -> 1101 (3 set bits, 3 prime)\n14 -> 1110 (3 set bits, 3 prime)\n15 -> 1111 (4 set bits, 4 prime)\n5 numbers prime number set bits.\n\n\xc2\xa0\nConstraints:\n\n1 <= left <= right <= 106\n0 <= right - left <= 104\n\n" b'You given string s. We want partition string many parts possible letter appears one part.\nNote partition done concatenating parts order, resultant string s.\nReturn list integers representing size parts.\n\xc2\xa0\nExample 1:\nInput: = "ababcbacadefegdehijhklij"\nOutput: [9,7,8]\nExplanation:\nThe partition "ababcbaca", "defegde", "hijhklij".\nThis partition letter appears one part.\nA partition like "ababcbacadefegde", "hijhklij" incorrect, splits less parts.\n\nExample 2:\nInput: = "eccbbbbdec"\nOutput: [10]\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 500\ns consists lowercase English letters.\n\n' b"You given integer n. You n x n binary grid grid values initially 1's except indices given array mines. The ith element array mines defined mines[i] = [xi, yi] grid[xi][yi] == 0.\nReturn order largest axis-aligned plus sign 1's contained grid. If none, return 0.\nAn axis-aligned plus sign 1's order k center grid[r][c] == 1 along four arms length k - 1 going up, down, left, right, made 1's. Note could 0's 1's beyond arms plus sign, relevant area plus sign checked 1's.\n\xc2\xa0\nExample 1:\n\nInput: n = 5, mines = [[4,2]]\nOutput: 2\nExplanation: In grid, largest plus sign order 2. One shown.\n\nExample 2:\n\nInput: n = 1, mines = [[0,0]]\nOutput: 0\nExplanation: There plus sign, return 0.\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 500\n1 <= mines.length <= 5000\n0 <= xi, yi < n\nAll pairs (xi, yi) unique.\n\n" b'There n couples sitting 2n seats arranged row want hold hands.\nThe people seats represented integer array row row[i] ID person sitting ith seat. The couples numbered order, first couple (0, 1), second couple (2, 3), last couple (2n - 2, 2n - 1).\nReturn minimum number swaps every couple sitting side side. A swap consists choosing two people, stand switch seats.\n\xc2\xa0\nExample 1:\nInput: row = [0,2,1,3]\nOutput: 1\nExplanation: We need swap second (row[1]) third (row[2]) person.\n\nExample 2:\nInput: row = [3,2,0,1]\nOutput: 0\nExplanation: All couples already seated side side.\n\n\xc2\xa0\nConstraints:\n\n2n == row.length\n2 <= n <= 30\nn even.\n0 <= row[i] < 2n\nAll elements row unique.\n\n' b'Given x n matrix, return\xc2\xa0true\xc2\xa0if matrix Toeplitz. Otherwise, return false.\nA matrix Toeplitz every diagonal top-left bottom-right elements.\n\xc2\xa0\nExample 1:\n\nInput: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]\nOutput: true\nExplanation:\nIn grid, the\xc2\xa0diagonals are:\n"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".\nIn diagonal elements same, answer True.\n\nExample 2:\n\nInput: matrix = [[1,2],[2,2]]\nOutput: false\nExplanation:\nThe diagonal "[1, 2]" different elements.\n\n\xc2\xa0\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 20\n0 <= matrix[i][j] <= 99\n\n\xc2\xa0\nFollow up:\n\nWhat matrix stored disk, memory limited load one row matrix memory once?\nWhat matrix large load partial row memory once?\n\n' b'Given string s, rearrange characters two adjacent characters same.\nReturn possible rearrangement return "" possible.\n\xc2\xa0\nExample 1:\nInput: = "aab"\nOutput: "aba"\nExample 2:\nInput: = "aaab"\nOutput: ""\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 500\ns consists lowercase English letters.\n\n' b"You given integer array arr.\nWe split arr number chunks (i.e., partitions), individually sort chunk. After concatenating them, result equal sorted array.\nReturn largest number chunks make sort array.\n\xc2\xa0\nExample 1:\nInput: arr = [5,4,3,2,1]\nOutput: 1\nExplanation:\nSplitting two chunks return required result.\nFor example, splitting [5, 4], [3, 2, 1] result [4, 5, 1, 2, 3], sorted.\n\nExample 2:\nInput: arr = [2,1,3,4,4]\nOutput: 4\nExplanation:\nWe split two chunks, [2, 1], [3, 4, 4].\nHowever, splitting [2, 1], [3], [4], [4] highest number chunks possible.\n\n\xc2\xa0\nConstraints:\n\n1 <= arr.length <= 2000\n0 <= arr[i] <= 108\n\n" b"You given integer array arr length n represents permutation integers range [0, n - 1].\nWe split arr number chunks (i.e., partitions), individually sort chunk. After concatenating them, result equal sorted array.\nReturn largest number chunks make sort array.\n\xc2\xa0\nExample 1:\nInput: arr = [4,3,2,1,0]\nOutput: 1\nExplanation:\nSplitting two chunks return required result.\nFor example, splitting [4, 3], [2, 1, 0] result [3, 4, 0, 1, 2], sorted.\n\nExample 2:\nInput: arr = [1,0,2,3,4]\nOutput: 4\nExplanation:\nWe split two chunks, [1, 0], [2, 3, 4].\nHowever, splitting [1, 0], [2], [3], [4] highest number chunks possible.\n\n\xc2\xa0\nConstraints:\n\nn == arr.length\n1 <= n <= 10\n0 <= arr[i] < n\nAll elements arr unique.\n\n" b'Given expression expression = "e + 8 - + 5" evaluation map {"e": 1} (given terms evalvars = ["e"] evalints = [1]), return list tokens representing simplified expression, ["-1*a","14"]\n\nAn expression alternates chunks symbols, space separating chunk symbol.\nA chunk either expression parentheses, variable, non-negative integer.\nA variable string lowercase letters (not including digits.) Note variables multiple letters, note variables never leading coefficient unary operator like "2x" "-x".\n\nExpressions evaluated usual order: brackets first, multiplication, addition subtraction.\n\nFor example, expression = "1 + 2 * 3" answer ["7"].\n\nThe format output follows:\n\nFor term free variables non-zero coefficient, write free variables within term sorted order lexicographically.\n\t\nFor example, would never write term like "b*a*c", "a*b*c".\n\n\nTerms degrees equal number free variables multiplied, counting multiplicity. We write largest degree terms answer first, breaking ties lexicographic order ignoring leading coefficient term.\n\t\nFor example, "a*a*b*c" degree 4.\n\n\nThe leading coefficient term placed directly left asterisk separating variables (if exist.) A leading coefficient 1 still printed.\nAn example well-formatted answer ["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"].\nTerms (including constant terms) coefficient 0 included.\n\t\nFor example, expression "0" output [].\n\n\n\n\xc2\xa0\nExample 1:\nInput: expression = "e + 8 - + 5", evalvars = ["e"], evalints = [1]\nOutput: ["-1*a","14"]\n\nExample 2:\nInput: expression = "e - 8 + temperature - pressure", evalvars = ["e", "temperature"], evalints = [1, 12]\nOutput: ["-1*pressure","5"]\n\nExample 3:\nInput: expression = "(e + 8) * (e - 8)", evalvars = [], evalints = []\nOutput: ["1*e*e","-64"]\n\n\xc2\xa0\nConstraints:\n\n1 <= expression.length <= 250\nexpression consists lowercase English letters, digits, \'+\', \'-\', \'*\', \'(\', \')\', \' \'.\nexpression contain leading trailing spaces.\nAll tokens expression separated single space.\n0 <= evalvars.length <= 100\n1 <= evalvars[i].length <= 20\nevalvars[i] consists lowercase English letters.\nevalints.length == evalvars.length\n-100 <= evalints[i] <= 100\n\n' b'You\'re given strings jewels representing types stones jewels, stones representing stones have. Each character stones type stone have. You want know many stones also jewels.\nLetters case sensitive, "a" considered different type stone "A".\n\xc2\xa0\nExample 1:\nInput: jewels = "aA", stones = "aAAbbbb"\nOutput: 3\nExample 2:\nInput: jewels = "z", stones = "ZZ"\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <=\xc2\xa0jewels.length, stones.length <= 50\njewels stones consist English letters.\nAll characters of\xc2\xa0jewels unique.\n\n' b'On 2 x 3 board, five tiles labeled 1 5, empty square represented 0. A move consists choosing 0 4-directionally adjacent number swapping it.\nThe state board solved board [[1,2,3],[4,5,0]].\nGiven puzzle board board, return least number moves required state board solved. If impossible state board solved, return -1.\n\xc2\xa0\nExample 1:\n\nInput: board = [[1,2,3],[4,0,5]]\nOutput: 1\nExplanation: Swap 0 5 one move.\n\nExample 2:\n\nInput: board = [[1,2,3],[5,4,0]]\nOutput: -1\nExplanation: No number moves make board solved.\n\nExample 3:\n\nInput: board = [[4,1,2],[5,0,3]]\nOutput: 5\nExplanation: 5 smallest number moves solves board.\nAn example path:\nAfter move 0: [[4,1,2],[5,0,3]]\nAfter move 1: [[4,1,2],[0,5,3]]\nAfter move 2: [[0,1,2],[4,5,3]]\nAfter move 3: [[1,0,2],[4,5,3]]\nAfter move 4: [[1,2,0],[4,5,3]]\nAfter move 5: [[1,2,3],[4,5,0]]\n\n\xc2\xa0\nConstraints:\n\nboard.length == 2\nboard[i].length == 3\n0 <= board[i][j] <= 5\nEach value board[i][j] unique.\n\n' b'You given integer array nums length n represents permutation integers range [0, n - 1].\nThe number global inversions number different pairs (i, j) where:\n\n0 <= < j < n\nnums[i] > nums[j]\n\nThe number local inversions number indices where:\n\n0 <= < n - 1\nnums[i] > nums[i + 1]\n\nReturn true number global inversions equal number local inversions.\n\xc2\xa0\nExample 1:\nInput: nums = [1,0,2]\nOutput: true\nExplanation: There 1 global inversion 1 local inversion.\n\nExample 2:\nInput: nums = [1,2,0]\nOutput: false\nExplanation: There 2 global inversions 1 local inversion.\n\n\xc2\xa0\nConstraints:\n\nn == nums.length\n1 <= n <= 105\n0 <= nums[i] < n\nAll integers nums unique.\nnums permutation numbers range [0, n - 1].\n\n' b'In string composed \'L\', \'R\', \'X\' characters, like "RXXLRXRXL", move consists either replacing one occurrence "XL" "LX", replacing one occurrence "RX" "XR". Given starting string start ending string end, return True exists sequence moves transform one string other.\n\xc2\xa0\nExample 1:\nInput: start = "RXXLRXRXL", end = "XRLXXRRLX"\nOutput: true\nExplanation: We transform start end following steps:\nRXXLRXRXL ->\nXRXLRXRXL ->\nXRLXRXRXL ->\nXRLXXRRXL ->\nXRLXXRRLX\n\nExample 2:\nInput: start = "X", end = "L"\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= start.length\xc2\xa0<= 104\nstart.length == end.length\nBoth start end consist characters \'L\', \'R\', and\xc2\xa0\'X\'.\n\n' b'You given n x n integer matrix grid value grid[i][j] represents elevation point (i, j).\nThe rain starts fall. At time t, depth water everywhere t. You swim square another 4-directionally adjacent square elevation squares individually t. You swim infinite distances zero time. Of course, must stay within boundaries grid swim.\nReturn least time reach bottom right square (n - 1, n - 1) start top left square (0, 0).\n\xc2\xa0\nExample 1:\n\nInput: grid = [[0,2],[1,3]]\nOutput: 3\nExplanation:\nAt time 0, grid location (0, 0).\nYou cannot go anywhere else 4-directionally adjacent neighbors higher elevation = 0.\nYou cannot reach point (1, 1) time 3.\nWhen depth water 3, swim anywhere inside grid.\n\nExample 2:\n\nInput: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\nOutput: 16\nExplanation: The final route shown.\nWe need wait time 16 (0, 0) (4, 4) connected.\n\n\xc2\xa0\nConstraints:\n\nn == grid.length\nn == grid[i].length\n1 <= n <= 50\n0 <= grid[i][j] <\xc2\xa0n2\nEach value grid[i][j] unique.\n\n' b'We build table n rows (1-indexed). We start writing 0 1st row. Now every subsequent row, look previous row replace occurrence 0 01, occurrence 1 10.\n\nFor example, n = 3, 1st row 0, 2nd row 01, 3rd row 0110.\n\nGiven two integer n k, return kth (1-indexed) symbol nth row table n rows.\n\xc2\xa0\nExample 1:\nInput: n = 1, k = 1\nOutput: 0\nExplanation: row 1: 0\n\nExample 2:\nInput: n = 2, k = 1\nOutput: 0\nExplanation: \nrow 1: 0\nrow 2: 01\n\nExample 3:\nInput: n = 2, k = 2\nOutput: 1\nExplanation: \nrow 1: 0\nrow 2: 01\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 30\n1 <= k <= 2n - 1\n\n' b'Given four integers sx, sy, tx, ty, return true possible convert point (sx, sy) point (tx, ty) operations, false otherwise.\nThe allowed operation point (x, y) convert either (x, x + y) (x + y, y).\n\xc2\xa0\nExample 1:\nInput: sx = 1, sy = 1, tx = 3, ty = 5\nOutput: true\nExplanation:\nOne series moves transforms starting point target is:\n(1, 1) -> (1, 2)\n(1, 2) -> (3, 2)\n(3, 2) -> (3, 5)\n\nExample 2:\nInput: sx = 1, sy = 1, tx = 2, ty = 2\nOutput: false\n\nExample 3:\nInput: sx = 1, sy = 1, tx = 1, ty = 1\nOutput: true\n\n\xc2\xa0\nConstraints:\n\n1 <= sx, sy, tx, ty <= 109\n\n' b'There forest unknown number rabbits. We asked n rabbits "How many rabbits color you?" collected answers integer array answers answers[i] answer ith rabbit.\nGiven array answers, return minimum number rabbits could forest.\n\xc2\xa0\nExample 1:\nInput: answers = [1,1,2]\nOutput: 5\nExplanation:\nThe two rabbits answered "1" could color, say red.\nThe rabbit answered "2" can\'t red answers would inconsistent.\nSay rabbit answered "2" blue.\nThen 2 blue rabbits forest didn\'t answer array.\nThe smallest possible number rabbits forest therefore 5: 3 answered plus 2 didn\'t.\n\nExample 2:\nInput: answers = [10,10,10]\nOutput: 11\n\n\xc2\xa0\nConstraints:\n\n1 <= answers.length <= 1000\n0 <= answers[i] < 1000\n\n' b"You given n x n binary grid board. In move, swap two rows other, two columns other.\nReturn minimum number moves transform board chessboard board. If task impossible, return -1.\nA chessboard board board 0's 1's 4-directionally adjacent.\n\xc2\xa0\nExample 1:\n\nInput: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\nOutput: 2\nExplanation: One potential sequence moves shown.\nThe first move swaps first second column.\nThe second move swaps second third row.\n\nExample 2:\n\nInput: board = [[0,1],[1,0]]\nOutput: 0\nExplanation: Also note board 0 top left corner, also valid chessboard.\n\nExample 3:\n\nInput: board = [[1,0],[1,0]]\nOutput: -1\nExplanation: No matter sequence moves make, cannot end valid chessboard.\n\n\xc2\xa0\nConstraints:\n\nn == board.length\nn == board[i].length\n2 <= n <= 30\nboard[i][j] either\xc2\xa00 1.\n\n" b'Given root Binary Search Tree (BST), return minimum difference values two different nodes tree.\n\xc2\xa0\nExample 1:\n\nInput: root = [4,2,6,1,3]\nOutput: 1\n\nExample 2:\n\nInput: root = [1,0,48,null,null,12,49]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [2, 100].\n0 <= Node.val <= 105\n\n\xc2\xa0\nNote: This question 530: https://leetcode.com/problems/minimum-absolute-difference-in-bst/\n' b'Given string s, you\xc2\xa0can transform every letter individually lowercase uppercase create another string.\nReturn list possible strings could create. Return output order.\n\xc2\xa0\nExample 1:\nInput: = "a1b2"\nOutput: ["a1b2","a1B2","A1b2","A1B2"]\n\nExample 2:\nInput: = "3z4"\nOutput: ["3z4","3Z4"]\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 12\ns consists lowercase English letters, uppercase English letters, digits.\n\n' b'There undirected graph n nodes, node numbered 0 n - 1. You given 2D array graph, graph[u] array nodes node u adjacent to. More formally, v graph[u], undirected edge node u node v. The graph following properties:\n\nThere self-edges (graph[u] contain u).\nThere parallel edges (graph[u] contain duplicate values).\nIf v graph[u], u graph[v] (the graph undirected).\nThe graph may connected, meaning may two nodes u v path them.\n\nA graph bipartite nodes partitioned two independent sets A B every edge graph connects node set A node set B.\nReturn true bipartite.\n\xc2\xa0\nExample 1:\n\nInput: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\nOutput: false\nExplanation: There way partition nodes two independent sets every edge connects node one node other.\nExample 2:\n\nInput: graph = [[1,3],[0,2],[1,3],[0,2]]\nOutput: true\nExplanation: We partition nodes two sets: {0, 2} {1, 3}.\n\xc2\xa0\nConstraints:\n\ngraph.length == n\n1 <= n <= 100\n0 <= graph[u].length < n\n0 <= graph[u][i] <= n - 1\ngraph[u]\xc2\xa0does contain\xc2\xa0u.\nAll values graph[u] unique.\nIf graph[u] contains v, graph[v] contains u.\n\n' b'You given sorted integer array arr containing 1 prime numbers, integers arr unique. You also given integer k.\nFor every j 0 <= < j < arr.length, consider fraction arr[i] / arr[j].\nReturn kth smallest fraction considered. Return answer array integers size 2, answer[0] == arr[i] answer[1] == arr[j].\n\xc2\xa0\nExample 1:\nInput: arr = [1,2,3,5], k = 3\nOutput: [2,5]\nExplanation: The fractions considered sorted order are:\n1/5, 1/3, 2/5, 1/2, 3/5, 2/3.\nThe third fraction 2/5.\n\nExample 2:\nInput: arr = [1,7], k = 1\nOutput: [1,7]\n\n\xc2\xa0\nConstraints:\n\n2 <= arr.length <= 1000\n1 <= arr[i] <= 3 * 104\narr[0] == 1\narr[i] prime number > 0.\nAll numbers arr unique sorted strictly increasing order.\n1 <= k <= arr.length * (arr.length - 1) / 2\n\n' b'There n cities connected number flights. You given array flights flights[i] = [fromi, toi, pricei] indicates flight city fromi city toi cost pricei.\nYou also given three integers src, dst, k, return cheapest price src dst k stops. If route, return -1.\n\xc2\xa0\nExample 1:\n\nInput: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1\nOutput: 700\nExplanation:\nThe graph shown above.\nThe optimal path 1 stop city 0 3 marked red cost 100 + 600 = 700.\nNote path cities [0,1,2,3] cheaper invalid uses 2 stops.\n\nExample 2:\n\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\nOutput: 200\nExplanation:\nThe graph shown above.\nThe optimal path 1 stop city 0 2 marked red cost 100 + 100 = 200.\n\nExample 3:\n\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\nOutput: 500\nExplanation:\nThe graph shown above.\nThe optimal path stops city 0 2 marked red cost 500.\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 100\n0 <= flights.length <= (n * (n - 1) / 2)\nflights[i].length == 3\n0 <= fromi, toi < n\nfromi != toi\n1 <= pricei <= 104\nThere multiple flights two cities.\n0 <= src, dst, k < n\nsrc != dst\n\n' b'An integer x good rotating digit individually 180 degrees, get valid number different x. Each digit must rotated - cannot choose leave alone.\nA number valid digit remains digit rotation. For example:\n\n0, 1, 8 rotate themselves,\n2 5 rotate (in case rotated different direction, words, 2 5 gets mirrored),\n6 9 rotate other, and\nthe rest numbers rotate number become invalid.\n\nGiven integer n, return number good integers range [1, n].\n\xc2\xa0\nExample 1:\nInput: n = 10\nOutput: 4\nExplanation: There four good numbers range [1, 10] : 2, 5, 6, 9.\nNote 1 10 good numbers, since remain unchanged rotating.\n\nExample 2:\nInput: n = 1\nOutput: 0\n\nExample 3:\nInput: n = 2\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 104\n\n' b'You playing simplified PAC-MAN game infinite 2-D grid. You start point [0, 0], given destination point target = [xtarget, ytarget] trying get to. There several ghosts map starting positions given 2D array ghosts, ghosts[i] = [xi, yi] represents starting position ith ghost. All inputs integral coordinates.\nEach turn, ghosts may independently choose either move 1 unit four cardinal directions: north, east, south, west, stay still. All actions happen simultaneously.\nYou escape reach target ghost reaches you. If reach square (including target) time ghost, count escape.\nReturn true possible escape regardless ghosts move, otherwise return false.\n\xc2\xa0\nExample 1:\nInput: ghosts = [[1,0],[0,3]], target = [0,1]\nOutput: true\nExplanation: You reach destination (0, 1) 1 turn, ghosts located (1, 0) (0, 3) cannot catch you.\n\nExample 2:\nInput: ghosts = [[1,0]], target = [2,0]\nOutput: false\nExplanation: You need reach destination (2, 0), ghost (1, 0) lies destination.\n\nExample 3:\nInput: ghosts = [[2,0]], target = [1,0]\nOutput: false\nExplanation: The ghost reach target time you.\n\n\xc2\xa0\nConstraints:\n\n1 <= ghosts.length <= 100\nghosts[i].length == 2\n-104 <= xi, yi <= 104\nThere multiple ghosts location.\ntarget.length == 2\n-104 <= xtarget, ytarget <= 104\n\n' b'You two types tiles: 2 x 1 domino shape tromino shape. You may rotate shapes.\n\nGiven integer n, return number ways tile 2 x n board. Since answer may large, return modulo 109 + 7.\nIn tiling, every square must covered tile. Two tilings different two 4-directionally adjacent cells board exactly one tilings squares occupied tile.\n\xc2\xa0\nExample 1:\n\nInput: n = 3\nOutput: 5\nExplanation: The five different ways show above.\n\nExample 2:\nInput: n = 1\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 1000\n\n' b'You given two strings order s. All words order unique sorted custom order previously.\nPermute characters match order order sorted. More specifically, character x occurs character order, x occur permuted string.\nReturn permutation satisfies property.\n\xc2\xa0\nExample 1:\nInput: order = "cba", = "abcd"\nOutput: "cbad"\nExplanation: \n"a", "b", "c" appear order, order "a", "b", "c" "c", "b", "a". \nSince "d" appear order, position returned string. "dcba", "cdba", "cbda" also valid outputs.\n\nExample 2:\nInput: order = "cbafg", = "abcd"\nOutput: "cbad"\n\n\xc2\xa0\nConstraints:\n\n1 <= order.length <= 26\n1 <= s.length <= 200\norder consist lowercase English letters.\nAll characters order unique.\n\n' b'Given string array strings words, return number words[i] subsequence s.\nA subsequence string new string generated original string characters (can none) deleted without changing relative order remaining characters.\n\nFor example, "ace" subsequence "abcde".\n\n\xc2\xa0\nExample 1:\nInput: = "abcde", words = ["a","bb","acd","ace"]\nOutput: 3\nExplanation: There three strings words subsequence s: "a", "acd", "ace".\n\nExample 2:\nInput: = "dsahjpjauf", words = ["ahjpjau","ja","ahbwzgqnuk","tnmlanowax"]\nOutput: 2\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 5 * 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 50\ns words[i] consist lowercase English letters.\n\n' b'Let f(x) number zeroes end x!. Recall x! = 1 * 2 * 3 * ... * x convention, 0! = 1.\n\nFor example, f(3) = 0 3! = 6 zeroes end, f(11) = 2 11! = 39916800 two zeroes end.\n\nGiven integer k, return number non-negative integers x property f(x) = k.\n\xc2\xa0\nExample 1:\nInput: k = 0\nOutput: 5\nExplanation: 0!, 1!, 2!, 3!, 4! end k = 0 zeroes.\n\nExample 2:\nInput: k = 5\nOutput: 0\nExplanation: There x x! ends k = 5 zeroes.\n\nExample 3:\nInput: k = 3\nOutput: 5\n\n\xc2\xa0\nConstraints:\n\n0 <= k <= 109\n\n' b'Given Tic-Tac-Toe board string array board, return true possible reach board position course valid tic-tac-toe game.\nThe board 3 x 3 array consists characters \' \', \'X\', \'O\'. The \' \' character represents empty square.\nHere rules Tic-Tac-Toe:\n\nPlayers take turns placing characters empty squares \' \'.\nThe first player always places \'X\' characters, second player always places \'O\' characters.\n\'X\' \'O\' characters always placed empty squares, never filled ones.\nThe game ends three (non-empty) character filling row, column, diagonal.\nThe game also ends squares non-empty.\nNo moves played game over.\n\n\xc2\xa0\nExample 1:\n\nInput: board = ["O "," "," "]\nOutput: false\nExplanation: The first player always plays "X".\n\nExample 2:\n\nInput: board = ["XOX"," X "," "]\nOutput: false\nExplanation: Players take turns making moves.\n\nExample 3:\n\nInput: board = ["XOX","O O","XOX"]\nOutput: true\n\n\xc2\xa0\nConstraints:\n\nboard.length == 3\nboard[i].length == 3\nboard[i][j] either \'X\', \'O\', \' \'.\n\n' b'Given integer array nums two integers left right, return number contiguous non-empty subarrays value maximum array element subarray range [left, right].\nThe test cases generated answer fit 32-bit integer.\n\xc2\xa0\nExample 1:\nInput: nums = [2,1,4,3], left = 2, right = 3\nOutput: 3\nExplanation: There three subarrays meet requirements: [2], [2, 1], [3].\n\nExample 2:\nInput: nums = [2,9,2,5,6], left = 2, right = 8\nOutput: 7\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 109\n0 <= left <= right <= 109\n\n' b'Given two strings goal, return true become goal number shifts s.\nA shift consists moving leftmost character rightmost position.\n\nFor example, = "abcde", "bcdea" one shift.\n\n\xc2\xa0\nExample 1:\nInput: = "abcde", goal = "cdeab"\nOutput: true\nExample 2:\nInput: = "abcde", goal = "abced"\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length, goal.length <= 100\ns goal consist lowercase English letters.\n\n' b'Given directed acyclic graph (DAG) n nodes labeled 0 n - 1, find possible paths node 0 node n - 1 return order.\nThe graph given follows: graph[i] list nodes visit node (i.e., directed edge node node graph[i][j]).\n\xc2\xa0\nExample 1:\n\nInput: graph = [[1,2],[3],[3],[]]\nOutput: [[0,1,3],[0,2,3]]\nExplanation: There two paths: 0 -> 1 -> 3 0 -> 2 -> 3.\n\nExample 2:\n\nInput: graph = [[4,3,1],[3,2,4],[3],[4],[]]\nOutput: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n\n\xc2\xa0\nConstraints:\n\nn == graph.length\n2 <= n <= 15\n0 <= graph[i][j] < n\ngraph[i][j] != (i.e., self-loops).\nAll elements graph[i] unique.\nThe input graph guaranteed DAG.\n\n' b'You given array nums. You rotate non-negative integer k array becomes [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]. Afterward, entries less equal index worth one point.\n\nFor example, nums = [2,4,1,3,0], rotate k = 2, becomes [1,3,0,2,4]. This worth 3 points 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point].\n\nReturn rotation index k corresponds highest score achieve rotated nums it. If multiple answers, return smallest index k.\n\xc2\xa0\nExample 1:\nInput: nums = [2,3,1,4,0]\nOutput: 3\nExplanation: Scores k listed below: \nk = 0, nums = [2,3,1,4,0], score 2\nk = 1, nums = [3,1,4,0,2], score 3\nk = 2, nums = [1,4,0,2,3], score 3\nk = 3, nums = [4,0,2,3,1], score 4\nk = 4, nums = [0,2,3,1,4], score 3\nSo choose k = 3, highest score.\n\nExample 2:\nInput: nums = [1,3,0,2,4]\nOutput: 0\nExplanation: nums always 3 points matter shifts.\nSo choose smallest k, 0.\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] < nums.length\n\n' b'We stack glasses pyramid, first row 1 glass, second row 2 glasses, 100th row.\xc2\xa0 Each glass holds one cup\xc2\xa0of champagne.\nThen, champagne poured first glass top.\xc2\xa0 When topmost glass full, excess liquid poured fall equally glass immediately left right it.\xc2\xa0 When glasses become full, excess champagne fall equally left right glasses, on.\xc2\xa0 (A glass bottom row excess champagne fall floor.)\nFor example, one cup champagne poured, top glass full.\xc2\xa0 After two cups champagne poured, two glasses second row half full.\xc2\xa0 After three cups champagne poured, two cups become full - 3 full glasses total now.\xc2\xa0 After four cups champagne poured, third row middle glass half full, two outside glasses quarter full, pictured below.\n\nNow pouring non-negative integer cups champagne, return full jth glass ith row (both j 0-indexed.)\n\xc2\xa0\nExample 1:\nInput: poured = 1, query_row = 1, query_glass = 1\nOutput: 0.00000\nExplanation: We poured 1 cup champange top glass tower (which indexed (0, 0)). There excess liquid glasses top glass remain empty.\n\nExample 2:\nInput: poured = 2, query_row = 1, query_glass = 1\nOutput: 0.50000\nExplanation: We poured 2 cups champange top glass tower (which indexed (0, 0)). There one cup excess liquid. The glass indexed (1, 0) glass indexed (1, 1) share excess liquid equally, get half cup champange.\n\nExample 3:\nInput: poured = 100000009, query_row = 33, query_glass = 17\nOutput: 1.00000\n\n\xc2\xa0\nConstraints:\n\n0 <=\xc2\xa0poured <= 109\n0 <= query_glass <= query_row\xc2\xa0< 100\n' b'You given two integer arrays length nums1 nums2. In one operation, allowed swap nums1[i] nums2[i].\n\nFor example, nums1 = [1,2,3,8], nums2 = [5,6,7,4], swap element = 3 obtain nums1 = [1,2,3,4] nums2 = [5,6,7,8].\n\nReturn minimum number needed operations make nums1 nums2 strictly increasing. The test cases generated given input always makes possible.\nAn array arr strictly increasing arr[0] < arr[1] < arr[2] < ... < arr[arr.length - 1].\n\xc2\xa0\nExample 1:\nInput: nums1 = [1,3,5,4], nums2 = [1,2,3,7]\nOutput: 1\nExplanation: \nSwap nums1[3] nums2[3]. Then sequences are:\nnums1 = [1, 3, 5, 7] nums2 = [1, 2, 3, 4]\nwhich strictly increasing.\n\nExample 2:\nInput: nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n2 <= nums1.length <= 105\nnums2.length == nums1.length\n0 <= nums1[i], nums2[i] <= 2 * 105\n\n' b'There directed graph n nodes node labeled 0 n - 1. The graph represented 0-indexed 2D integer array graph graph[i] integer array nodes adjacent node i, meaning edge node node graph[i].\nA node terminal node outgoing edges. A node safe node every possible path starting node leads terminal node.\nReturn array containing safe nodes graph. The answer sorted ascending order.\n\xc2\xa0\nExample 1:\n\nInput: graph = [[1,2],[2,3],[5],[0],[5],[],[]]\nOutput: [2,4,5,6]\nExplanation: The given graph shown above.\nNodes 5 6 terminal nodes outgoing edges either them.\nEvery path starting nodes 2, 4, 5, 6 lead either node 5 6.\nExample 2:\nInput: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\nOutput: [4]\nExplanation:\nOnly node 4 terminal node, every path starting node 4 leads node 4.\n\n\xc2\xa0\nConstraints:\n\nn == graph.length\n1 <= n <= 104\n0 <= graph[i].length <= n\n0 <= graph[i][j] <= n - 1\ngraph[i] sorted strictly increasing order.\nThe graph may contain self-loops.\nThe number edges graph range [1, 4 * 104].\n\n' b'You given x n binary grid, 1 represents brick 0 represents empty space. A brick stable if:\n\nIt directly connected top grid, or\nAt least one brick four adjacent cells stable.\n\nYou also given array hits, sequence erasures want apply. Each time want erase brick location hits[i] = (rowi, coli). The brick location\xc2\xa0(if exists) disappear. Some bricks may longer stable erasure fall. Once brick falls, immediately erased grid (i.e., land stable bricks).\nReturn array result, result[i] number bricks fall ith erasure applied.\nNote erasure may refer location brick, does, bricks drop.\n\xc2\xa0\nExample 1:\nInput: grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]\nOutput: [2]\nExplanation: Starting grid:\n[[1,0,0,0],\n [1,1,1,0]]\nWe erase underlined brick (1,0), resulting grid:\n[[1,0,0,0],\n [0,1,1,0]]\nThe two underlined bricks longer stable longer connected top adjacent another stable brick, fall. The resulting grid is:\n[[1,0,0,0],\n [0,0,0,0]]\nHence result [2].\n\nExample 2:\nInput: grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]\nOutput: [0,0]\nExplanation: Starting grid:\n[[1,0,0,0],\n [1,1,0,0]]\nWe erase underlined brick (1,1), resulting grid:\n[[1,0,0,0],\n [1,0,0,0]]\nAll remaining bricks still stable, bricks fall. The grid remains same:\n[[1,0,0,0],\n [1,0,0,0]]\nNext, erase underlined brick (1,0), resulting grid:\n[[1,0,0,0],\n [0,0,0,0]]\nOnce again, remaining bricks still stable, bricks fall.\nHence result [0,0].\n\n\xc2\xa0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 200\ngrid[i][j] 0 1.\n1 <= hits.length <= 4 * 104\nhits[i].length == 2\n0 <= xi\xc2\xa0<= - 1\n0 <=\xc2\xa0yi <= n - 1\nAll (xi, yi) unique.\n\n' b'International Morse Code defines standard encoding letter mapped series dots dashes, follows:\n\n\'a\' maps ".-",\n\'b\' maps "-...",\n\'c\' maps "-.-.", on.\n\nFor convenience, full table 26 letters English alphabet given below:\n[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]\nGiven array strings words word written concatenation Morse code letter.\n\nFor example, "cab" written "-.-..--...", concatenation "-.-.", ".-", "-...". We call concatenation transformation word.\n\nReturn number different transformations among words have.\n\xc2\xa0\nExample 1:\nInput: words = ["gin","zen","gig","msg"]\nOutput: 2\nExplanation: The transformation word is:\n"gin" -> "--...-."\n"zen" -> "--...-."\n"gig" -> "--...--."\n"msg" -> "--...--."\nThere 2 different transformations: "--...-." "--...--.".\n\nExample 2:\nInput: words = ["a"]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= words.length <= 100\n1 <= words[i].length <= 12\nwords[i] consists lowercase English letters.\n\n' b'You given integer array nums.\nYou move element nums one two arrays A B A B non-empty, average(A) == average(B).\nReturn true possible achieve false otherwise.\nNote array arr, average(arr) sum elements arr length arr.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3,4,5,6,7,8]\nOutput: true\nExplanation: We split array [1,4,5,8] [2,3,6,7], average 4.5.\n\nExample 2:\nInput: nums = [3,1]\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 30\n0 <= nums[i] <= 104\n\n' b'You given string lowercase English letters array widths denoting many pixels wide lowercase English letter is. Specifically, widths[0] width \'a\', widths[1] width \'b\', on.\nYou trying write across several lines, line longer 100 pixels. Starting beginning s, write many letters first line total width exceed 100 pixels. Then, stopped s, continue writing many letters second line. Continue process written s.\nReturn array result length 2 where:\n\nresult[0] total number lines.\nresult[1] width last line pixels.\n\n\xc2\xa0\nExample 1:\nInput: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], = "abcdefghijklmnopqrstuvwxyz"\nOutput: [3,60]\nExplanation: You write follows:\nabcdefghij // 100 pixels wide\nklmnopqrst // 100 pixels wide\nuvwxyz // 60 pixels wide\nThere total 3 lines, last line 60 pixels wide.\nExample 2:\nInput: widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], = "bbbcccdddaaa"\nOutput: [2,4]\nExplanation: You write follows:\nbbbcccdddaa // 98 pixels wide\na // 4 pixels wide\nThere total 2 lines, last line 4 pixels wide.\n\xc2\xa0\nConstraints:\n\nwidths.length == 26\n2 <= widths[i] <= 10\n1 <= s.length <= 1000\ns contains lowercase English letters.\n\n' b"There city composed n x n blocks, block contains single building shaped like vertical square prism. You given 0-indexed n x n integer matrix grid grid[r][c] represents height building located block row r column c.\nA city's skyline outer contour formed building viewing side city distance. The skyline cardinal direction north, east, south, west may different.\nWe allowed increase height number buildings amount (the amount different per building). The height 0-height building also increased. However, increasing height building affect city's skyline cardinal direction.\nReturn maximum total sum height buildings increased without changing city's skyline cardinal direction.\n\xc2\xa0\nExample 1:\n\nInput: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\nOutput: 35\nExplanation: The building heights shown center image.\nThe skylines viewed cardinal direction drawn red.\nThe grid increasing height buildings without affecting skylines is:\ngridNew = [ [8, 4, 8, 7],\n [7, 4, 7, 7],\n [9, 4, 8, 7],\n [3, 3, 3, 3] ]\n\nExample 2:\nInput: grid = [[0,0,0],[0,0,0],[0,0,0]]\nOutput: 0\nExplanation: Increasing height building result skyline changing.\n\n\xc2\xa0\nConstraints:\n\nn == grid.length\nn == grid[r].length\n2 <= n <= 50\n0 <= grid[r][c] <= 100\n\n" b"There two types soup: type A type B. Initially, n ml type soup. There four kinds operations:\n\nServe 100 ml soup A 0 ml soup B,\nServe 75 ml soup A 25 ml soup B,\nServe 50 ml soup A 50 ml soup B, and\nServe 25 ml soup A 75 ml soup B.\n\nWhen serve soup, give someone, longer it. Each turn, choose four operations equal probability 0.25. If remaining volume soup enough complete operation, serve much possible. We stop longer quantity types soup.\nNote operation 100 ml's soup B used first.\nReturn probability soup A empty first, plus half probability A B become empty time. Answers within 10-5 actual answer accepted.\n\xc2\xa0\nExample 1:\nInput: n = 50\nOutput: 0.62500\nExplanation: If choose first two operations, A become empty first.\nFor third operation, A B become empty time.\nFor fourth operation, B become empty first.\nSo total probability A becoming empty first plus half probability A B become empty time, 0.25 * (1 + 1 + 0.5 + 0) = 0.625.\n\nExample 2:\nInput: n = 100\nOutput: 0.71875\n\n\xc2\xa0\nConstraints:\n\n0 <= n <= 109\n\n" b'Sometimes people repeat letters represent extra feeling. For example:\n\n"hello" -> "heeellooo"\n"hi" -> "hiiii"\n\nIn strings like "heeellooo", groups adjacent letters same: "h", "eee", "ll", "ooo".\nYou given string array query strings words. A query word stretchy made equal number applications following extension operation: choose group consisting characters c, add number characters c group size group three more.\n\nFor example, starting "hello", could extension group "o" get "hellooo", cannot get "helloo" since group "oo" size less three. Also, could another extension like "ll" -> "lllll" get "helllllooo". If = "helllllooo", query word "hello" would stretchy two extension operations: query = "hello" -> "hellooo" -> "helllllooo" = s.\n\nReturn number query strings stretchy.\n\xc2\xa0\nExample 1:\nInput: = "heeellooo", words = ["hello", "hi", "helo"]\nOutput: 1\nExplanation: \nWe extend "e" "o" word "hello" get "heeellooo".\nWe can\'t extend "helo" get "heeellooo" group "ll" size 3 more.\n\nExample 2:\nInput: = "zzzzzyyyyy", words = ["zzyy","zy","zyy"]\nOutput: 3\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length, words.length <= 100\n1 <= words[i].length <= 100\ns words[i] consist lowercase letters.\n\n' b'You given array integers nums represents numbers written chalkboard.\nAlice Bob take turns erasing exactly one number chalkboard, Alice starting first. If erasing number causes bitwise XOR elements chalkboard become 0, player loses. The bitwise XOR one element element itself, bitwise XOR elements 0.\nAlso, player starts turn bitwise XOR elements chalkboard equal 0, player wins.\nReturn true Alice wins game, assuming players play optimally.\n\xc2\xa0\nExample 1:\nInput: nums = [1,1,2]\nOutput: false\nExplanation: \nAlice two choices: erase 1 erase 2. \nIf erases 1, nums array becomes [1, 2]. The bitwise XOR elements chalkboard 1 XOR 2 = 3. Now Bob remove element wants, Alice one erase last element lose. \nIf Alice erases 2 first, nums become [1, 1]. The bitwise XOR elements chalkboard 1 XOR 1 = 0. Alice lose.\n\nExample 2:\nInput: nums = [0,1]\nOutput: true\n\nExample 3:\nInput: nums = [1,2,3]\nOutput: true\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 1000\n0 <= nums[i] < 216\n\n' b'A website domain "discuss.leetcode.com" consists various subdomains. At top level, "com", next level, "leetcode.com"\xc2\xa0and lowest level, "discuss.leetcode.com". When visit domain like "discuss.leetcode.com", also visit parent domains "leetcode.com" "com" implicitly.\nA count-paired domain domain one two formats "rep d1.d2.d3" "rep d1.d2" rep number visits domain d1.d2.d3 domain itself.\n\nFor example, "9001 discuss.leetcode.com" count-paired domain indicates discuss.leetcode.com visited 9001 times.\n\nGiven array count-paired domains cpdomains, return array count-paired domains subdomain input. You may return answer order.\n\xc2\xa0\nExample 1:\nInput: cpdomains = ["9001 discuss.leetcode.com"]\nOutput: ["9001 leetcode.com","9001 discuss.leetcode.com","9001 com"]\nExplanation: We one website domain: "discuss.leetcode.com".\nAs discussed above, subdomain "leetcode.com" "com" also visited. So visited 9001 times.\n\nExample 2:\nInput: cpdomains = ["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]\nOutput: ["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]\nExplanation: We visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" "wiki.org" 5 times.\nFor subdomains, visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, "org" 5 times.\n\n\xc2\xa0\nConstraints:\n\n1 <= cpdomain.length <= 100\n1 <= cpdomain[i].length <= 100\ncpdomain[i] follows either "repi d1i.d2i.d3i" format "repi d1i.d2i" format.\nrepi integer range [1, 104].\nd1i, d2i, d3i consist lowercase English letters.\n\n' b'Given array points X-Y plane points points[i] = [xi, yi], return area largest triangle formed three different points. Answers within 10-5 actual answer accepted.\n\xc2\xa0\nExample 1:\n\nInput: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\nOutput: 2.00000\nExplanation: The five points shown figure. The red triangle largest.\n\nExample 2:\nInput: points = [[1,0],[0,0],[0,1]]\nOutput: 0.50000\n\n\xc2\xa0\nConstraints:\n\n3 <= points.length <= 50\n-50 <= xi, yi <= 50\nAll given points unique.\n\n' b'You given integer array nums integer k. You partition array k non-empty adjacent subarrays. The score partition sum averages subarray.\nNote partition must use every integer nums, score necessarily integer.\nReturn maximum score achieve possible partitions. Answers within 10-6 actual answer accepted.\n\xc2\xa0\nExample 1:\nInput: nums = [9,1,2,3,9], k = 3\nOutput: 20.00000\nExplanation: \nThe best choice partition nums [9], [1, 2, 3], [9]. The answer 9 + (1 + 2 + 3) / 3 + 9 = 20.\nWe could also partitioned nums [9, 1], [2], [3, 9], example.\nThat partition would lead score 5 + 2 + 6 = 13, worse.\n\nExample 2:\nInput: nums = [1,2,3,4,5,6,7], k = 4\nOutput: 20.50000\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 100\n1 <= nums[i] <= 104\n1 <= k <= nums.length\n\n' b'Given root binary tree, return tree every subtree (of given tree) containing 1 removed.\nA subtree node node node plus every node descendant node.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,null,0,0,1]\nOutput: [1,null,0,null,1]\nExplanation: \nOnly red nodes satisfy property "every subtree containing 1".\nThe diagram right represents answer.\n\nExample 2:\n\nInput: root = [1,0,1,0,0,0,1]\nOutput: [1,null,1,null,1]\n\nExample 3:\n\nInput: root = [1,1,0,1,1,0,1,0]\nOutput: [1,1,0,1,1,null,1]\n\n\xc2\xa0\nConstraints:\n\nThe number nodes tree range [1, 200].\nNode.val either 0 1.\n\n' b'You given array routes representing bus routes routes[i] bus route ith bus repeats forever.\n\nFor example, routes[0] = [1, 5, 7], means 0th bus travels sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever.\n\nYou start bus stop source (You bus initially), want go bus stop target. You travel bus stops buses only.\nReturn least number buses must take travel source target. Return -1 possible.\n\xc2\xa0\nExample 1:\nInput: routes = [[1,2,7],[3,6,7]], source = 1, target = 6\nOutput: 2\nExplanation: The best strategy take first bus bus stop 7, take second bus bus stop 6.\n\nExample 2:\nInput: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\nOutput: -1\n\n\xc2\xa0\nConstraints:\n\n1 <= routes.length <= 500.\n1 <= routes[i].length <= 105\nAll values routes[i] unique.\nsum(routes[i].length) <= 105\n0 <= routes[i][j] < 106\n0 <= source, target < 106\n\n' b'We 2-dimensional coordinates, like "(1, 3)" "(2, 0.5)". Then, removed commas, decimal points, spaces ended string s.\n\nFor example, "(1, 3)" becomes = "(13)" "(2, 0.5)" becomes = "(205)".\n\nReturn list strings representing possibilities original coordinates could been.\nOur original representation never extraneous zeroes, never started numbers like "00", "0.0", "0.00", "1.0", "001", "00.01", number represented fewer digits. Also, decimal point within number never occurs without least one digit occurring it, never started numbers like ".1".\nThe final answer list returned order. All coordinates final answer exactly one space (occurring comma.)\n\xc2\xa0\nExample 1:\nInput: = "(123)"\nOutput: ["(1, 2.3)","(1, 23)","(1.2, 3)","(12, 3)"]\n\nExample 2:\nInput: = "(0123)"\nOutput: ["(0, 1.23)","(0, 12.3)","(0, 123)","(0.1, 2.3)","(0.1, 23)","(0.12, 3)"]\nExplanation: 0.0, 00, 0001 00.01 allowed.\n\nExample 3:\nInput: = "(00011)"\nOutput: ["(0, 0.011)","(0.001, 1)"]\n\n\xc2\xa0\nConstraints:\n\n4 <= s.length <= 12\ns[0] == \'(\' s[s.length - 1] == \')\'.\nThe rest digits.\n\n' b'You given head linked list containing unique integer values integer array nums subset linked list values.\nReturn number connected components nums two values connected appear consecutively linked list.\n\xc2\xa0\nExample 1:\n\nInput: head = [0,1,2,3], nums = [0,1,3]\nOutput: 2\nExplanation: 0 1 connected, [0, 1] [3] two connected components.\n\nExample 2:\n\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\nOutput: 2\nExplanation: 0 1 connected, 3 4 connected, [0, 1] [3, 4] two connected components.\n\n\xc2\xa0\nConstraints:\n\nThe number nodes linked list n.\n1 <= n <= 104\n0 <= Node.val < n\nAll values Node.val unique.\n1 <= nums.length <= n\n0 <= nums[i] < n\nAll values nums unique.\n\n' b'Your car starts position 0 speed +1 infinite number line. Your car go negative positions. Your car drives automatically according sequence instructions \'A\' (accelerate) \'R\' (reverse):\n\nWhen get instruction \'A\', car following:\n\n\t\nposition += speed\nspeed *= 2\n\n\nWhen get instruction \'R\', car following:\n\t\nIf speed positive speed = -1\notherwise speed = 1\n\n\tYour position stays same.\n\nFor example, commands "AAR", car goes positions 0 --> 1 --> 3 --> 3, speed goes 1 --> 2 --> 4 --> -1.\nGiven target position target, return length shortest sequence instructions get there.\n\xc2\xa0\nExample 1:\nInput: target = 3\nOutput: 2\nExplanation: \nThe shortest instruction sequence "AA".\nYour position goes 0 --> 1 --> 3.\n\nExample 2:\nInput: target = 6\nOutput: 5\nExplanation: \nThe shortest instruction sequence "AAARA".\nYour position goes 0 --> 1 --> 3 --> 7 --> 7 --> 6.\n\n\xc2\xa0\nConstraints:\n\n1 <= target <= 104\n\n' b'Given string paragraph string array banned words banned, return frequent word banned. It guaranteed least one word banned, answer unique.\nThe words paragraph case-insensitive answer returned lowercase.\n\xc2\xa0\nExample 1:\nInput: paragraph = "Bob hit ball, hit BALL flew far hit.", banned = ["hit"]\nOutput: "ball"\nExplanation: \n"hit" occurs 3 times, banned word.\n"ball" occurs twice (and word does), frequent non-banned word paragraph. \nNote words paragraph case sensitive,\nthat punctuation ignored (even adjacent words, "ball,"), \nand "hit" isn\'t answer even though occurs banned.\n\nExample 2:\nInput: paragraph = "a.", banned = []\nOutput: "a"\n\n\xc2\xa0\nConstraints:\n\n1 <= paragraph.length <= 1000\nparagraph consists English letters, space \' \', one symbols: "!?\',;.".\n0 <= banned.length <= 100\n1 <= banned[i].length <= 10\nbanned[i] consists lowercase English letters.\n\n' b'A valid encoding array words reference string array indices indices that:\n\nwords.length == indices.length\nThe reference string ends \'#\' character.\nFor index indices[i], substring starting indices[i] (but including) next \'#\' character equal words[i].\n\nGiven array words, return length shortest reference string possible valid encoding words.\n\xc2\xa0\nExample 1:\nInput: words = ["time", "me", "bell"]\nOutput: 10\nExplanation: A valid encoding would = "time#bell#" indices = [0, 2, 5].\nwords[0] = "time", substring starting indices[0] = 0 next \'#\' underlined "time#bell#"\nwords[1] = "me", substring starting indices[1] = 2 next \'#\' underlined "time#bell#"\nwords[2] = "bell", substring starting indices[2] = 5 next \'#\' underlined "time#bell#"\n\nExample 2:\nInput: words = ["t"]\nOutput: 2\nExplanation: A valid encoding would = "t#" indices = [0].\n\n\xc2\xa0\nConstraints:\n\n1 <= words.length <= 2000\n1 <= words[i].length <= 7\nwords[i] consists lowercase letters.\n\n' b'Given string character c occurs s, return array integers answer answer.length == s.length answer[i] distance index closest occurrence character c s.\nThe distance two indices j abs(i - j), abs absolute value function.\n\xc2\xa0\nExample 1:\nInput: = "loveleetcode", c = "e"\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\nExplanation: The character \'e\' appears indices 3, 5, 6, 11 (0-indexed).\nThe closest occurrence \'e\' index 0 index 3, distance abs(0 - 3) = 3.\nThe closest occurrence \'e\' index 1 index 3, distance abs(1 - 3) = 2.\nFor index 4, tie \'e\' index 3 \'e\' index 5, distance still same: abs(4 - 3) == abs(4 - 5) = 1.\nThe closest occurrence \'e\' index 8 index 6, distance abs(8 - 6) = 2.\n\nExample 2:\nInput: = "aaab", c = "b"\nOutput: [3,2,1,0]\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 104\ns[i] c lowercase English letters.\nIt guaranteed c occurs least s.\n\n' b'You given two 0-indexed integer arrays fronts backs length n, ith card positive integer fronts[i] printed front backs[i] printed back. Initially, card placed table front number facing facing down. You may flip number cards (possibly zero).\nAfter flipping cards, integer considered good facing card facing card.\nReturn minimum possible good integer flipping cards. If good integers, return 0.\n\xc2\xa0\nExample 1:\nInput: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]\nOutput: 2\nExplanation:\nIf flip second card, face numbers [1,3,4,4,7] face [1,2,4,1,3].\n2 minimum good integer appears facing facing up.\nIt shown 2 minimum possible good integer obtainable flipping cards.\n\nExample 2:\nInput: fronts = [1], backs = [1]\nOutput: 0\nExplanation:\nThere good integers matter flip cards, return 0.\n\n\xc2\xa0\nConstraints:\n\nn == fronts.length == backs.length\n1 <= n <= 1000\n1 <= fronts[i], backs[i] <= 2000\n\n' b"Given array unique integers, arr, integer arr[i] strictly greater 1.\nWe make binary tree using integers, number may used number times. Each non-leaf node's value equal product values children.\nReturn number binary trees make. The answer may large return answer modulo 109 + 7.\n\xc2\xa0\nExample 1:\nInput: arr = [2,4]\nOutput: 3\nExplanation: We make trees: [2], [4], [4, 2, 2]\nExample 2:\nInput: arr = [2,4,5,10]\nOutput: 7\nExplanation: We make trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].\n\xc2\xa0\nConstraints:\n\n1 <= arr.length <= 1000\n2 <= arr[i] <= 109\nAll values arr unique.\n\n" b'You given string sentence consist words separated spaces. Each word consists lowercase uppercase letters only.\nWe would like convert sentence "Goat Latin" (a made-up language similar Pig Latin.) The rules Goat Latin follows:\n\nIf word begins vowel (\'a\', \'e\', \'i\', \'o\', \'u\'), append "ma" end word.\n\n\t\nFor example, word "apple" becomes "applema".\n\n\nIf word begins consonant (i.e., vowel), remove first letter append end, add "ma".\n\t\nFor example, word "goat" becomes "oatgma".\n\n\nAdd one letter \'a\' end word per word index sentence, starting 1.\n\t\nFor example, first word gets "a" added end, second word gets "aa" added end, on.\n\n\n\nReturn final sentence representing conversion sentence Goat Latin.\n\xc2\xa0\nExample 1:\nInput: sentence = "I speak Goat Latin"\nOutput: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"\nExample 2:\nInput: sentence = "The quick brown fox jumped lazy dog"\nOutput: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"\n\n\xc2\xa0\nConstraints:\n\n1 <= sentence.length <= 150\nsentence consists English letters spaces.\nsentence leading trailing spaces.\nAll words sentence separated single space.\n\n' b'There n persons social media website. You given integer array ages ages[i] age ith person.\nA Person x send friend request person (x != y) following conditions true:\n\nage[y] <= 0.5 * age[x] + 7\nage[y] > age[x]\nage[y] > 100 && age[x] < 100\n\nOtherwise, x send friend request y.\nNote x sends request y, necessarily send request x. Also, person send friend request themself.\nReturn total number friend requests made.\n\xc2\xa0\nExample 1:\nInput: ages = [16,16]\nOutput: 2\nExplanation: 2 people friend request other.\n\nExample 2:\nInput: ages = [16,17,18]\nOutput: 2\nExplanation: Friend requests made 17 -> 16, 18 -> 17.\n\nExample 3:\nInput: ages = [20,30,100,110,120]\nOutput: 3\nExplanation: Friend requests made 110 -> 100, 120 -> 110, 120 -> 100.\n\n\xc2\xa0\nConstraints:\n\nn == ages.length\n1 <= n <= 2 * 104\n1 <= ages[i] <= 120\n\n' b'You n jobs workers. You given three arrays: difficulty, profit, worker where:\n\ndifficulty[i] profit[i] difficulty profit ith job, and\nworker[j] ability jth worker (i.e., jth worker complete job difficulty worker[j]).\n\nEvery worker assigned one job, one job completed multiple times.\n\nFor example, three workers attempt job pays $1, total profit $3. If worker cannot complete job, profit $0.\n\nReturn maximum profit achieve assigning workers jobs.\n\xc2\xa0\nExample 1:\nInput: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\nOutput: 100\nExplanation: Workers assigned jobs difficulty [4,4,6,6] get profit [20,20,30,30] separately.\n\nExample 2:\nInput: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\nn == difficulty.length\nn == profit.length\nm == worker.length\n1 <= n, <= 104\n1 <= difficulty[i], profit[i], worker[i] <= 105\n\n' b"You given n x n binary matrix grid. You allowed change one 0 1.\nReturn size largest island grid applying operation.\nAn island 4-directionally connected group 1s.\n\xc2\xa0\nExample 1:\nInput: grid = [[1,0],[0,1]]\nOutput: 3\nExplanation: Change one 0 1 connect two 1s, get island area = 3.\n\nExample 2:\nInput: grid = [[1,1],[1,0]]\nOutput: 4\nExplanation: Change 0 1 make island bigger, one island area = 4.\nExample 3:\nInput: grid = [[1,1],[1,1]]\nOutput: 4\nExplanation: Can't change 0 1, one island area = 4.\n\n\xc2\xa0\nConstraints:\n\nn == grid.length\nn == grid[i].length\n1 <= n <= 500\ngrid[i][j] either 0 1.\n" b'Let\'s define function countUniqueChars(s) returns number unique characters s.\n\nFor example, calling countUniqueChars(s) = "LEETCODE" "L", "T", "C", "O", "D" unique characters since appear s, therefore countUniqueChars(s) = 5.\n\nGiven string s, return sum countUniqueChars(t) substring s.\nNotice substrings repeated case count repeated ones too.\n\xc2\xa0\nExample 1:\nInput: = "ABC"\nOutput: 10\nExplanation: All possible substrings are: "A","B","C","AB","BC" "ABC".\nEvery substring composed unique letters.\nSum lengths substring 1 + 1 + 1 + 2 + 2 + 3 = 10\n\nExample 2:\nInput: = "ABA"\nOutput: 8\nExplanation: The example 1, except countUniqueChars("ABA") = 1.\n\nExample 3:\nInput: = "LEETCODE"\nOutput: 92\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 105\ns consists uppercase English letters only.\n\n' b'Given integer n, return number ways write n sum consecutive positive integers.\n\xc2\xa0\nExample 1:\nInput: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\n\nExample 2:\nInput: n = 9\nOutput: 3\nExplanation: 9 = 4 + 5 = 2 + 3 + 4\n\nExample 3:\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 109\n\n' b'In string s\xc2\xa0of lowercase letters, letters form consecutive groups character.\nFor example, string like = "abbxxxxzyy" groups "a", "bb", "xxxx", "z", and\xc2\xa0"yy".\nA group identified interval\xc2\xa0[start, end], where\xc2\xa0start\xc2\xa0and\xc2\xa0end\xc2\xa0denote start end\xc2\xa0indices (inclusive) group. In example,\xc2\xa0"xxxx"\xc2\xa0has interval\xc2\xa0[3,6].\nA group considered\xc2\xa0large\xc2\xa0if 3 characters.\nReturn\xc2\xa0the intervals every large group sorted in\xc2\xa0increasing order start index.\n\xc2\xa0\nExample 1:\nInput: = "abbxxxxzzy"\nOutput: [[3,6]]\nExplanation: "xxxx" large group start index 3 end index 6.\n\nExample 2:\nInput: = "abc"\nOutput: []\nExplanation: We groups "a", "b", "c", none large groups.\n\nExample 3:\nInput: = "abcdddeeeeaabbbcd"\nOutput: [[3,5],[6,9],[12,14]]\nExplanation: The large groups "ddd", "eeee", "bbb".\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 1000\ns contains lowercase English letters only.\n\n' b'You given personal information string s, representing either email address phone number. Return masked personal information using rules.\nEmail address:\nAn email address is:\n\nA name consisting uppercase lowercase English letters, followed by\nThe \'@\' symbol, followed by\nThe domain consisting uppercase lowercase English letters dot \'.\' somewhere middle (not first last character).\n\nTo mask email:\n\nThe uppercase letters name domain must converted lowercase letters.\nThe middle letters name (i.e., first last letters) must replaced 5 asterisks "*****".\n\nPhone number:\nA phone number formatted follows:\n\nThe phone number contains 10-13 digits.\nThe last 10 digits make local number.\nThe remaining 0-3 digits, beginning, make country code.\nSeparation characters set {\'+\', \'-\', \'(\', \')\', \' \'} separate digits way.\n\nTo mask phone number:\n\nRemove separation characters.\nThe masked phone number form:\n\t\n"***-***-XXXX" country code 0 digits.\n"+*-***-***-XXXX" country code 1 digit.\n"+**-***-***-XXXX" country code 2 digits.\n"+***-***-***-XXXX" country code 3 digits.\n\n\n"XXXX" last 4 digits local number.\n\n\xc2\xa0\nExample 1:\nInput: = "LeetCode@LeetCode.com"\nOutput: "l*****e@leetcode.com"\nExplanation: email address.\nThe name domain converted lowercase, middle name replaced 5 asterisks.\n\nExample 2:\nInput: = "AB@qq.com"\nOutput: "a*****b@qq.com"\nExplanation: email address.\nThe name domain converted lowercase, middle name replaced 5 asterisks.\nNote even though "ab" 2 characters, still must 5 asterisks middle.\n\nExample 3:\nInput: = "1(234)567-890"\nOutput: "***-***-7890"\nExplanation: phone number.\nThere 10 digits, local number 10 digits country code 0 digits.\nThus, resulting masked number "***-***-7890".\n\n\xc2\xa0\nConstraints:\n\ns either valid email phone number.\nIf email:\n\t\n8 <= s.length <= 40\ns consists uppercase lowercase English letters exactly one \'@\' symbol \'.\' symbol.\n\n\nIf phone number:\n\t\n10 <= s.length <= 20\ns consists digits, spaces, symbols \'(\', \')\', \'-\', \'+\'.\n\n\n\n' b'Given n x n binary matrix image, flip image horizontally, invert it, return resulting image.\nTo flip image horizontally means row image reversed.\n\nFor example, flipping [1,1,0] horizontally results [0,1,1].\n\nTo invert image means 0 replaced 1, 1 replaced 0.\n\nFor example, inverting [0,1,1] results [1,0,0].\n\n\xc2\xa0\nExample 1:\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\nExplanation: First reverse row: [[0,1,1],[1,0,1],[0,0,0]].\nThen, invert image: [[1,0,0],[0,1,0],[1,1,1]]\n\nExample 2:\nInput: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\nOutput: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\nExplanation: First reverse row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].\nThen invert image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\n\xc2\xa0\nConstraints:\n\nn == image.length\nn == image[i].length\n1 <= n <= 20\nimages[i][j] either 0 1.\n\n' b'You given 0-indexed string must perform k replacement operations on. The replacement operations given three 0-indexed parallel arrays, indices, sources, targets, length k.\nTo complete ith replacement operation:\n\nCheck substring sources[i] occurs index indices[i] original string s.\nIf occur, nothing.\nOtherwise occur, replace substring targets[i].\n\nFor example, = "abcd", indices[i] = 0, sources[i] = "ab", targets[i] = "eee", result replacement "eeecd".\nAll replacement operations must occur simultaneously, meaning replacement operations affect indexing other. The testcases generated replacements overlap.\n\nFor example, testcase = "abc", indices = [0, 1], sources = ["ab","bc"] generated "ab" "bc" replacements overlap.\n\nReturn resulting string performing replacement operations s.\nA substring contiguous sequence characters string.\n\xc2\xa0\nExample 1:\n\nInput: = "abcd", indices = [0, 2], sources = ["a", "cd"], targets = ["eee", "ffff"]\nOutput: "eeebffff"\nExplanation:\n"a" occurs index 0 s, replace "eee".\n"cd" occurs index 2 s, replace "ffff".\n\nExample 2:\n\nInput: = "abcd", indices = [0, 2], sources = ["ab","ec"], targets = ["eee","ffff"]\nOutput: "eeecd"\nExplanation:\n"ab" occurs index 0 s, replace "eee".\n"ec" occur index 2 s, nothing.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 1000\nk == indices.length == sources.length == targets.length\n1 <= k <= 100\n0 <= indexes[i] < s.length\n1 <= sources[i].length, targets[i].length <= 50\ns consists lowercase English letters.\nsources[i] targets[i] consist lowercase English letters.\n\n' b'There undirected connected tree n nodes labeled 0 n - 1 n - 1 edges.\nYou given integer n array edges edges[i] = [ai, bi] indicates edge nodes ai bi tree.\nReturn array answer length n answer[i] sum distances ith node tree nodes.\n\xc2\xa0\nExample 1:\n\nInput: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\nOutput: [8,12,6,10,10,10]\nExplanation: The tree shown above.\nWe see dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer[0] = 8, on.\n\nExample 2:\n\nInput: n = 1, edges = []\nOutput: [0]\n\nExample 3:\n\nInput: n = 2, edges = [[1,0]]\nOutput: [1,1]\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 3 * 104\nedges.length == n - 1\nedges[i].length == 2\n0 <= ai, bi < n\nai != bi\nThe given input represents valid tree.\n\n' b'You given two images, img1 img2, represented binary, square matrices size n x n. A binary matrix 0s 1s values.\nWe translate one image however choose sliding 1 bits left, right, up, and/or number units. We place top image. We calculate overlap counting number positions 1 images.\nNote also translation include kind rotation. Any 1 bits translated outside matrix borders erased.\nReturn largest possible overlap.\n\xc2\xa0\nExample 1:\n\nInput: img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]\nOutput: 3\nExplanation: We translate img1 right 1 unit 1 unit.\n\nThe number positions 1 images 3 (shown red).\n\n\nExample 2:\nInput: img1 = [[1]], img2 = [[1]]\nOutput: 1\n\nExample 3:\nInput: img1 = [[0]], img2 = [[0]]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\nn == img1.length == img1[i].length\nn == img2.length == img2[i].length\n1 <= n <= 30\nimg1[i][j] either 0 1.\nimg2[i][j] either 0 1.\n\n' b'An axis-aligned rectangle represented list [x1, y1, x2, y2], (x1, y1) coordinate bottom-left corner, (x2, y2) coordinate top-right corner. Its top bottom edges parallel X-axis, left right edges parallel Y-axis.\nTwo rectangles overlap area intersection positive. To clear, two rectangles touch corner edges overlap.\nGiven two axis-aligned rectangles rec1 rec2, return true overlap, otherwise return false.\n\xc2\xa0\nExample 1:\nInput: rec1 = [0,0,2,2], rec2 = [1,1,3,3]\nOutput: true\nExample 2:\nInput: rec1 = [0,0,1,1], rec2 = [1,0,2,1]\nOutput: false\nExample 3:\nInput: rec1 = [0,0,1,1], rec2 = [2,2,3,3]\nOutput: false\n\n\xc2\xa0\nConstraints:\n\nrec1.length == 4\nrec2.length == 4\n-109 <= rec1[i], rec2[i] <= 109\nrec1 rec2 represent valid rectangle non-zero area.\n\n' b'Alice plays following game, loosely based card game "21".\nAlice starts 0 points draws numbers less k points. During draw, gains integer number points randomly range [1, maxPts], maxPts integer. Each draw independent outcomes equal probabilities.\nAlice stops drawing numbers gets k points.\nReturn probability Alice n fewer points.\nAnswers within 10-5 actual answer considered accepted.\n\xc2\xa0\nExample 1:\nInput: n = 10, k = 1, maxPts = 10\nOutput: 1.00000\nExplanation: Alice gets single card, stops.\n\nExample 2:\nInput: n = 6, k = 1, maxPts = 10\nOutput: 0.60000\nExplanation: Alice gets single card, stops.\nIn 6 10 possibilities, 6 points.\n\nExample 3:\nInput: n = 21, k = 17, maxPts = 10\nOutput: 0.73278\n\n\xc2\xa0\nConstraints:\n\n0 <= k <= n <= 104\n1 <= maxPts <= 104\n\n' b'There n dominoes line, place domino vertically upright. In beginning, simultaneously push dominoes either left right.\nAfter second, domino falling left pushes adjacent domino left. Similarly, dominoes falling right push adjacent dominoes standing right.\nWhen vertical domino dominoes falling sides, stays still due balance forces.\nFor purposes question, consider falling domino expends additional force falling already fallen domino.\nYou given string dominoes representing initial state where:\n\ndominoes[i] = \'L\', ith domino pushed left,\ndominoes[i] = \'R\', ith domino pushed right, and\ndominoes[i] = \'.\', ith domino pushed.\n\nReturn string representing final state.\n\xc2\xa0\nExample 1:\nInput: dominoes = "RR.L"\nOutput: "RR.L"\nExplanation: The first domino expends additional force second domino.\n\nExample 2:\n\nInput: dominoes = ".L.R...LR..L.."\nOutput: "LL.RR.LLRRLL.."\n\n\xc2\xa0\nConstraints:\n\nn == dominoes.length\n1 <= n <= 105\ndominoes[i] either \'L\', \'R\', \'.\'.\n\n' b'Two strings X\xc2\xa0and Y\xc2\xa0are similar swap two letters (in different positions) X, that\xc2\xa0it equals Y. Also two strings X Y similar equal.\nFor example, "tars"\xc2\xa0and "rats"\xc2\xa0are similar (swapping positions 0 2), "rats" "arts" similar, "star" similar "tars", "rats", "arts".\nTogether, form two connected groups similarity: {"tars", "rats", "arts"} {"star"}.\xc2\xa0 Notice "tars" "arts" group even though similar.\xc2\xa0 Formally, group word group similar least one word group.\nWe given list strs strings every string strs anagram every string strs. How many groups there?\n\xc2\xa0\nExample 1:\nInput: strs = ["tars","rats","arts","star"]\nOutput: 2\n\nExample 2:\nInput: strs = ["omv","ovm"]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= strs.length <= 300\n1 <= strs[i].length <= 300\nstrs[i] consists lowercase letters only.\nAll words strs length anagrams other.\n\n' b'A 3 x 3 magic square 3 x 3 grid filled distinct numbers 1 9 row, column, diagonals sum.\nGiven row x col\xc2\xa0grid\xc2\xa0of integers, many 3 x 3 "magic square" subgrids there?\xc2\xa0 (Each subgrid contiguous).\n\xc2\xa0\nExample 1:\n\nInput: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid 3 x 3 magic square:\n\nwhile one not:\n\nIn total, one magic square inside given grid.\n\nExample 2:\nInput: grid = [[8]]\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\nrow == grid.length\ncol == grid[i].length\n1 <= row, col <= 10\n0 <= grid[i][j] <= 15\n\n' b'There n rooms labeled 0 n - 1\xc2\xa0and rooms locked except room 0. Your goal visit rooms. However, cannot enter locked room without key.\nWhen visit room, may find set distinct keys it. Each key number it, denoting room unlocks, take unlock rooms.\nGiven array rooms rooms[i] set keys obtain visited room i, return true visit rooms, false otherwise.\n\xc2\xa0\nExample 1:\nInput: rooms = [[1],[2],[3],[]]\nOutput: true\nExplanation: \nWe visit room 0 pick key 1.\nWe visit room 1 pick key 2.\nWe visit room 2 pick key 3.\nWe visit room 3.\nSince able visit every room, return true.\n\nExample 2:\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\nOutput: false\nExplanation: We enter room number 2 since key unlocks room.\n\n\xc2\xa0\nConstraints:\n\nn == rooms.length\n2 <= n <= 1000\n0 <= rooms[i].length <= 1000\n1 <= sum(rooms[i].length) <= 3000\n0 <= rooms[i][j] < n\nAll values rooms[i] unique.\n\n' b'You given string digits num, "123456579". We split Fibonacci-like sequence [123, 456, 579].\nFormally, Fibonacci-like sequence list f non-negative integers that:\n\n0 <= f[i] < 231, (that is, integer fits 32-bit signed integer type),\nf.length >= 3, and\nf[i] + f[i + 1] == f[i + 2] 0 <= < f.length - 2.\n\nNote splitting string pieces, piece must extra leading zeroes, except piece number 0 itself.\nReturn Fibonacci-like sequence split num, return [] cannot done.\n\xc2\xa0\nExample 1:\nInput: num = "1101111"\nOutput: [11,0,11,11]\nExplanation: The output [110, 1, 111] would also accepted.\n\nExample 2:\nInput: num = "112358130"\nOutput: []\nExplanation: The task impossible.\n\nExample 3:\nInput: num = "0123"\nOutput: []\nExplanation: Leading zeroes allowed, "01", "2", "3" valid.\n\n\xc2\xa0\nConstraints:\n\n1 <= num.length <= 200\nnum contains digits.\n\n' b'This interactive problem.\nYou given array unique strings wordlist wordlist[i] 6 letters long, one word list chosen secret.\nYou may call Master.guess(word) guess word. The guessed word type string must original list 6 lowercase letters.\nThis function returns integer type, representing number exact matches (value position) guess secret word. Also, guess given wordlist, return -1 instead.\nFor test case, exactly 10 guesses guess word. At end number calls, made 10 fewer calls Master.guess least one guesses secret, pass test case.\n\xc2\xa0\nExample 1:\nInput: secret = "acckzz", wordlist = ["acckzz","ccbazz","eiowzz","abcczz"], numguesses = 10\nOutput: You guessed secret word correctly.\nExplanation:\nmaster.guess("aaaaaa") returns -1, "aaaaaa" wordlist.\nmaster.guess("acckzz") returns 6, "acckzz" secret 6 matches.\nmaster.guess("ccbazz") returns 3, "ccbazz" 3 matches.\nmaster.guess("eiowzz") returns 2, "eiowzz" 2 matches.\nmaster.guess("abcczz") returns 4, "abcczz" 4 matches.\nWe made 5 calls master.guess one secret, pass test case.\n\nExample 2:\nInput: secret = "hamada", wordlist = ["hamada","khaled"], numguesses = 10\nOutput: You guessed secret word correctly.\n\n\xc2\xa0\nConstraints:\n\n1 <= wordlist.length <= 100\nwordlist[i].length == 6\nwordlist[i] consist lowercase English letters.\nAll strings wordlist unique.\nsecret exists wordlist.\nnumguesses == 10\n\n' b'Given two strings t, return true equal typed empty text editors. \'#\' means backspace character.\nNote backspacing empty text, text continue empty.\n\xc2\xa0\nExample 1:\nInput: = "ab#c", = "ad#c"\nOutput: true\nExplanation: Both become "ac".\n\nExample 2:\nInput: = "ab##", = "c#d#"\nOutput: true\nExplanation: Both become "".\n\nExample 3:\nInput: = "a#c", = "b"\nOutput: false\nExplanation: becomes "c" becomes "b".\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length, t.length <= 200\ns contain lowercase letters \'#\' characters.\n\n\xc2\xa0\nFollow up: Can solve O(n) time O(1) space?\n' b'You may recall array arr mountain array if:\n\narr.length >= 3\nThere exists index (0-indexed) 0 < < arr.length - 1 that:\n\t\narr[0] < arr[1] < ... < arr[i - 1] < arr[i]\narr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n\n\n\nGiven integer array arr, return length longest subarray, mountain. Return 0 mountain subarray.\n\xc2\xa0\nExample 1:\nInput: arr = [2,1,4,7,3,2,5]\nOutput: 5\nExplanation: The largest mountain [1,4,7,3,2] length 5.\n\nExample 2:\nInput: arr = [2,2,2]\nOutput: 0\nExplanation: There mountain.\n\n\xc2\xa0\nConstraints:\n\n1 <= arr.length <= 104\n0 <= arr[i] <= 104\n\n\xc2\xa0\nFollow up:\n\nCan solve using one pass?\nCan solve O(1) space?\n\n' b"Alice number cards wants rearrange cards groups group size groupSize, consists groupSize consecutive cards.\nGiven integer array hand hand[i] value written ith card integer groupSize, return true rearrange cards, false otherwise.\n\xc2\xa0\nExample 1:\nInput: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3\nOutput: true\nExplanation: Alice's hand rearranged [1,2,3],[2,3,4],[6,7,8]\n\nExample 2:\nInput: hand = [1,2,3,4,5], groupSize = 4\nOutput: false\nExplanation: Alice's hand rearranged groups 4.\n\n\n\xc2\xa0\nConstraints:\n\n1 <= hand.length <= 104\n0 <= hand[i] <= 109\n1 <= groupSize <= hand.length\n\n\xc2\xa0\nNote: This question 1296: https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/\n" b'You undirected, connected graph n nodes labeled 0 n - 1. You given array graph graph[i] list nodes connected node edge.\nReturn length shortest path visits every node. You may start stop node, may revisit nodes multiple times, may reuse edges.\n\xc2\xa0\nExample 1:\n\nInput: graph = [[1,2,3],[0],[0],[0]]\nOutput: 4\nExplanation: One possible path [1,0,2,0,3]\n\nExample 2:\n\nInput: graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]\nOutput: 4\nExplanation: One possible path [0,1,4,2,3]\n\n\xc2\xa0\nConstraints:\n\nn == graph.length\n1 <= n <= 12\n0 <= graph[i].length <\xc2\xa0n\ngraph[i] contain i.\nIf graph[a] contains b, graph[b] contains a.\nThe input graph always connected.\n\n' b'You given string lowercase English letters integer array shifts length.\nCall shift() letter, next letter alphabet, (wrapping around \'z\' becomes \'a\').\n\nFor example, shift(\'a\') = \'b\', shift(\'t\') = \'u\', shift(\'z\') = \'a\'.\n\nNow shifts[i] = x, want shift first + 1 letters s, x times.\nReturn final string shifts applied.\n\xc2\xa0\nExample 1:\nInput: = "abc", shifts = [3,5,9]\nOutput: "rpl"\nExplanation: We start "abc".\nAfter shifting first 1 letters 3, "dbc".\nAfter shifting first 2 letters 5, "igc".\nAfter shifting first 3 letters 9, "rpl", answer.\n\nExample 2:\nInput: = "aaa", shifts = [1,2,3]\nOutput: "gfd"\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 105\ns consists lowercase English letters.\nshifts.length == s.length\n0 <= shifts[i] <= 109\n\n' b'You given array representing row seats seats[i] = 1 represents person sitting ith seat, seats[i] = 0 represents ith seat empty (0-indexed).\nThere least one empty seat, least one person sitting.\nAlex wants sit seat distance closest person maximized.\xc2\xa0\nReturn maximum distance closest person.\n\xc2\xa0\nExample 1:\n\nInput: seats = [1,0,0,0,1,0,1]\nOutput: 2\nExplanation: \nIf Alex sits second open seat (i.e. seats[2]), closest person distance 2.\nIf Alex sits open seat, closest person distance 1.\nThus, maximum distance closest person 2.\n\nExample 2:\nInput: seats = [1,0,0,0]\nOutput: 3\nExplanation: \nIf Alex sits last seat (i.e. seats[3]), closest person 3 seats away.\nThis maximum distance possible, answer 3.\n\nExample 3:\nInput: seats = [0,1]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n2 <= seats.length <= 2 * 104\nseats[i]\xc2\xa0is 0 or\xc2\xa01.\nAt least one seat empty.\nAt least one seat occupied.\n\n' b'You given 2D array axis-aligned rectangles. Each rectangle[i] = [xi1, yi1, xi2, yi2] denotes ith rectangle (xi1, yi1) coordinates bottom-left corner, (xi2, yi2) coordinates top-right corner.\nCalculate total area covered rectangles plane. Any area covered two rectangles counted once.\nReturn total area. Since answer may large, return modulo 109 + 7.\n\xc2\xa0\nExample 1:\n\nInput: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\nOutput: 6\nExplanation: A total area 6 covered three rectangales, illustrated picture.\nFrom (1,1) (2,2), green red rectangles overlap.\nFrom (1,0) (2,3), three rectangles overlap.\n\nExample 2:\nInput: rectangles = [[0,0,1000000000,1000000000]]\nOutput: 49\nExplanation: The answer 1018 modulo (109 + 7), 49.\n\n\xc2\xa0\nConstraints:\n\n1 <= rectangles.length <= 200\nrectanges[i].length == 4\n0 <= xi1, yi1, xi2, yi2 <= 109\n\n'